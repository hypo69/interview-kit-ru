### `question_065.md`

**Вопрос 065.** Какой будет результат выполнения следующего кода?

```python
def modify_list(lst):
    lst.append(4)
    lst = lst + [5]
    return lst

my_list = [1, 2, 3]
new_list = modify_list(my_list)
print(my_list)
print(new_list)
```

- A. `[1, 2, 3] [1, 2, 3, 4, 5]`
- B. `[1, 2, 3, 4] [1, 2, 3, 4, 5]`
- C. `[1, 2, 3, 4, 5] [1, 2, 3, 4, 5]`
- D. `[1, 2, 3] [1, 2, 3, 5]`

**Правильный ответ: B**

**Объяснение:**

Этот код демонстрирует разницу между мутированием списка и созданием нового списка, а также то, как это влияет на переменные в Python.

1. **Изначальный список:** `my_list` инициализируется как `[1, 2, 3]`.
2. **Функция `modify_list`:**
   * Принимает список `lst` в качестве аргумента.
   * `lst.append(4)`:  Метод `append` *мутирует* список, добавляя 4 в конец. Теперь `lst` (изначально `my_list`) стал `[1, 2, 3, 4]`.
   * `lst = lst + [5]`: Операция `+` создает *новый* список, объединяя `lst` c `[5]`.  Результат присваивается *локальной* переменной `lst` внутри функции.  Это **не** изменяет  `my_list` в глобальной области видимости.
   *  Возвращается *новый* список `lst`.
3. **Вызов `modify_list`:** Функция вызывается с `my_list` как аргументом.  Возвращаемый *новый* список присваивается переменной `new_list`.
4. **Вывод:**
   *   `print(my_list)` выведет  `[1, 2, 3, 4]`, так как  `my_list` был мутирован внутри функции.
   *   `print(new_list)` выведет `[1, 2, 3, 4, 5]`, который является новым списком, созданным в функции и возвращенным.

**Дополнительные замечания:**
*   Метод `append` изменяет исходный список (мутирует его).
*   Оператор `+`  создает новый список, не изменяя исходные.
*   Присваивание внутри функции создает локальную переменную, которая никак не влияет на переменную с тем же именем, объявленную за пределами этой функции.
*   Понимание разницы между мутацией и созданием новых объектов важно для предотвращения нежелательных побочных эффектов при работе со списками в Python.
