### `question_082.md`

**Вопрос 82** Какой будет результат выполнения следующего кода?

```python
def my_function(n):
    if n == 0:
       return 1
    else:
        return n * my_function(n-1)

print(my_function(5))
```

- A.  1
- B.  5
- C.  120
- D.  Вызовет ошибку переполнения стека.

**Правильный ответ: C**

**Объяснение:**

Данный код реализует рекурсивную функцию для вычисления факториала числа. Функция `my_function(n)` возвращает n! (факториал n).

*   **Точка выхода из рекурсии:** Если `n` равно 0, функция возвращает 1 (факториал 0 равен 1). Это условие необходимо для завершения рекурсивных вызовов.
*   **Рекурсивный случай:** Если `n` больше 0, функция возвращает `n` умноженное на результат вызова самой себя с `n-1`.

Таким образом, вызов `my_function(5)` будет выполнен следующим образом:

```
my_function(5) = 5 * my_function(4)
my_function(4) = 4 * my_function(3)
my_function(3) = 3 * my_function(2)
my_function(2) = 2 * my_function(1)
my_function(1) = 1 * my_function(0)
my_function(0) = 1
```

Подставляя значения снизу вверх, получаем:

`1 * 1 * 2 * 3 * 4 * 5 = 120`

Следовательно, результат вызова `print(my_function(5))` будет `120`.

**Дополнительные замечания:**
- Рекурсивные функции должны иметь условие выхода из рекурсии, чтобы избежать бесконечного вызова функций и ошибки переполнения стека.
- Данная рекурсивная реализация факториала вполне подходит для небольших чисел, но для очень больших чисел может быть менее эффективна, чем итеративная реализация. Вот пример итеративной реализации факториала:

```python
def factorial_iterative(n):
  result = 1
  for i in range(1, n + 1):
    result *= i
  return result
```

- Итеративная реализация часто более эффективна по памяти, так как не использует стек вызовов.
