### `question_213.md`

**Вопрос 13.**  Что такое "полиморфизм" в контексте объектно-ориентированного программирования?

A. Это возможность наследовать методы только из одного родительского класса.
B. Это способность объектов разных классов иметь общую структуру данных.
C. Это способность объектов разных классов реагировать на один и тот же метод по-разному.
D. Это возможность скрыть внутренние детали класса.

**Правильный ответ: C**

**Объяснение:**

Полиморфизм (от греческого "многоформенность") в объектно-ориентированном программировании (ООП) — это способность объектов разных классов реагировать на один и тот же метод по-своему. Это означает, что вы можете использовать один и тот же интерфейс (метод) для различных типов объектов, и каждый объект будет выполнять соответствующие ему действия.

*   **Вариант A** не верен:  Это понятие относится к наследованию, а не к полиморфизму.
*   **Вариант B** не верен: Общая структура данных, не относится к полиморфизму, а скорее к наследованию.
*   **Вариант C** верен: Полиморфизм дает объектам разных классов возможность по-разному реагировать на один и тот же метод.
*  **Вариант D** не верен:  Это относится к инкапсуляции, а не к полиморфизму.

**Как работает полиморфизм:**

1.  Разные классы могут иметь методы с одинаковым именем.
2.  Метод вызывается через интерфейс, а какое действие будет выполнено определяется на основе типа объекта.

**Пример:**

```python
class Animal:
    def make_sound(self):
        print("Generic animal sound")

class Dog(Animal):
    def make_sound(self):
        print("Woof!")

class Cat(Animal):
    def make_sound(self):
      print("Meow!")

def animal_speak(animal: Animal):
    animal.make_sound() # Полиморфный вызов метода make_sound()

animal: Animal = Animal()
dog: Dog = Dog()
cat: Cat = Cat()
animal_speak(animal) # Вывод: Generic animal sound
animal_speak(dog)  # Вывод: Woof!
animal_speak(cat)  # Вывод: Meow!
```

**В результате:**
* Функция `animal_speak()` может вызывать метод `make_sound()` на разных объектах, и каждый объект вызывает свою реализацию метода.

Таким образом, **вариант C** является правильным ответом.
