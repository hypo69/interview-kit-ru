### `question_210.md`

**Вопрос 210.** Что такое "инкапсуляция" в объектно-ориентированном программировании (ООП) и какую пользу она приносит?

A. Инкапсуляция — это механизм наследования классов.
B. Инкапсуляция — это способность объектов разных классов вести себя единообразно через общий интерфейс.
C. Инкапсуляция — это принцип объединения данных и методов, работающих с этими данными, в пределах класса, а также сокрытия внутренней реализации объекта и предоставление доступа к ней через публичный интерфейс.
D. Инкапсуляция — это способ создания статических методов, принадлежащих классу.

**Правильный ответ: C**

**Объяснение:**

Инкапсуляция – один из фундаментальных принципов объектно-ориентированного программирования. Он заключается в объединении данных (атрибутов) и методов, работающих с этими данными, внутри класса. Это также подразумевает сокрытие деталей реализации и предоставление доступа к данным только через методы класса, то есть через "публичный интерфейс".

*   **Вариант A** не верен: Наследование — это механизм, позволяющий одному классу наследовать свойства другого.
*  **Вариант B** не верен:  Это определение полиморфизма.
*   **Вариант C** верен: Инкапсуляция — это объединение данных с методами и управление доступом.
*   **Вариант D** не верен:  Это определение статических методов.

**Как работает инкапсуляция:**

1.  Данные и методы, связанные с объектом, объединяются в класс.
2.  Внутренние данные (атрибуты) объявляются "защищенными" или "частными", чтобы ограничить прямой доступ извне класса.
3.  Для доступа к таким данным создаются методы (геттеры и сеттеры), обеспечивающие контролируемый доступ.
4.  Инкапсуляция позволяет скрыть детали реализации и обеспечивает защиту данных.

**Пример:**

```python
class BankAccount:
    def __init__(self, balance: int):
      self._balance: int = balance # protected переменная

    def get_balance(self) -> int:
        """Получить текущий баланс."""
        return self._balance

    def deposit(self, amount: int) -> None:
        """Положить деньги на счет."""
        if amount > 0:
           self._balance += amount
        else:
            print("Сумма должна быть положительной!")

account: BankAccount = BankAccount(1000)
print(f"Баланс: {account.get_balance()}") # Вывод: Баланс: 1000

# Прямой доступ к переменной balance, но не рекомендуется:
# print(account._balance)
```

**В результате:**
*  В примере выше атрибут `_balance` является защищённым, и к нему нет прямого доступа.
* Управление происходит через методы `get_balance`, `deposit` и `withdraw`, что позволяет защитить состояние объекта.

Таким образом, **вариант C** является правильным.
