### `question_192.md`

**Вопрос 192.** Что такое "полиморфизм" в объектно-ориентированном программировании?

A. Возможность создания новых классов на основе существующих.
B. Возможность создания нескольких экземпляров одного класса.
C. Возможность обрабатывать объекты разных классов через общий интерфейс.
D. Возможность сокрытия данных внутри класса.

**Правильный ответ: C**

**Объяснение:**

Полиморфизм (от греческого "многоформенность") в объектно-ориентированном программировании — это возможность использовать объекты разных классов через общий интерфейс. Другими словами, объекты разных классов могут отвечать на один и тот же метод, но по-разному, исходя из своей природы.

*   **Вариант A** не верен: Это определение относится к наследованию, а не полиморфизму.
*  **Вариант B** не верен:  Это описание создания экземпляров, но не полиморфизма.
*   **Вариант C** верен: Полиморфизм заключается в обработке объектов разных классов через общий интерфейс.
*   **Вариант D** не верен:  Это определение инкапсуляции, а не полиморфизма.

**Как работает полиморфизм:**

1.  В разных классах могут быть методы с одинаковыми именами.
2.  Когда вызывается метод с общим именем, конкретное действие определяется типом объекта, через который вызывается метод (так называемый "динамический полиморфизм").

**Пример:**

```python
class Animal:
  def make_sound(self):
      print("Generic sound")

class Dog(Animal):
    def make_sound(self): # переопределяем метод
       print("Woof!")

class Cat(Animal):
    def make_sound(self): # переопределяем метод
        print("Meow!")

def animal_sound(animal: Animal):
    animal.make_sound() # вызов метода у объектов разных классов

animal: Animal = Animal()
dog: Dog = Dog()
cat: Cat = Cat()

animal_sound(animal)  # Вывод: Generic sound
animal_sound(dog) # Вывод: Woof!
animal_sound(cat)  # Вывод: Meow!
```

**В результате:**

*   Функция `animal_sound()` использует полиморфизм для обработки объектов разных классов `Animal`, `Dog`, и `Cat`.
*   У каждого объекта вызывается метод `make_sound()` но вывод этого метода разный, в зависимости от конкретного класса.

Таким образом, **вариант C** является правильным ответом.
