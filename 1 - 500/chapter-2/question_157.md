### `question_157.md`

**Вопрос 57.** Какова основная цель использования декораторов в Python?

A. Для изменения базового функционала функций.
B. Для добавления дополнительной функциональности к функциям без изменения их исходного кода.
C. Для создания копий функций.
D. Для отладки функций.

**Правильный ответ: B**

**Объяснение:**

Декораторы в Python используются для добавления дополнительной функциональности к функциям или методам без изменения их исходного кода. Они предоставляют способ обернуть функцию и добавить к ней действия, которые выполняются до или после вызова оригинальной функции.

*   **Вариант A** не верен: Декораторы не меняют базовый функционал, а расширяют его.
*   **Вариант B** верен: Декораторы позволяют добавлять функциональность, не изменяя исходный код функции.
*   **Вариант C** не верен: Для создания копии функции используют `copy.deepcopy()` или `copy.copy()`.
*   **Вариант D** не верен:  Декораторы могут применяться для отладки, но не являются основными инструментами для этого.

**Как работают декораторы:**

1.  Декоратор — это функция, которая принимает другую функцию в качестве аргумента.
2.  Декоратор возвращает новую функцию, которая обычно обертывает исходную функцию.
3.  Декорированная функция выполняет сначала обертку декоратора, а потом уже сам код функции.

**Пример:**

```python
import time
from typing import Callable

def timer(func: Callable) -> Callable:
    def wrapper(*args, **kwargs):
        start_time: float = time.time()
        result = func(*args, **kwargs)
        end_time: float = time.time()
        execution_time: float = end_time - start_time
        print(f"Время выполнения функции {func.__name__}: {execution_time:.4f} сек")
        return result
    return wrapper


@timer
def my_function(n: int) -> int:
  """Функция, которая замедляет выполнение"""
  time.sleep(n)
  return n*2

result: int = my_function(2) # Вывод: Время выполнения функции my_function: 2.0019 секунд
print(f"Результат: {result}")  # Вывод: Результат: 4
```

**В результате:**

*  Декоратор `@timer` обертывает функцию `my_function`.
*   При вызове `my_function` сначала выполняется код декоратора `timer`, который измеряет время выполнения, а потом вызывается сама функция `my_function`.

Таким образом, **вариант B** является правильным.
