### `question_195.md`

**Вопрос 195.** Каково назначение декоратора `@classmethod` в Python?

A.  Он превращает метод в статический метод.
B.  Он используется для создания экземпляров класса.
C.  Он превращает метод в метод класса, который принимает класс в качестве первого аргумента (`cls`).
D. Он ограничивает доступ к методу только внутри экземпляра класса.

**Правильный ответ: C**

**Объяснение:**

Декоратор `@classmethod` в Python используется для определения методов, которые связаны с самим классом, а не с конкретным экземпляром класса. Такие методы получают класс как свой первый аргумент, который обычно называют `cls`.

*   **Вариант A** не верен: Декоратор `@staticmethod` превращает метод в статический метод.
*   **Вариант B** не верен: Конструктор класса `__init__()` используется для создания экземпляров класса.
*   **Вариант C** верен:  Декоратор `@classmethod` определяет метод класса и передает в него ссылку на класс (`cls`).
*   **Вариант D** не верен: Метод экземпляра используется только в объекте.

**Как работает `@classmethod`:**

1. Декоратор `@classmethod` помещается над методом.
2.  Метод класса автоматически получает ссылку на класс (обычно называемую `cls`) в качестве первого аргумента.
3.  Метод класса может изменять состояние класса (атрибуты класса).
4.  Метод класса может быть вызван как через класс, так и через экземпляр класса.

**Пример:**

```python
class MyClass:
    count: int = 0

    def __init__(self):
        MyClass.count += 1

    @classmethod
    def get_count(cls):
       """Метод класса, который возвращает количество экземпляров"""
       return cls.count


obj1: MyClass = MyClass()
obj2: MyClass = MyClass()

print(MyClass.get_count()) # Вывод: 2
print(obj1.get_count()) # Вывод: 2
```

**В результате:**

* Метод `get_count` помечен `@classmethod` и получает ссылку на класс (`cls`).
*   Метод `get_count` может быть вызван как через класс, так и через его экземпляр.

Таким образом, **вариант C** является правильным.
