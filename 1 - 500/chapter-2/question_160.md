### `question_160.md`

**Вопрос 60.** Какое из следующих утверждений лучше всего описывает понятие "утиная типизация" (duck typing) в Python?

A. Python проверяет тип объекта перед выполнением метода и вызывает ошибку, если тип не соответствует.
B. Python требует, чтобы все объекты, используемые в одном контексте, были одного типа.
C. Python проверяет наличие необходимых методов и атрибутов у объекта, не требуя конкретного типа, и вызывает эти методы или атрибуты, если они существуют.
D. Python проверяет, имеет ли объект общую иерархию классов с ожидаемым типом.

**Правильный ответ: C**

**Объяснение:**

"Утиная типизация" (duck typing) — это концепция в динамически типизированных языках, таких как Python, где тип объекта не важен. Важно, чтобы объект имел необходимые методы и атрибуты, которые используются в коде.

*   **Вариант A** не верен:  При утиной типизации Python не проверяет тип объекта перед вызовом метода.
*   **Вариант B** не верен: Утиная типизация разрешает использовать объекты разных типов в одном контексте.
*   **Вариант C** верен: Утиная типизация проверяет наличие необходимых методов и атрибутов, а не конкретный тип.
*   **Вариант D** не верен: Утиная типизация не зависит от иерархии классов.

**Как работает утиная типизация:**

1.  Python не требует, чтобы объекты явно объявляли свой тип.
2.  Вместо проверки типов Python проверяет, есть ли у объекта необходимые методы или атрибуты для конкретной операции.
3.  Если объект "ведет себя как утка" (имеет необходимые методы и атрибуты), то Python предполагает, что это "утка", и позволяет использовать объект, даже если его тип не определен явно.

**Пример:**

```python
class Duck:
    def quack(self):
        print("Quack!")

class Cat:
    def quack(self):
        print("Meow!")

def make_quack(animal):
    animal.quack()  # Проверяется только наличие метода quack, тип объекта не важен

duck: Duck = Duck()
cat: Cat = Cat()

make_quack(duck) # Вывод: Quack!
make_quack(cat) # Вывод: Meow!
```

**В результате:**

*   Функция `make_quack()` не проверяет, является ли аргумент экземпляром класса `Duck` или нет.
*   Она просто вызывает метод `quack()`. Поскольку и у объекта `duck` и у объекта `cat` есть метод `quack()`,  оба вызова работают без ошибок.

Таким образом, **вариант C** является правильным ответом.
