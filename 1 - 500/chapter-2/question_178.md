### `question_178.md`

**Вопрос 178.** Каково назначение метода `get()` применительно к словарям в Python?

A.  Он добавляет новую пару ключ-значение в словарь.
B.  Он удаляет пару ключ-значение из словаря по указанному ключу.
C.  Он возвращает значение по указанному ключу и возвращает `None` (или значение по умолчанию), если ключ не найден.
D.  Он возвращает список всех ключей словаря.

**Правильный ответ: C**

**Объяснение:**

Метод `get()` словаря в Python предназначен для получения значения по ключу, но он также позволяет установить значение по умолчанию, которое будет возвращено, если ключ отсутствует в словаре. Это позволяет избежать ошибок `KeyError`.

*   **Вариант A** не верен: Для добавления элемента используют `dictionary[key] = value` или `dictionary.update()`.
*   **Вариант B** не верен: Для удаления используют метод `pop()` или `del`.
*   **Вариант C** верен: `get()` возвращает значение по ключу или значение по умолчанию если ключа нет.
*   **Вариант D** не верен: `keys()` возвращает список всех ключей.

**Как работает `get()`:**

1.  `get(key)`: Возвращает значение, связанное с ключом `key`. Если ключ не найден, возвращает `None`.
2.  `get(key, default)`: Возвращает значение, связанное с ключом `key`. Если ключ не найден, возвращает значение `default`.

**Пример:**

```python
my_dict: dict[str, int] = {"a": 1, "b": 2}

value1: int | None = my_dict.get("a")
print(f"Значение для 'a': {value1}")  # Вывод: Значение для 'a': 1

value2: int | None = my_dict.get("c")
print(f"Значение для 'c' (не найдено): {value2}")  # Вывод: Значение для 'c' (не найдено): None

value3: int = my_dict.get("c", 0)
print(f"Значение для 'c' (не найдено, default 0): {value3}")  # Вывод: Значение для 'c' (не найдено, default 0): 0
```

**В результате:**

*   Метод `get("a")` возвращает значение по существующему ключу `"a"`.
*   Метод `get("c")` возвращает `None`, так как ключа `"c"` нет в словаре.
*  Метод `get("c", 0)` возвращает значение 0, как значение по умолчанию.
*   При прямом обращении к словарю по несуществующему ключу возникло бы исключение `KeyError`.

Таким образом, **вариант C** является правильным.
