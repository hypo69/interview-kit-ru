### `question_003.md`

**Вопрос 3.** В Python области видимости переменных играют важную роль в понимании того, как переменные доступны или изменяются внутри вложенных блоков кода. Если переменная с одним и тем же именем определена как внутри функции, так и вне ее, что произойдет, когда функция попытается изменить эту переменную без какого-либо дополнительного ключевого слова?

A.  Функция напрямую изменит глобальную переменную без какой-либо ошибки.

B.  Python вызовет ошибку `SyntaxError` из-за конфликтующих областей видимости переменных.

C.  Функция создаст новую локальную переменную с тем же именем, что и глобальная переменная, оставив глобальную переменную без изменений.

D.  Глобальная переменная будет перекрыта, и ее значение изменится только тогда, когда функция завершит свою работу.

**Правильный ответ: C**

**Объяснение:**

*   **Локальные переменные:** В Python переменные, объявленные внутри функции, по умолчанию считаются локальными для этой функции. Это означает, что они существуют и доступны только внутри этой функции.

*   **Глобальные переменные:** Глобальные переменные - это переменные, объявленные вне функций (на уровне модуля), и они доступны во всем коде модуля.

*   **Изменение глобальных переменных:** Если внутри функции используется имя переменной, которое также существует в глобальной области видимости, и при этом не используется ключевое слово `global`, то Python автоматически создаст локальную переменную с тем же именем внутри этой функции. Это означает, что изменения, произведенные с этой переменной внутри функции, не повлияют на глобальную переменную.

**Пример:**

```python
global_variable: int = 10  # Глобальная переменная

def modify_variable() -> None:
    global_variable: int = 5 # Создается локальная переменная с тем же именем
    print(f"Значение переменной внутри функции: {global_variable}")  # Вывод: Значение переменной внутри функции: 5

modify_variable()
print(f"Значение глобальной переменной после вызова функции: {global_variable}") # Вывод: Значение глобальной переменной после вызова функции: 10
```

**В результате:**

*   Внутри функции `modify_variable` создается локальная переменная `global_variable` со значением `5`. Она *перекрывает* глобальную переменную с тем же именем, но *не изменяет* её.
*   Когда функция завершает свою работу, локальная переменная перестает существовать.
*   После вызова функции, глобальная переменная `global_variable` сохраняет свое первоначальное значение `10`.

Таким образом, ответ **C** является правильным, так как он точно описывает механизм создания локальной переменной внутри функции при наличии глобальной переменной с тем же именем.
