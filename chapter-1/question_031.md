### `question_031.md`

**Вопрос 31.** Какое из следующих утверждений точно описывает роль и применение декораторов Python в усилении или изменении поведения функций или методов в программе?

A.  Декораторы позволяют изменять вывод функций без непосредственного изменения кода функции, действуя как обертка, которая предоставляет дополнительную функциональность до или после вызова исходной функции.
B.  Они в первую очередь служат для уменьшения скорости выполнения функций за счет добавления дополнительных слоев логики, которые необходимо обработать.
C.  Декораторы Python служат для увеличения использования памяти функциями, поскольку они вводят новые слои и структуры, тем самым замедляя общий процесс выполнения.
D.  Декораторы в Python могут применяться только к методам объектно-ориентированного программирования, в частности к взаимодействиям методов класса, а не к автономным функциям.

**Правильный ответ: A**

**Объяснение:**

Декораторы в Python — это мощный инструмент, который позволяет модифицировать поведение функций или методов без прямого изменения их кода. Они работают как обертки, которые добавляют дополнительную функциональность до или после вызова исходной функции.

*   **Вариант A** верен: Декораторы позволяют обернуть функцию и добавить к ней дополнительный функционал, не изменяя саму функцию.
*   **Вариант B** не верен: Декораторы не предназначены для уменьшения скорости выполнения функций. Наоборот, они могут использоваться для оптимизации, например, с помощью мемоизации.
*   **Вариант C** не верен: Декораторы не обязательно увеличивают использование памяти и могут улучшить производительность.
*   **Вариант D** не верен: Декораторы могут применяться как к методам класса, так и к обычным функциям.

**Пример:**

```python
import time
from typing import Callable

# Декоратор, измеряющий время выполнения функции
def timer(func: Callable) -> Callable:
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения функции {func.__name__}: {execution_time:.4f} секунд")
        return result
    return wrapper

# Функция для тестирования
@timer # Применение декоратора
def my_function(n: int) -> int:
    """Функция, которая замедляет выполнение искусственно."""
    time.sleep(n)
    return n * 2

# Вызов функции
result: int = my_function(2)
print(f"Результат функции: {result}")

# Пример использования декоратора без @
def test_function(x: int) -> int:
   return x * 3

wrapped_func = timer(test_function)
res: int = wrapped_func(4)
print(f"Результат test_function: {res}")
```

**В результате:**

*   Декоратор `timer` обертывает функцию `my_function` и измеряет время ее выполнения.
*   При вызове `my_function`, декоратор добавляет функциональность измерения времени, а затем выводит результат.
*  При использовании обертки без `@`, функция `test_function` будет обернута в декоратор, но это не изменит само определение функции.

Таким образом, **вариант A** является верным, так как он точно описывает назначение и применение декораторов в Python.
