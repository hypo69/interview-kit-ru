### `question_013.md`

**Вопрос 13.** Учитывая динамическую систему типизации Python, какой из следующих фрагментов кода демонстрирует гибкость присваивания типов в Python, позволяя переназначать переменные на различные типы данных в пределах одного и того же сценария?

```python
A. x = 10; x = "ten"; print(x)
B. x = 10; x = x + "10"; print(x)
C. x = "10"; x = int(x); x = x + 10; print(x)
D. x = "10"; x = int(x); x = x + "10"; print(x)
```

**Правильный ответ: A**

**Объяснение:**

Динамическая типизация в Python означает, что тип переменной не нужно объявлять явно, и он может изменяться в процессе выполнения программы. Это позволяет переменной сначала хранить значение одного типа (например, целое число), а затем значение другого типа (например, строку) без ошибок.

*   **Вариант A**: `x = 10; x = "ten"; print(x)` - Это правильный вариант. Сначала переменной `x` присваивается целое число `10`, а затем ей же присваивается строка `"ten"`. Python позволяет это, демонстрируя гибкость динамической типизации.

*   **Вариант B**: `x = 10; x = x + "10"; print(x)` - Этот вариант приведет к ошибке, потому что вы пытаетесь сложить целое число со строкой. Python не выполняет неявное преобразование типов, поэтому возникнет ошибка `TypeError`.
    
*   **Вариант C**: `x = "10"; x = int(x); x = x + 10; print(x)` - Этот вариант сначала присваивает строковое значение `"10"` переменной `x`, затем преобразует его в целое число и присваивает переменной `x` новое значение, а затем складывает с целым числом `10`. Это не демонстрирует изменение типа в течение времени, так как `x` будет `int` на протяжении 2х последних операций.

*   **Вариант D**: `x = "10"; x = int(x); x = x + "10"; print(x)` - Этот вариант похож на вариант C, но последняя операция  снова использует  строку, что приведет к ошибке `TypeError`, поскольку вы пытаетесь сложить целое число со строкой.
    
**Пример:**

```python
# Пример с правильным вариантом (A)
x: int | str = 10
print(f"Тип x до изменения: {type(x)}, Значение x: {x}")  # Вывод: Тип x до изменения: <class 'int'>, Значение x: 10

x: str = "ten"
print(f"Тип x после изменения: {type(x)}, Значение x: {x}") # Вывод: Тип x после изменения: <class 'str'>, Значение x: ten

# Пример с неверным вариантом (B) - вызовет ошибку
try:
    x: int | str = 10
    x: str = x + "10"
    print(x)
except TypeError as e:
    print(e) # Вывод: unsupported operand type(s) for +: 'int' and 'str'
```

**В результате:**

*   **Вариант A** успешно демонстрирует, как переменная `x` меняет тип с `int` на `str` в процессе выполнения программы.
*   **Вариант B** вызывает `TypeError`, так как Python не может автоматически сложить целое число со строкой.

Таким образом, только **вариант A** корректно демонстрирует гибкость динамической типизации в Python.
