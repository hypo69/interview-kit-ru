Отлично, это очень хороший и конкретный вопрос, касающийся различий между итераторами и генераторами. Давайте разберем это в формате вопроса для собеседования.

### `question_267_interview.md`

**Вопрос 267.** Какие из перечисленных методов являются специфическими для генераторов в Python и не доступны для обычных итераторов?

1.  `send(value)`
2.  `throw(type, value=None, traceback=None)`
3.  `close()`

A.  Только 1
B.  Только 1 и 2
C.  Только 1 и 3
D.  1, 2 и 3

**Правильный ответ: D**

**Объяснение:**

В Python, генераторы и итераторы являются механизмами для последовательного доступа к элементам, но у генераторов есть некоторые специфические методы, которые делают их более гибкими.

*   **Итераторы:**
    *   Представляют собой объекты, реализующие протокол итератора, который требует наличия методов `__iter__()` (возвращает сам итератор) и `__next__()` (возвращает следующий элемент или поднимает `StopIteration`).
    *   Используются для последовательного обхода элементов, но они не имеют возможности «внешнего» управления своим поведением.

*   **Генераторы:**
    *   Являются специальным видом итераторов. Они создаются с использованием функций, содержащих ключевое слово `yield`.
    *   Автоматически реализуют протокол итератора.
    *   Имеют дополнительные методы, которые позволяют взаимодействовать с их выполнением, чего нет у обычных итераторов.

**Специфические методы генераторов:**

1.  **`send(value)`**:
    *   Позволяет передать значение *внутрь генератора* в точке его приостановки (где был выполнен `yield`).
    *   Это значение становится результатом выражения `yield`, позволяя генератору изменять свое поведение на основе внешних данных.
    *   Обычные итераторы не имеют такого метода.

2.  **`throw(type, value=None, traceback=None)`**:
    *   Используется для *выбрасывания исключения* внутри генератора в точке, где он был приостановлен (после последнего `yield`).
    *   Позволяет обрабатывать ошибки и особые ситуации извне генератора.
    *   Обычные итераторы не имеют такого метода.

3.  **`close()`**:
    *   *Завершает* выполнение генератора, вызывая исключение `GeneratorExit`.
    *   Обычно используется для освобождения ресурсов, связанных с генератором.
    *   Обычные итераторы не имеют такого метода.

*   **Вариант A не верен:** Метод `send()` есть только у генератора, но `throw()` и `close()` так же являются специфическими методами.
*   **Вариант B не верен:**  `close()` так же является специфичным методом.
*  **Вариант C не верен:** `throw()` так же является специфичным методом.
*   **Вариант D верен:** Все перечисленные методы доступны для генераторов, но не для обычных итераторов.

**Пример:**

```python
def my_generator():
    value = yield 1
    print(f"Received: {value}")
    yield 2
    yield 3

gen = my_generator()
print(next(gen))     # Output: 1
print(gen.send("hello")) # Output: Received: hello, then 2
print(gen.throw(ValueError, "an error")) # Output ValueError: an error
try:
  next(gen)
except StopIteration:
  print("Done")
gen.close()
```

**В результате:**

`send()`, `throw()`, и `close()` являются специфическими методами генераторов, предоставляя им дополнительную гибкость и функциональность, которой нет у обычных итераторов.

Таким образом, вариант D является правильным.
