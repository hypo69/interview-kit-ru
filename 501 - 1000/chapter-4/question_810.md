
### `question_810_interview.md`

**Вопрос 810.** Что будет выведено на экран в результате выполнения следующего Python-кода?

```python
a = {1: "A", 2: "B", 3: "C"}
b = a.copy()
b[2] = "D"
print(a)
```

A.  `{1: 'A', 2: 'B', 3: 'C'}`
B.  `{1: 'A', 2: 'D', 3: 'C'}`
C.  `{1: 'A', 2: 'B', 3: 'C'}`  (Ошибка: для словарей нет метода copy())
D. `None`

**Правильный ответ: A**

**Объяснение:**

В Python словари являются изменяемыми (mutable) объектами, поэтому при присваивании словаря другой переменной, создается лишь *ссылка* на тот же словарь, а не его копия. Однако метод `.copy()` создает *поверхностную (shallow) копию* словаря. Это означает, что если значениями в словаре являются неизменяемые типы (например, строки, числа), то изменения в копии *не* повлияют на оригинал. В данном примере, метод `copy()` создаст новый словарь, а не новую ссылку.

1.  **Создание словаря `a`:**
   ```python
   a = {1: "A", 2: "B", 3: "C"}
   ```
   Словарь `a` содержит пары ключ-значение.
2.  **Создание поверхностной копии `b`:**
   ```python
   b = a.copy()
   ```
   `b` становится поверхностной копией словаря `a`. Теперь `b` и `a` - это разные объекты в памяти.
3. **Изменение `b`:**
   ```python
    b[2] = "D"
   ```
   Меняется значение ключа `2` в словаре `b`. Так как создана *поверхностная* копия `b` и значения словаря - неизменяемые строки, то эти изменения *не* влияют на словарь `a`.
4.  **Вывод словаря `a`:**
    ```python
    print(a)
    ```
    Выводится оригинальный словарь `a`, который остался неизменным.

*   **Вариант A верен:**  Метод `copy()` создает *поверхностную копию* словаря. Так как значения в словаре - неизменяемые строки, то изменения `b` не затрагивают `a`.
*   **Вариант B не верен:**  Изменения в копии `b` не влияют на оригинал `a` из-за использования  `copy()`.
*   **Вариант C не верен:** Метод copy для словарей *существует*.
*   **Вариант D не верен:** Функция print выведет словарь, а не `None`.

**Ключевой момент:**

Важно помнить, что метод `.copy()` создает *поверхностную* копию. Если бы значениями в словаре были *изменяемые* объекты (например, списки или другие словари), то изменения в этих объектах в копии повлияли бы и на оригинальный словарь. В таком случае, для создания полностью независимой копии потребовалось бы использовать глубокое копирование (`copy.deepcopy()`).

**В результате:**

В результате выполнения кода, на экран будет выведен словарь `{1: 'A', 2: 'B', 3: 'C'}`, так как `b = a.copy()` создает поверхностную копию, изменения в которой не повлияли на оригинал `a`.

Таким образом, вариант A является правильным.
