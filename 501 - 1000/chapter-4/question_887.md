### `question_887.md`

**Вопрос 887.** Как работает автоматическое управление памятью (garbage collection) в Python?

A. В Python управление памятью осуществляется исключительно подсчетом ссылок, при котором память освобождается немедленно, когда количество ссылок на объект становится равным нулю, без учета возможных циклических зависимостей.

B. В Python используется комбинация механизма подсчета ссылок, который освобождает память при обнулении счетчика ссылок, и циклического сборщика мусора, который периодически сканирует объекты в памяти для обнаружения и удаления циклических зависимостей, которые не позволяют автоматически освободить память.

C. В Python автоматическое управление памятью основано на анализе достижимости объектов, начиная с корневых объектов, и все недостижимые объекты удаляются сборщиком мусора, без использования подсчета ссылок.

D. Python предоставляет ручное управление памятью с помощью функций `malloc` и `free`, как в языке C, а автоматическая сборка мусора используется только для отладки.

**Правильный ответ: B**

**Объяснение:**

Python использует автоматическое управление памятью, что значительно упрощает разработку приложений. Этот процесс включает в себя два основных механизма:

1.  **Подсчет ссылок (Reference Counting):**
    *   Каждый объект в Python имеет счетчик ссылок, который увеличивается при создании новой ссылки на объект и уменьшается при удалении ссылки.
    *   Когда счетчик ссылок объекта достигает нуля, это означает, что на объект больше никто не ссылается, и Python немедленно освобождает память, занимаемую этим объектом.

2.  **Циклический сборщик мусора (Cyclic Garbage Collector):**
    *   Подсчет ссылок не может обработать случаи, когда объекты ссылаются друг на друга, образуя *циклические зависимости*. В этом случае счетчики ссылок объектов никогда не станут равными нулю, даже если объекты больше не используются.
    *   Циклический сборщик мусора периодически сканирует объекты в памяти в поисках таких циклических зависимостей.
    *   Если он обнаруживает циклы, состоящие из объектов, которые больше не достижимы из основной программы (то есть, не используются), то он удаляет эти объекты и освобождает занимаемую ими память.

*   **Вариант A не верен:** Циклические зависимости игнорируются, что приведет к утечке памяти.
*   **Вариант B верен:** Это полное и точное описание.
*   **Вариант C не верен:** Алгоритм достижимости используется, как вспомогательный, но основным является подсчёт ссылок.
*   **Вариант D не верен:** В python нет ручного управления памятью.

**Пример:**

```python
import gc

class MyObject:
    pass

obj1 = MyObject()
obj2 = MyObject()

obj1.reference = obj2
obj2.reference = obj1  # Cyclic reference created!

del obj1
del obj2 # The objects are still in memory because of the cyclic reference

print(gc.collect()) # Циклический сборщик мусора удалит эти объекты
```
**В результате:**

В Python используется автоматическое управление памятью с помощью комбинации подсчета ссылок и циклического сборщика мусора. Подсчет ссылок освобождает память, когда на объект больше нет ссылок, а циклический сборщик мусора обнаруживает и удаляет циклические зависимости, предотвращая утечки памяти.

Таким образом, вариант B является правильным.
