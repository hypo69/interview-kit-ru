### `question_536.md`

**Вопрос 536.** Какой результат будет получен при выполнении следующего кода Python, 
реализующего алгоритм быстрой сортировки?

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)


# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
print("Original array:", arr)
sorted_arr = quick_sort(arr)
print("Sorted array:", sorted_arr)
```

-   A. `Original array: [64, 34, 25, 12, 22, 11, 90] Sorted array: [90, 64, 34, 25, 22, 12, 11]`
-   B. `Original array: [64, 34, 25, 12, 22, 11, 90] Sorted array: [11, 12, 22, 25, 34, 64, 90]`
-   C. `Original array: [64, 34, 25, 12, 22, 11, 90] Sorted array: [11, 90, 12, 64, 22, 34, 25]`
-   D. `Original array: [64, 34, 25, 12, 22, 11, 90] Sorted array: [64, 34, 25, 22, 12, 11, 90]`

**Правильный ответ: B**

**Объяснение:**

Предоставленный код реализует алгоритм быстрой сортировки (quick sort), который использует принцип "разделяй и властвуй".

*   **Алгоритм быстрой сортировки:**
    *   Выбирает опорный элемент (pivot) из массива.
    *   Разделяет массив на три части: элементы меньше опорного, элементы равные опорному и элементы больше опорного.
    *   Рекурсивно сортирует подмассивы слева и справа от опорного элемента.
    *   Объединяет отсортированные подмассивы и опорный элемент.
*   **Описание кода:**
    *   `quick_sort(arr)`: Функция, которая принимает массив `arr` в качестве аргумента.
        *   `if len(arr) <= 1`: Базовый случай рекурсии: если длина массива меньше или равна 1, то он возвращается.
        *   `pivot = arr[len(arr) // 2]`: Выбирает опорный элемент из середины массива.
        *   `left = [x for x in arr if x < pivot]`: Создает список элементов меньше опорного.
        *   `middle = [x for x in arr if x == pivot]`: Создает список элементов равных опорному.
        *  `right = [x for x in arr if x > pivot]`: Создает список элементов больше опорного.
        * `return quick_sort(left) + middle + quick_sort(right)`: Рекурсивно вызывает `quick_sort` для `left`, и `right` и возвращает объединенный отсортированный массив.

**Разбор вариантов:**
*   **A. `Original array: [64, 34, 25, 12, 22, 11, 90] Sorted array: [90, 64, 34, 25, 22, 12, 11]`:** Неправильно. Это сортировка в порядке убывания.
*   **B. `Original array: [64, 34, 25, 12, 22, 11, 90] Sorted array: [11, 12, 22, 25, 34, 64, 90]`:** Правильно. Результат сортировки в порядке возрастания.
*   **C. `Original array: [64, 34, 25, 12, 22, 11, 90] Sorted array: [11, 90, 12, 64, 22, 34, 25]`:** Неправильно.
*   **D. `Original array: [64, 34, 25, 12, 22, 11, 90] Sorted array: [64, 34, 25, 22, 12, 11, 90]`:** Неправильно.

**В результате:**
*   Код правильно реализует алгоритм быстрой сортировки для сортировки массива в порядке возрастания.
*   Быстрая сортировка является одним из наиболее эффективных алгоритмов сортировки.
*   Выбор опорного элемента может влиять на производительность алгоритма, но в данном примере это упрощенная версия.

Таким образом, правильным ответом является **B. `Original array: [64, 34, 25, 12, 22, 11, 90] Sorted array: [11, 12, 22, 25, 34, 64, 90]`**.
