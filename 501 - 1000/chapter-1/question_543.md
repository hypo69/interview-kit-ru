### `question_543.md`

**Вопрос 543.** Что такое декораторы в Python и для чего они используются? Приведите пример кода, демонстрирующий их применение.

-   A. Декораторы - это специальные переменные, которые используются для хранения дополнительных данных о функциях, не изменяя их поведение.
-   B. Декораторы - это функции, которые изменяют имена других функций и делают их вызовы более короткими.
-   C. Декораторы - это функции, которые принимают другую функцию в качестве аргумента, расширяют ее функциональность и возвращают новую функцию. Они позволяют добавлять поведение к функциям без изменения их исходного кода.
-   D. Декораторы - это способы скрытия кода, чтобы предотвратить его чтение и изменение.

**Правильный ответ: C**

**Объяснение:**

Декораторы в Python — это мощный и элегантный инструмент, позволяющий изменять поведение функций или методов без изменения их исходного кода. Они используют концепцию функций высшего порядка, то есть функций, которые могут принимать другие функции в качестве аргументов и возвращать их.

*   **Основные идеи декораторов:**
    *   Декоратор — это функция, которая принимает другую функцию в качестве аргумента.
    *   Декоратор добавляет новую функциональность к принимаемой функции.
    *   Декоратор возвращает новую функцию (обычно "обертку"), которая включает в себя расширенную функциональность.
    *   Декораторы используют синтаксис `@decorator_name` для применения декоратора к функции.

*   **Преимущества декораторов:**
    *   **Повторное использование кода:** Позволяют повторно использовать логику (например, логирование, проверка прав) для различных функций.
    *   **Модификация поведения:** Расширяют функциональность функций, не меняя их исходный код (принцип открытости/закрытости).
    *   **Упрощение кода:** Помогают сделать код более читаемым и организованным за счет разделения ответственности.

**Пример кода:**

```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f'Функция {func.__name__} вызвана')
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    return a + b

@logger
def multiply(a,b):
  return a * b

add(2, 3) # Выведет 'Функция add вызвана'
multiply(4,5) # Выведет 'Функция multiply вызвана'
```
**Описание примера:**

*   **`logger(func)`:** Декоратор, который принимает функцию `func`.
    *   `wrapper(*args, **kwargs)`: Вложенная функция, которая будет "оберткой" для оригинальной функции.
    *   `print(f'Функция {func.__name__} вызвана')`: Логирует вызов функции.
    *   `return func(*args, **kwargs)`: Вызывает оригинальную функцию и возвращает ее результат.

*   **`@logger`:** Применяет декоратор `logger` к функциям `add` и `multiply`.
*   Теперь при вызове `add(2, 3)` или `multiply(4,5)` сначала будет вызван декоратор `logger`, который выведет сообщение в консоль о том, какая функция была вызвана, а затем будет вызвана сама функция, переданная в декоратор.

**Разбор вариантов:**
*  **A. Декораторы - это специальные переменные, которые используются для хранения дополнительных данных о функциях, не изменяя их поведение:** Неправильно. Декораторы — это функции, а не переменные.
*   **B. Декораторы - это функции, которые изменяют имена других функций и делают их вызовы более короткими:** Неправильно. Декораторы не меняют имена функций.
*   **C. Декораторы - это функции, которые принимают другую функцию в качестве аргумента, расширяют ее функциональность и возвращают новую функцию. Они позволяют добавлять поведение к функциям без изменения их исходного кода:** Правильно.
*   **D. Декораторы - это способы скрытия кода, чтобы предотвратить его чтение и изменение:** Неправильно. Декораторы не скрывают код, а, наоборот, делают его более организованным.

**В результате:**
*   Декораторы позволяют добавлять новую функциональность к функциям "на лету", не изменяя их код напрямую.
*   Они являются важным инструментом для написания более чистого, модульного и повторно используемого кода в Python.

Таким образом, правильным ответом является **C. Декораторы - это функции, которые принимают другую функцию в качестве аргумента, расширяют ее функциональность и возвращают новую функцию. Они позволяют добавлять поведение к функциям без изменения их исходного кода.**
