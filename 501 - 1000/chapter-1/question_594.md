### `question_594.md`

**Вопрос 594.** В чем заключаются основные различия между методами экземпляра, методами класса и статическими методами в Python, и как они используются в контексте классов?

-   A.  Методы экземпляра, класса и статические методы являются полностью эквивалентными и могут взаимозаменяться в любом контексте.
-   B.  Методы экземпляра относятся к конкретному экземпляру класса и принимают `self` в качестве первого параметра. Статические методы не принимают `self` и не связаны с каким-либо экземпляром класса. Методы класса принимают параметр `cls` и могут изменять состояние класса.
-   C.  Методы экземпляра, класса и статические методы являются просто разными способами записи одного и того же, и компилятор Python обрабатывает их одинаково.
-   D.  Методы класса могут быть вызваны через экземпляр класса, статические - только через класс, а методы экземпляра - напрямую через функцию, без создания экземпляра.

**Правильный ответ: B**

**Объяснение:**

В Python методы класса представляют разные способы работы с классами и объектами, и каждый тип имеет свое предназначение и особенности.

*  **Методы экземпляра (Instance methods):**
    *   **Первый параметр `self`:** Принимают обязательный первый параметр `self`, который является ссылкой на экземпляр класса.
    *  **Доступ к состоянию экземпляра:** Имеют доступ к атрибутам и другим методам конкретного экземпляра класса.
    *   **Зависят от экземпляра:**  Работают с состоянием конкретного экземпляра класса.
     *  Вызываются через экземпляр: `instance.method()`.

* **Статические методы (Static methods):**
   *    **Декоратор `@staticmethod`:**  Помечаются декоратором `@staticmethod`.
   * **Нет обязательного параметра `self`:** Не принимают обязательный параметр `self` (не имеют доступа к атрибутам экземпляра).
   *  **Не зависят от экземпляра:** Не могут изменять состояние экземпляра или класса.
   *  **Автономные методы:** Выступают как обычные функции, которые связаны с классом (но не с его экземплярами).
    *    **Вызываются через класс:**  `Class.method()` или `instance.method()`.

*  **Методы класса (Class methods):**
     *   **Декоратор `@classmethod`:** Помечаются декоратором `@classmethod`.
    *   **Первый параметр `cls`:** Принимают обязательный первый параметр `cls`, который является ссылкой на класс.
    *   **Доступ к состоянию класса:** Могут обращаться и изменять состояние класса.
   *  **Зависят от класса:** Могут работать со свойствами класса.
   *  **Вызываются через класс:**  `Class.method()` или `instance.method()`.

**Примеры:**

```python
class CoffeeShop:
    specialty = 'espresso'

    def __init__(self, coffee_price):
        self.coffee_price = coffee_price
  
    # instance method
    def make_coffee(self):
        print(f'Making {self.specialty} for ${self.coffee_price}')
 
    # static method    
    @staticmethod
    def check_weather():
        print('Its sunny')

    # class method
    @classmethod
    def change_specialty(cls, specialty):
        cls.specialty = specialty
        print(f'Specialty changed to {specialty}')

# Создаем экземпляр
coffee_shop = CoffeeShop('5')

# Вызов метода экземпляра (с помощью экземпляра)
coffee_shop.make_coffee()
# Вывод: Making espresso for $5

# Вызов статического метода (с помощью экземпляра)
coffee_shop.check_weather()
# Вывод: Its sunny

# Вызов метода класса (с помощью экземпляра)
coffee_shop.change_specialty('drip coffee')
# Вывод: Specialty changed to drip coffee

# Вызов метода экземпляра после вызова метода класса
coffee_shop.make_coffee()
# Вывод: Making drip coffee for $5
# Вызов статического метода (с помощью класса)
CoffeeShop.check_weather()
# Вывод: Its sunny
# Вызов метода класса (с помощью класса)
CoffeeShop.change_specialty('latte')
# Вывод: Specialty changed to latte
print(coffee_shop.specialty) # Выведет latte
```
**Разбор примеров:**
1. **`CoffeeShop`:** класс с атрибутом `specialty`, установленным по умолчанию в `espresso`.
2.  **`make_coffee(self)`:** метод экземпляра. Обращается к атрибутам  `specialty` и `coffee_price` экземпляра через `self`.
3.  **`check_weather()`:** Статический метод с декоратором `@staticmethod`. Он не имеет доступа к  экземпляру или к атрибутам класса.
4.  **`change_specialty(cls, specialty)`:**  Метод класса с декоратором `@classmethod`. Он изменяет атрибут класса `specialty` с помощью параметра `cls`.
5. Далее в примере показывается как вызывать эти методы с помощью экземпляра и класса.

**Разбор вариантов:**
*  **A. Методы экземпляра, класса и статические методы являются полностью эквивалентными и могут взаимозаменяться в любом контексте.:** Неправильно.
*   **B. Методы экземпляра относятся к конкретному экземпляру класса и принимают `self` в качестве первого параметра. Статические методы не принимают `self` и не связаны с каким-либо экземпляром класса. Методы класса принимают параметр `cls` и могут изменять состояние класса.:** Правильно.
*   **C. Методы экземпляра, класса и статические методы являются просто разными способами записи одного и того же, и компилятор Python обрабатывает их одинаково.:** Неправильно.
*   **D. Методы класса могут быть вызваны через экземпляр класса, статические - только через класс, а методы экземпляра - напрямую через функцию, без создания экземпляра.:** Неправильно.

**В результате:**
*  Методы экземпляра работают с конкретным экземпляром, методы класса с классом, а статические методы не зависят ни от экземпляра ни от класса.
*  Выбор типа метода зависит от того, требуется ли ему доступ к объекту, классу, или методу можно быть независимым от них.

Таким образом, правильным ответом является **B. Методы экземпляра относятся к конкретному экземпляру класса и принимают `self` в качестве первого параметра. Статические методы не принимают `self` и не связаны с каким-либо экземпляром класса. Методы класса принимают параметр `cls` и могут изменять состояние класса.**
