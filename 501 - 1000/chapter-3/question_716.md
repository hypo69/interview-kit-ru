### `question_716.md`

**Вопрос 716.** Разработайте алгоритм для поиска наибольшей длины подстроки, состоящей только из неповторяющихся символов в заданной строке.

**Пример:**

```
Ввод: s = "abcabcbb"
Вывод: 3
Объяснение: "abc" является самым длинным палиндромом.

Ввод: s = "bbbbb"
Вывод: 1
Объяснение: "b" является самым длинным палиндромом.
```

-   A. Для решения задачи можно использовать алгоритм с полным перебором всех подстрок и проверять их на уникальность.
-   B. Для решения задачи необходимо использовать  рекурсивный алгоритм, и возвращать максимальную длину при возвращении из рекурсии.
-   C. Для решения задачи необходимо использовать алгоритм динамического программирования.
-  D.  Для решения задачи можно использовать подход скользящего окна и  хеш таблицу для отслеживания встречающихся элементов, что позволяет достичь  линейной временной сложности.

**Правильный ответ: D**

**Объяснение:**

Для решения задачи поиска наибольшей длины подстроки с неповторяющимися символами, оптимальным является метод "скользящего окна" и использования хеш-таблицы (словаря) для отслеживания встречающихся символов. Этот подход позволяет достичь линейной временной сложности `O(n)`.

*   **Алгоритм (скользящее окно с хеш-таблицей):**
    1.  **Инициализация:**
          *  Создается пустой словарь `seen`, для отслеживания индекса, где символ уже встречался.
         * `max_length`  устанавливается на 0.
          *  Устанавливается  `start` на 0 - индекс  начала текущего подмассива.
    2. **Перебор:** Перебираем  все символы в строке:
         *   **Проверка на наличие символа в словаре:**  Если текущий символ `el` уже присутствует в словаре `seen`, то необходимо сравнить  `start` и  `seen[el]+1`, что позволит получить правильное значение старта для текущей строки.
          *  **Обновление индекса:** Сохраняем индекс  `n` (текущего символа)  в словарь.
          *   **Вычисление максимальной длины:** Вычисляем длину текущей подстроки,  и сравниваем ее с  максимальной длиной, и сохраняем максимальное значение.
    3.  **Результат:** После обхода всей строки возвращается максимальная длина.

*   **Преимущества алгоритма:**
    *   **Линейная сложность:** Временная сложность равна O(n), где n - длина строки.
    *   **Постоянная память:** Использует постоянное количество дополнительной памяти.
    *  **Эффективность:** Обеспечивает быстрое нахождение решения.

**Примеры (псевдокод):**

```
function max_subs_len(s):
    seen = create empty dict
    max_length = 0
    start = 0
    for n and el in s :
       if el in seen:
            start = max(start, seen[el] + 1)
        seen[el] = n
        max_length = max(max_length, n - start + 1)
    return max_length
```

**Примеры реализации в Python:**
```python
def max_subs_len(s):
    seen = {}
    max_length = 0
    start = 0

    for n, el in enumerate(s):
        if el in seen:
            start = max(start, seen[el] + 1)
        seen[el] = n
        max_length = max(max_length, n - start + 1)

    return max_length
s1 = "abcabcbb"
print(f"Ввод: s = '{s1}'")
print(f"Вывод: {max_subs_len(s1)}")  # Выведет: Вывод: 3

s2 = "bbbbb"
print(f"Ввод: s = '{s2}'")
print(f"Вывод: {max_subs_len(s2)}")   # Выведет: Вывод: 1
s3 = "pwwkew"
print(f"Ввод: s = '{s3}'")
print(f"Вывод: {max_subs_len(s3)}")   # Выведет: Вывод: 3

```

**Разбор вариантов:**
*   **A. Для решения задачи нужно перебрать все возможные подстроки, и при этом проверить их на уникальность.:** Неправильно.  Это  требует сложности O(n^3).
*  **B. Для решения задачи необходимо использовать  рекурсивный алгоритм, и возвращать максимальную длину при возвращении из рекурсии.:** Неправильно. Рекурсия является не оптимальной.
*   **C. Для решения задачи необходимо использовать алгоритм динамического программирования.:** Неправильно.  Динамическое программирование не является оптимальным подходом.
*   **D.  Для решения задачи можно использовать подход скользящего окна и  хеш таблицу для отслеживания встречающихся элементов, что позволяет достичь  линейной временной сложности.:** Правильно.

**В результате:**
*  Алгоритм  использует  скользящее окно и хеш-таблицу для отслеживания элементов.
*   Позволяет найти самую длинную подстроку с  неповторяющимися  символами за линейное время `O(n)`.
*   Алгоритм является простым и эффективным решением.

Таким образом, правильным ответом является **D. Для решения задачи можно использовать подход скользящего окна и  хеш таблицу для отслеживания встречающихся элементов, что позволяет достичь  линейной временной сложности.**
