### `question_723.md`

**Вопрос 723.** Дан массив строк `words`, гарантированно содержащий хотя бы одно слово. Разработайте алгоритм на Python, который находит и возвращает самую длинную общую подстроку-префикс (общее начало) для всех строк в массиве. Если общей подстроки-префикса не существует, верните пустую строку "".

**Примеры:**

```
Ввод: words = ["дог", "домен", "домра", "доширак"]
Вывод: "до"

Ввод: words = ["документ", "кот", "кум", "ум"]
Вывод: ""
```

-   A. Для решения задачи нужно построить дерево, содержащее все подстроки и проверять их.
-  B.  Для решения задачи нужно сначала отсортировать слова и сравнить первый и последний.
- C.  Для решения задачи нужно сравнивать префиксы первого слова  со всеми остальными словами массива, перебирая символы до первого несовпадения, или пока не закончится одно из слов.
-  D. Для решения задачи нужно использовать только рекурсию.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи поиска самого длинного общего префикса в массиве строк оптимальным подходом будет использование алгоритма посимвольного сравнения. При этом  можно избежать лишних проверок и  гарантируется достижение решения за минимальное время.

*   **Алгоритм (посимвольное сравнение):**
    1.  **Пустой массив:** Если массив `words` пустой, возвращаем пустую строку.
    2.  **Выбор эталона:**  Берем первое слово `words[0]` как эталонную строку  `first_word` для  последующих сравнений. Если есть пустая строка, то  сразу возвращаем пустую строку.
    3.  **Посимвольное сравнение:**  Проходим по символам `first_word`  по индексу:
        *  Проходим по всем словам в массиве, и сравниваем текущий символ `first_word[index]` с символом с тем же  индексом  `other_word[index]`.
            *   Если индекс больше или равен  длине  `other_word`  (не все слова имеют одинаковую длину) или символы не равны, то  значит  текущий префикс перестал быть общим. Возвращаем срез  `first_word` до текущего индекса.
     4.   **Результат:** Если проверка для всех символов эталонного слова пройдена, значит эталонное слово есть самый длинный префикс  и его и возвращаем.

*   **Преимущества алгоритма:**
    *  **Эффективность:**  Алгоритм имеет линейную временную сложность  `O(m*n)`, где `n` — количество слов, а  `m`  - длина наименьшего слова, так как просматривает строку до первой неудачи.
   * **Простота:** Легко реализуемый и понятный  алгоритм.

**Примеры (псевдокод):**
```
function longest_common_prefix(words):
    if length(words) == 0:
      return ""
    first_word = words[0]
    for index from 0 to length(first_word) -1:
      for other_word in words:
        if index >= length(other_word) or first_word[index] != other_word[index]:
          return first_word[0:index]
    return first_word
```

**Примеры реализации в Python:**
```python
def longest_common_prefix(words):
    if not words:
        return ""
    first_word = words[0]
    for index, char in enumerate(first_word):
        for other_word in words:
            if index >= len(other_word) or other_word[index] != char:
                return first_word[:index]
    return first_word


words1 = ["дог", "домен", "домра", "доширак"]
print(f"Ввод: words = {words1}")
print(f"Вывод: '{longest_common_prefix(words1)}'") # Выведет: Вывод: 'до'

words2 = ["документ", "кот", "кум", "ум"]
print(f"Ввод: words = {words2}")
print(f"Вывод: '{longest_common_prefix(words2)}'")  # Выведет: Вывод: ''

words3 = ["flower","flow","flight"]
print(f"Ввод: words = {words3}")
print(f"Вывод: '{longest_common_prefix(words3)}'")  # Выведет: Вывод: 'fl'
words4 = ["aaa","aa","aaa"]
print(f"Ввод: words = {words4}")
print(f"Вывод: '{longest_common_prefix(words4)}'")  # Выведет: Вывод: 'aa'
```
**Разбор вариантов:**
*  **A. Для решения задачи необходимо составить все возможные префиксы для каждого слова, и проверить есть ли среди них общие.:** Неправильно.
*   **B. Для решения задачи можно использовать рекурсивный алгоритм, который будет проверять наличие общего префикса рекурсивно.:** Неправильно. Рекурсивный алгоритм не нужен и менее эффективен.
*  **C. Для решения задачи нужно использовать метод, который сравнивает символы в словах посимвольно до тех пор, пока либо не найдено различие, либо не достигнут конец одного из слов, начиная с первого слова.:** Правильно.
*  **D. Для решения задачи необходимо отсортировать все слова по длинне и использовать  самое короткое слово, так как оно потенциально содержит максимальный префикс.:** Неправильно.  Сортировка не требуется и не влияет на решение.

**В результате:**
*   Алгоритм посимвольного сравнения позволяет эффективно находить  самый длинный общий префикс.
*  Символы сравниваются  до тех пор,  пока не найдено  различие, или не достигнут конец слова.
* Алгоритм  не требует предварительной сортировки.

Таким образом, правильным ответом является **C. Для решения задачи нужно использовать метод, который сравнивает символы в словах посимвольно до тех пор, пока либо не найдено различие, либо не достигнут конец одного из слов, начиная с первого слова.**
