### `question_764.md`

**Вопрос 764.** Дан двумерный массив (матрица) `grid` размера `m x n`, где `1` означает сушу, а `0` означает воду. Разработайте алгоритм для поиска наибольшей площади острова, образованного прилегающими друг к другу (сверху, снизу, слева, справа) ячейками со значением `1`.

**Примеры:**

**Изображение графа в ASCII:**
```
 0 0 1 0 0 0 0 1 0 0 0 0 0
 0 0 0 0 0 0 0 1 1 1 0 0 0
 0 1 1 0 1 0 0 0 0 0 0 0 0
 0 1 0 0 1 1 0 0 1 0 1 0 0
 0 1 0 0 1 1 0 0 1 1 1 0 0
 0 0 0 0 0 0 0 0 0 0 1 0 0
 0 0 0 0 0 0 0 1 1 1 0 0 0
 0 0 0 0 0 0 0 1 1 0 0 0 0
```

```
Ввод: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Вывод: 6

Ввод: grid = [[0,0,0,0,0,0,0,0]]
Вывод: 0
```

-   A. Для решения задачи нужно использовать жадный алгоритм и считать количество единиц в каждой строке.
-   B. Для решения задачи нужно использовать рекурсивный обход графа в глубину (DFS), который будет возвращать кол-во соединенных ячеек.
-  C. Для решения задачи нужно использовать обход в ширину (BFS) и очередь.
-   D. Для решения задачи требуется  алгоритм динамического программирования, при этом необходимо будет сохранять промежуточные данные о площади островов.

**Правильный ответ: B**

**Объяснение:**

Для решения задачи поиска максимальной площади острова в двумерной матрице, оптимальным является применение алгоритма поиска в глубину (DFS). DFS позволяет эффективно обходить все соединенные компоненты,  подсчитывать их площадь  и при этом запоминать максимальную площадь.

*   **Алгоритм (рекурсивный DFS):**
    1.   **Инициализация:** Создаем  переменную `max_area`, в которой будет храниться максимальная найденная площадь острова и устанавливаем значение в 0.
    2.  **Перебор матрицы:** Итерируем по строкам и столбцам  матрицы:
      *    **Проверка ячейки:**  Если значение ячейки равно 1 (является частью острова) и эта ячейка еще не посещалась, то вызываем рекурсивную функцию `dfs`, которая будет подсчитывать все связанные ячейки (часть острова).
       *     Обновляем максимальное значение `max_area` если результат рекурсии больше предыдущего значения.
    3.  **Рекурсивная функция `dfs(row, col)`:**
        *   **Проверка границ:** Если текущие координаты находятся за пределами матрицы или текущая ячейка  равна 0 (вода) или уже посещенная, то возвращаем 0.
          *   **Пометка посещенной ячейки:** Помечаем  текущую ячейку как посещенную  (например  изменяя  значение на `-1`).
          *   **Обход соседей:** Рекурсивно вызываем  `dfs` для  соседних ячеек (сверху, снизу, слева, справа).
      *  Возвращаем  размер острова (1 + размеры всех потомков).

* **Преимущества алгоритма:**
     *   **Обход:**  DFS  позволяет обойти  все ячейки, которые принадлежат  одному острову.
    *    **Изменение матрицы:** Изменяем саму матрицу, отмечая уже пройденные узлы  (не используем  память для хранения пройденных  узлов).
    *   **Эффективность:** Алгоритм обходит матрицу только один раз, обеспечивая  временную сложность `O(n*m)`.

**Примеры (псевдокод):**
```
function max_area_of_island(grid):
   m = number of rows
   n  = number of cols
  max_area = 0

    function dfs(row,col):
        if row out of bound or  col is out of bound or grid[row][col] is not 1:
           return 0

       grid[row][col] = -1 // mark as visited
        return 1 + dfs(row+1, col)+dfs(row-1,col)+dfs(row, col+1)+ dfs(row, col -1)

  for i in range m
     for j in range n
       if grid[i][j] == 1
         max_area  =  max(max_area, dfs(i, j))

  return max_area
```

**Примеры реализации в Python:**

```python
def max_area_of_island(grid):
    m = len(grid)
    if m == 0 :
        return 0
    n = len(grid[0])
    max_area = 0
    def dfs(row, col):
        if row < 0 or row >= m or col < 0 or col >= n or grid[row][col] != 1:
            return 0

        grid[row][col] = -1 # mark as visited
        return 1 + dfs(row + 1, col) + dfs(row - 1, col) + dfs(row, col + 1) + dfs(row, col - 1)

    for row in range(m):
        for col in range(n):
            if grid[row][col] == 1:
                max_area = max(max_area, dfs(row,col))
    return max_area

grid1 = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
print(f"Ввод: grid = {grid1}")
print(f"Вывод: {max_area_of_island(grid1)}") # Выведет 6

grid2 = [[0,0,0,0,0,0,0,0]]
print(f"Ввод: grid = {grid2}")
print(f"Вывод: {max_area_of_island(grid2)}")  # Выведет: 0

grid3 = [
    [1,1,0,0,0],
    [1,1,0,0,0],
    [0,0,1,0,1],
    [0,0,0,0,1]
]
print(f"Ввод: grid = {grid3}")
print(f"Вывод: {max_area_of_island(grid3)}") # Выведет 4

```

**Разбор вариантов:**
*   **A. Для решения задачи нужно использовать жадный алгоритм и считать количество единиц в каждой строке.:** Неправильно.
*  **B. Для решения задачи нужно использовать рекурсивный обход графа в глубину (DFS), который будет возвращать кол-во соединенных ячеек.:** Правильно.
*   **C. Для решения задачи нужно использовать обход в ширину (BFS) и очередь.:** Неправильно. BFS также работает, но  менее оптимален.
*  **D. Для решения задачи требуется алгоритм динамического программирования, при этом необходимо будет сохранять промежуточные данные о площади островов.:** Неправильно.

**В результате:**
*   Рекурсивный  DFS позволяет эффективно  находить и считать площадь каждого  острова в матрице.
*  Позволяет  отслеживать посещенные ячейки, чтобы не пересчитывать их по несколько раз.
*  Алгоритм  обеспечивает линейную сложность относительно кол-ва ячеек.

Таким образом, правильным ответом является **B. Для решения задачи нужно использовать рекурсивный обход графа в глубину (DFS), который будет возвращать кол-во соединенных ячеек.**
