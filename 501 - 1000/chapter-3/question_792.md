### `question_792.md`

**Вопрос 792.** В шеренгу друг за другом стоят `n` человек, где рост `i`-го из них равен `a[i]` условных единиц. Вам нужно найти такую позицию `p` в шеренге, чтобы значение `f(p)` было максимальным.

*   `f(p)` = `[количество людей левее вас того же роста, что и вы]` * `[количество людей правее вас ростом, не равным вашему]`.
*  Вы можете встать в начало, конец или между любыми двумя людьми.
* Вам известны `m` предположений о вашем возможном росте, и для каждого предположения нужно найти оптимальную позицию.

Разработайте алгоритм на Python, который принимает на вход:
*  `n`  - список ростов учеников
*  `m`  - список возможных вариантов вашего роста.

Возвращает список оптимальных позиций для каждого роста из списка  `m`, где позиция должна быть  от 1 до n включительно (0 - начало списка, n - конец списка, в ином случае индекс + 1 ).

**Примеры:**
```
Ввод: n = [1,2,3,2,4], m = [2, 4]
Вывод: [2, 4]
Объяснение:
Для 2 - лучшая позиция = 2 (1 * 1)
Для 4 - лучшая позиция = 4 (0 * 2)

Ввод:  n = [4,4,3,2,1,4], m = [4]
Вывод:  [2]
Объяснение:
Для 4, вставить надо на позицию 2 (1*2)
```

-   A. Для решения задачи необходимо перебрать все возможные позиции и для каждого положения пересчитать значения f(p),  и  выбрать  максимальное.
-   B. Для решения задачи необходимо использовать  двумерный массив,  где будет храниться все посчитанные значения  и выбрать максимальное.
-   C.  Для решения задачи можно использовать  линейный обход массива, и для каждой гипотезы  отслеживать количества равных и неравных, и возвращать позицию, где f(p) будет максимальной.
-   D.  Для решения задачи нужно отсортировать  массив, и затем применить   бинарный поиск.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи поиска оптимальной позиции с максимальным значением `f(p)` для каждого из  предположений роста, наиболее эффективным является использование подхода, основанного на линейном обходе массива `nums`, и  поддержании и  вычислении  `equal` (кол-во равных элементов слева) и `notequal` (кол-во неравных элементов справа), что позволяет  получить  решение  за один проход, избегая  лишних вычислений.

*  **Алгоритм (линейный с перебором):**
    1.  **Инициализация:**
         *  Создаем  списки  `equal` и `notequal`  с начальным  значением `0` и  с  начальным  значением кол-ва неравных элементов (от начала до конца) ,  соответственно,  для каждого из `m` возможных ростов.
       *    Также  создаем  списки `valsave` (максимальное значение) и  `possave` (лучшая позиция) с начальными значениями `0`.
   2.  **Итерирование по массиву `n`:**
           *  Итерируемся по массиву  `n`  (предполагаемые места в шеренге).
         * **Итерируем по  `m`:** Для каждого из m вариантов роста  проверяем:
                 * **Сравнение с  текущим элементом:**  Если текущий элемент  `n[i]` равен текущему значению  из  `m[x]`, то увеличиваем счетчик  `equal[x]`  на 1.
                 *  Если текущий элемент  `n[i]` не равен текущему значению  из `m[x]`, то уменьшаем счетчик  `notequal[x]`  на 1.
            *  **Вычисление `f(p)`:**  Вычисляем  `val = equal[x] * notequal[x]`.
          *  **Обновление:** Если `val` больше чем `valsave[x]`, то  запоминаем новое  `val`  и позицию `possave[x] = i+1`.

    3.  **Результат:** После прохождения всех элементов `n`  возвращаем  массив  `possave`  (с оптимальной позицией  для  каждого  значения  `m`).

*   **Преимущества алгоритма:**
    *   **Линейная сложность:** Алгоритм  обходит массив только один раз, и имеет временную сложность O(n*m).
    *  **Удобство:**  Алгоритм просто  реализовать  и просматривать все варианты.
     *  **Отслеживание:** Позволяет на каждом шаге итерирования по массиву  `n`  отслеживать `equal`,  `notequal`  и `possave` и сохранять их правильные значения.

**Примеры (псевдокод):**
```
function find_positions(n, m):
  equal = new array with length m, default 0
  notequal = new array with length m. initialized with n - sum of same m
  valsave =  new array with length m, default 0
    possave =  new array with length m, default 0

    for i from 0 to length(n)-1
        for x from 0 to length(m) - 1
            if n[i] is equal to m[x]
                increase equal[x]
            if n[i] is not equal to m[x]
                reduce notequal[x]
           val  = equal[x] * notequal[x]
         if val > valsave[x]
             valsave[x] = val
             possave[x]= i+1

     return possave
```

**Примеры реализации в Python:**

```python
def find_positions(n, m):
    equal = [0 for i in range(len(m))]
    notequal = [len(list(filter(lambda x: x != m[i], n))) for i in range(len(m))]
    valsave = [0 for i in range(len(m))]
    possave = [0 for i in range(len(m))]

    for i in range(len(n)):
        for x in range(len(m)):
            if n[i] == m[x]:
                equal[x] += 1
            if n[i] != m[x]:
                notequal[x] -= 1

            val = equal[x] * notequal[x]
            if val > valsave[x]:
                valsave[x] = val
                possave[x] = i+1
    return possave

n1 = [1,2,3,2,4]
m1 = [2, 4]
print(f"Ввод: n = {n1}, m = {m1}")
print(f"Вывод: {find_positions(n1,m1)}") # Выведет: [2, 4]

n2 = [4,4,3,2,1,4]
m2 = [4]
print(f"Ввод: n = {n2}, m = {m2}")
print(f"Вывод: {find_positions(n2,m2)}") # Выведет [2]
```
**Разбор вариантов:**

*  **A. Для решения задачи нужно перебрать все возможные позиции и для каждого положения пересчитать значения f(p), и выбрать максимальное.:** Неправильно. Это  замедлит  программу  из-за лишних пересчетов.
*  **B. Для решения задачи необходимо использовать  двумерный массив,  где будет храниться все посчитанные значения  и выбрать максимальное.:** Неправильно,  двумерный массив не нужен.
*   **C. Для решения задачи можно использовать  линейный обход массива, и для каждой гипотезы отслеживать количества равных и неравных, и возвращать позицию, где f(p) будет максимальной.:** Правильно.
*  **D. Для решения задачи нужно отсортировать массив, и затем применить бинарный поиск.:** Неправильно. Сортировка и бинарный поиск тут не подходят.

**В результате:**

*  Итерирование  по массиву `nums` позволяет получить все нужные данные для дальнейшего вычисления.
*  Сохранение  промежуточных результатов позволяет избежать повторных вычислений.
*  Алгоритм  возвращает  оптимальные позиции  для каждого варианта роста за линейное время.

Таким образом, правильным ответом является **C. Для решения задачи можно использовать линейный обход массива, и для каждой гипотезы  отслеживать количества равных и неравных, и возвращать позицию, где f(p) будет максимальной.**
