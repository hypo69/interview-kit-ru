### `question_725.md`

**Вопрос 725.** Дан массив целых чисел `coins`, представляющий номиналы монет, и целое число `amount`, представляющее целевую сумму. Разработайте алгоритм, который возвращает наименьшее количество монет, требуемое для формирования целевой суммы `amount`, используя монеты из массива `coins`, где количество монет каждого номинала не ограничено. Если  `amount` невозможно получить, то вернуть `-1`.

**Примеры:**

```
Ввод: coins = [1, 2, 5], amount = 11
Вывод: 3
Объяснение: 11 = 5 + 5 + 1

Ввод: coins = [2], amount = 3
Вывод: -1

Ввод: coins = [1], amount = 0
Вывод: 0
```

-   A.  Для решения задачи можно использовать жадный алгоритм и перебирать монеты в порядке убывания.
-   B.  Для решения задачи нужно использовать полный перебор всех возможных комбинаций и возвращать наименьшее количество монет.
-  C. Для решения задачи можно использовать динамическое программирование, строя таблицу с наименьшим количеством монет, для получения текущей суммы.
-  D.  Для решения задачи можно использовать алгоритм поиска в ширину (BFS) и перебирать все возможные комбинации.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи нахождения наименьшего количества монет для заданной суммы, используя неограниченное количество монет, подходит алгоритм динамического программирования. Данный метод позволяет переиспользовать ранее вычисленные решения для меньших сумм.

*   **Алгоритм (динамическое программирование):**
    1.   **Создание массива:** Создается массив `dp` размерностью `amount + 1`, где  `dp[i]`  будет соответствовать наименьшему количеству монет,  нужных  для получения суммы `i`.
     2. **Инициализация:**  Инициализируем массив `dp` бесконечными значениями (кроме `dp[0] = 0`, так как нулевую сумму можно получить за `0`  монет).
     3.  **Итерация по суммам:** Итерируемся по суммам от 1 до `amount`, и  для каждой суммы итерируемся по массиву `coins`:
         *   **Проверка:** Если номинал монеты `coin` меньше или равен текущей сумме `i`, то мы можем применить эту монету, и обновить значение `dp[i]`  как минимум из  `dp[i]`  и `dp[i - coin] + 1`.
    4.  **Результат:**  После итераций возвращаем значение  `dp[amount]`. Если  значение  `dp[amount]` по прежнему равно бесконечности (или другому признаку отсутствия решения), то вернем `-1`, так как  `amount`  нельзя получить из списка монет.

*   **Преимущества алгоритма:**
    *   **Оптимальность:** Находит наиболее оптимальное решение.
    *   **Динамическое программирование:**  Использует таблицу для хранения промежуточных результатов и  избегает повторных вычислений.
   * **Эффективность:**   Обеспечивает  оптимальную сложность, для данной задачи.
*   **Почему другие подходы не подходят:**
    *   **Жадный алгоритм:** Жадный алгоритм не гарантирует нахождения минимального количества монет, особенно при некоторых наборах номиналов.
     *  **Перебор:** Полный перебор всех вариантов очень неэффективен и  имеет большую сложность.
     *   **BFS:** BFS может подойти, но  динамическое программирование позволяет найти более оптимальное решение по времени.

**Примеры (псевдокод):**
```
function find_minimum_coins(coins, amount):
     dp =  an array of length amount+1 and each position set to infinity except 0 set to 0.
     for i from 1 to amount:
          for coin from coins:
                if coin <= i:
                    dp[i] = min(dp[i], dp[i-coin] +1)
      if dp[amount] is not infinity:
            return dp[amount]
      return -1
```
**Примеры реализации в Python:**

```python
def find_minimum_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1

coins1 = [1, 2, 5]
amount1 = 11
print(f"Ввод: coins = {coins1}, amount = {amount1}")
print(f"Вывод: {find_minimum_coins(coins1, amount1)}")  # Выведет: Вывод: 3

coins2 = [2]
amount2 = 3
print(f"Ввод: coins = {coins2}, amount = {amount2}")
print(f"Вывод: {find_minimum_coins(coins2, amount2)}")  # Выведет: Вывод: -1

coins3 = [1]
amount3 = 0
print(f"Ввод: coins = {coins3}, amount = {amount3}")
print(f"Вывод: {find_minimum_coins(coins3, amount3)}")  # Выведет: Вывод: 0
```
**Разбор вариантов:**

*   **A. Для решения задачи нужно использовать жадный алгоритм и перебирать монеты в порядке убывания.:** Неправильно.  Жадные алгоритмы не гарантируют нахождение минимального решения.
*   **B. Для решения задачи необходимо использовать полный перебор всех возможных комбинаций и возвращать наименьшее количество монет.:** Неправильно.
*   **C. Для решения задачи нужно использовать динамическое программирование, строя таблицу с наименьшим количеством монет, для получения текущей суммы.:** Правильно.
*   **D. Для решения задачи нужно использовать алгоритм поиска в ширину (BFS) и перебирать все возможные комбинации.:** Неправильно. BFS  требует много памяти.

**В результате:**
*  Использование динамического программирования позволяет найти оптимальное решение.
*   Таблица (массив)  `dp` используется для хранения промежуточных результатов.
*  Рекуррентная формула  позволяет  итеративно  вычислить  наименьшее число монет.

Таким образом, правильным ответом является **C. Для решения задачи нужно использовать динамическое программирование, строя таблицу с наименьшим количеством монет, для получения текущей суммы.**
