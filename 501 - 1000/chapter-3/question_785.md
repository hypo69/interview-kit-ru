### `question_785.md`

**Вопрос 785.** Дано число `n`, представляющее количество кандидатов для двух космических экспедиций на Марс.  Также дана матрица `conflicts` размера `n x n`, где `conflicts[i][j] = "+"`, если участие кандидатов `i` и `j` в одной экспедиции нежелательно. Разработайте алгоритм на Python, который распределяет кандидатов на две группы так, чтобы не было конфликтов внутри каждой группы. Если это невозможно, выведите `"No solution"`. В случае, если существуют несколько вариантов разбиения с минимальной разницей в размерах групп, выведите то решение, в котором первая группа лексикографически меньше.

*   Если есть несколько вариантов разбиения с одинаковым размером групп - то выбираем ту, где первая группа меньше лексикографически.
*   Нумерация кандидатов начинается с `1`.

**Примеры:**
```
Ввод:
8
- - + - - - - -
- - - + - - - -
+ - - - - - - +
- + - - - + - -
- - - - - - - -
- - - + - - - -
- - - - - - - +
- - + - - - + -
Вывод: 1 2 6 8

```
**Объяснение:**
```
Ввод:
3
- - +
- - -
+ - -
Вывод: 1 2
```

- A. Для решения задачи нужно использовать жадный алгоритм, добавляя кандидатов в ту группу, в которой меньше людей.
- B. Для решения задачи нужно перебрать все возможные комбинации разбиения на 2 группы, проверить на конфликт и выбрать лучший.
-  C. Для решения задачи необходимо использовать  алгоритм backtracking, с возможностью  пометить каждого кандидата в группу 1 или группу 2,  и отсечь невалидные  варианты, а также сохранить лучший.
-  D. Для решения задачи необходимо применить бинарный поиск  с использованием  массива  состояния  групп.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи распределения кандидатов на две группы с минимальными конфликтами и минимальной разницей в размерах групп, оптимальным будет использование алгоритма бэктрекинга. Бэктрекинг позволяет перебрать все возможные варианты распределения,  гарантируя, что будет найдено оптимальное решение при заданных ограничениях.

*   **Алгоритм (рекурсивный с бэктрекингом):**
    1. **Инициализация:**
          *  `best_group1` (список) -  для хранения  наилучшей первой группы и ставим  в `null` (чтобы проверять, что еще нет лучшего решения).
         *  `min_diff`  -  для хранения минимальной разницы между группами ставим  в infinity.
     2.  **Рекурсивная функция:** Создадим  рекурсивную функцию, которая принимает:
            *  `index`-  текущий индекс кандидата,  
           *  `group1`  -  кандидатов для первой группы.
         * `group2`  -  кандидатов для второй группы.
       *  **Базовый случай:** Если перебраны все кандидаты, то   вычисляем разницу между кол-вом кандидатов в  группах и проверяем  является  ли она меньше чем  `min_diff`:
            *  Если меньше -  то мы нашли лучшее решение.
          *   Если равна, то нужно  проверить лексикографически, и если  новое решение меньше, то  меняем  `best_group1`.
         * **Рекурсивный вызов:**  Для каждого кандидата в цикле :
            *   Сначала, пытаемся  добавить кандидата в `group1`, и рекурсивно вызываем функцию.  (нужно проверить что он не конфликтует  ни с одним из кандидатов `group1`)
            *    После возвращения  убираем кандидата из `group1` (чтобы  можно  было пробовать  следующие варианты).
             *   Пытаемся добавить кандидата в `group2`, если небыло  конфликта, и рекурсивно вызываем функцию.
             *    После возвращения  убираем  кандидата из `group2`.
    3.  **Начальный вызов:**  Вызываем рекурсивную функцию  с начальными параметрами  (индекс `0`,  пустые `group1` и  `group2`).
   4.   **Результат:** После  завершения рекурсии, возвращаем  отсортированный  `best_group1`  или `"No solution"`

*   **Преимущества алгоритма:**
    *   **Перебор всех вариантов:**  Бэктрекинг позволяет  перебрать все возможные комбинации  групп, и гарантирует нахождение решения.
    *   **Отсечение:** Алгоритм  отсекает не валидные  комбинации.
  *    **Оптимальность:** Алгоритм  обеспечивает  выбор решения с минимальной разницей в размере групп и с минимальным лексикографическим порядком, если есть несколько вариантов.

**Примеры (псевдокод):**
```
function find_best_teams(n, conflicts):
    best_group1 = null
    min_diff = infinity;
  function backtrack(index, group1, group2):
    if index == n
        diff = abs(length(group1) - length(group2))
        if diff < min_diff
            min_diff = diff;
            best_group1 = group1;
         elif diff = min_diff
          best_group1 = min (group1, best_group1)
         return
    current_player = index+1
    add to group 1 if no conflicts, backtrack, remove from group1
    add to group 2 if no conflicts, backtrack, remove from group2
    return if best_group1 is null - then No solution, or  sort and return it.
```

**Примеры реализации в Python:**
```python
def find_best_teams(n, conflicts):
    best_group1 = None
    min_diff = float('inf')
    def backtrack(index, group1, group2):
        nonlocal min_diff, best_group1
        if index == n:
           diff = abs(len(group1) - len(group2))
           if diff < min_diff:
               min_diff = diff
               best_group1 = sorted(group1)
           elif diff == min_diff:
               if group1 < best_group1:
                best_group1 = sorted(group1)
           return

        current_player = index+1 # player index starts from 1 not from zero

        can_add_to_group1 = True
        for player_in_group1 in group1:
             if conflicts[player_in_group1-1][current_player-1] == '+':
                can_add_to_group1 = False
        if can_add_to_group1:
          group1.append(current_player)
          backtrack(index + 1, group1, group2)
          group1.pop()

        can_add_to_group2 = True
        for player_in_group2 in group2:
             if conflicts[player_in_group2-1][current_player-1] == '+':
                can_add_to_group2 = False
        if can_add_to_group2:
          group2.append(current_player)
          backtrack(index + 1, group1, group2)
          group2.pop()


    backtrack(0, [], [])
    return best_group1 if best_group1 else "No solution"

n1 = 8
conflicts1 = [
    ['-','-','+','-','-','-','-','-'],
    ['-','-','-','+','-','-','-','-'],
    ['+','-','-','-','-','-','-','+'],
    ['-','+','-','-','-','+','-','-'],
    ['-','-','-','-','-','-','-','-'],
    ['-','-','-','+','-','-','-','-'],
    ['-','-','-','-','-','-','-','+'],
    ['-','-','+','-','-','-','+','-']
]

print(f"Ввод: n = {n1}, conflicts = {conflicts1}")
print(f"Вывод: {find_best_teams(n1, conflicts1)}") # Выведет:  [1, 2, 6, 8]

n2 = 3
conflicts2 = [
    ['-', '-', '+'],
    ['-', '-', '-'],
    ['+', '-', '-']
]
print(f"Ввод: n = {n2}, conflicts = {conflicts2}")
print(f"Вывод: {find_best_teams(n2, conflicts2)}") # Выведет [1, 2]
```

**Разбор вариантов:**
*   **A. Для решения задачи нужно использовать жадный алгоритм, добавляя кандидатов в ту группу, в которой меньше людей.:** Неправильно. Жадный алгоритм не гарантирует нахождения оптимального решения.
*   **B. Для решения задачи нужно перебрать все возможные комбинации разбиения на 2 группы, проверить на конфликт и выбрать лучший.:** Неправильно, это будет занимать много времени.
*    **C. Для решения задачи необходимо использовать алгоритм backtracking, с возможностью пометить каждого кандидата в группу 1 или группу 2, и отсечь невалидные варианты, а также сохранить лучший.:** Правильно.
*    **D. Для решения задачи необходимо применить бинарный поиск  с использованием массива состояния  групп.:** Неправильно. Бинарный поиск тут не подходит.

**В результате:**
*  Рекурсивный алгоритм с бэктрекингом позволяет перебрать все возможные варианты.
*   Обновление  `best_group1` с минимальной разницей  гарантирует получение нужного решения.
*  Использование бэктрекинга  отсекает не валидные комбинации.

Таким образом, правильным ответом является **C. Для решения задачи необходимо использовать алгоритм backtracking, с возможностью  пометить каждого кандидата в группу 1 или группу 2, и отсечь невалидные  варианты, а также сохранить лучший.**
