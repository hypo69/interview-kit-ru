### `question_704.md`

**Вопрос 704.** Дан отсортированный в порядке неубывания (то есть в порядке возрастания, с возможностью равенства) целочисленный массив `nums` и целое число `target`. Разработайте алгоритм для поиска первой и последней позиции целевого элемента `target` в массиве `nums`, с временной сложностью O(log n). Если целевой элемент отсутствует в массиве, верните `[-1, -1]`.

**Примеры:**
```
Ввод: nums = [5,7,7,8,8,10], target = 8
Вывод: [3,4]

Ввод: nums = [5,7,7,8,8,10], target = 6
Вывод: [-1,-1]
```
-   A.  Для решения задачи необходимо перебрать все элементы массива и найти первый и последний индексы вхождения target.
-  B.  Для решения задачи можно использовать только двоичный поиск, который найдет только  средний индекс, если такой элемент есть.
- C. Для решения задачи нужно применить два бинарных поиска: один для нахождения первой позиции, а второй для нахождения последней позиции, а если element не найден, то нужно вернуть `[-1,-1]`.
- D. Для решения задачи необходимо использовать алгоритм линейного поиска в массиве.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи поиска первой и последней позиций элемента в отсортированном массиве с временной сложностью `O(log n)` оптимальным решением является использование двух алгоритмов бинарного поиска. Один из них находит первую позицию, а второй — последнюю.

*  **Алгоритм (два бинарных поиска):**
    1.  **Первый бинарный поиск (первая позиция):**
         *   Ищем элемент, равный `target`, но при этом  нужно сдвигаться влево, пока не будет найден самый левый элемент.
        *   Если элемент не найден, то выходим из алгоритма, и возвращаем `[-1, -1]`.
     2.  **Второй бинарный поиск (последняя позиция):**
          * Ищем элемент, равный `target`, но при этом  нужно сдвигаться вправо, пока не будет найден самый правый элемент.
          *  Если элемент не найден, то выходим из алгоритма.
      3.   **Результат:**  После двух бинарных поисков возвращается  список из первого и последнего индекса.

*  **Преимущества алгоритма:**
    *   **Логарифмическая сложность:** Обеспечивает временную сложность O(log n) для поиска каждой позиции.
   *  **Использование свойств отсортированного массива:**  Использует отсортированность массива для быстрого поиска нужного элемента.
 *   **Два бинарных поиска:** Алгоритм использует два бинарных поиска, что  гарантирует нахождение левого и правого индекса.

*  **Почему другие варианты не подходят:**
    * **Линейный поиск:**  Обход массива от начала до конца приведет к сложности O(n).
     * **Один бинарный поиск:**  Один поиск  не позволит найти первую и последнюю позицию, если элемент повторяется.
     *  **Сортировка:**  Сортировка массива  в начале алгоритма является не нужной и замедлит выполнение.

**Примеры (псевдокод):**

```
function find_range(nums, target):

    # Функция для поиска левой границы:
    function find_left_index(nums, target):
        low = 0
        high = length(nums) - 1
        index = -1

        while low <= high:
            mid = low + (high - low) // 2
            if nums[mid] >= target:
              if nums[mid] == target:
                   index = mid # запоминаем, где нашли
              high = mid - 1
            else:
                low = mid + 1
        return index

   # Функция для поиска правой границы:
    function find_right_index(nums, target):
        low = 0
        high = length(nums) - 1
        index = -1
        while low <= high:
           mid = low + (high - low) // 2
           if nums[mid] <= target:
            if nums[mid] == target:
              index = mid # запоминаем где нашли
            low = mid + 1
           else:
             high = mid - 1

        return index

    left = find_left_index(nums, target) # Поиск левого индекса
    if left == -1 :
        return [-1, -1] # не найден элемент
    right = find_right_index(nums, target) # Поиск правого индекса

    return [left, right]
```

**Примеры реализации в Python:**
```python
def find_range(nums, target):

    def find_left_index(nums, target):
        low = 0
        high = len(nums) - 1
        index = -1
        while low <= high:
            mid = low + (high - low) // 2
            if nums[mid] >= target:
              if nums[mid] == target:
                   index = mid
              high = mid - 1
            else:
                low = mid + 1
        return index

    def find_right_index(nums, target):
        low = 0
        high = len(nums) - 1
        index = -1
        while low <= high:
           mid = low + (high - low) // 2
           if nums[mid] <= target:
            if nums[mid] == target:
              index = mid
            low = mid + 1
           else:
             high = mid - 1
        return index

    left = find_left_index(nums, target)
    if left == -1:
      return [-1,-1]
    right = find_right_index(nums, target)
    return [left, right]

nums1 = [5,7,7,8,8,10]
target1 = 8
print(f"Ввод: nums = {nums1}, target = {target1}")
print(f"Вывод: {find_range(nums1, target1)}") # Выведет Вывод: [3, 4]


nums2 = [5,7,7,8,8,10]
target2 = 6
print(f"Ввод: nums = {nums2}, target = {target2}")
print(f"Вывод: {find_range(nums2, target2)}") # Выведет Вывод: [-1, -1]

nums3 = [1]
target3 = 1
print(f"Ввод: nums = {nums3}, target = {target3}")
print(f"Вывод: {find_range(nums3, target3)}") # Выведет Вывод: [0, 0]

nums4 = [2,2]
target4 = 2
print(f"Ввод: nums = {nums4}, target = {target4}")
print(f"Вывод: {find_range(nums4, target4)}")  # Выведет Вывод: [0, 1]
```

**Разбор вариантов:**
*   **A. Для решения задачи необходимо перебрать все элементы массива и найти первый и последний индексы вхождения target.:** Неправильно. Полный перебор займет  O(n) времени.
*  **B. Для решения задачи можно использовать только двоичный поиск, который найдет только  средний индекс, если такой элемент есть.:** Неправильно. Необходимо найти и левый и правый индекс.
*  **C. Для решения задачи нужно применить два бинарных поиска: один для нахождения первой позиции, а второй для нахождения последней позиции, а если element не найден, то нужно вернуть `[-1,-1]`.:** Правильно.
* **D. Для решения задачи необходимо использовать алгоритм линейного поиска в массиве.:** Неправильно. Линейный поиск не удовлетворяет  требованиям по сложности.

**В результате:**
*  Алгоритм использует два бинарных поиска для  нахождения начальной и конечной позиций элемента с сложностью  `O(log n)`  для каждого поиска.
*  Проверяются случаи,  когда целевой элемент не найден.
*  Эффективно решает поставленную задачу за требуемое время.

Таким образом, правильным ответом является **C. Для решения задачи нужно применить два бинарных поиска: один для нахождения первой позиции, а второй для нахождения последней позиции, а если element не найден, то нужно вернуть `[-1,-1]`**.
