### `question_782.md`

**Вопрос 782.** Разработайте алгоритм на Python для реализации "грубой силы" (brute-force) для взлома пароля. Функция должна принимать на вход:
*   `password` - строку с паролем,
*   `characters` -  строку со всеми допустимыми символами для пароля,
*   `max_length`  - целое число, максимальная  длинна  пароля.

Функция должна генерировать все возможные комбинации паролей,  до тех пор, пока не найдет нужный, а затем вернуть его, гарантируя, что пароль будет найден.

*   Рекомендуется ограничить длину пароля до 4-х символов для тестирования.

**Примеры:**

```
# предполагая characters = "abc"
Ввод: password = "c", max_length = 3
Вывод: "c"

Ввод: password = "abc", max_length = 3
Вывод: "abc"

Ввод: password = "ad", max_length = 3
Вывод: "ad"
```

-   A. Для решения задачи необходимо использовать жадный алгоритм и каждый раз добавлять наиболее вероятные символы, до достижения пароля, при этом не перебирая все варианты.
-   B. Для решения задачи, нужно  использовать генераторы, чтобы получить все  варианты паролей и затем перебрать их.
- C. Для решения задачи необходимо использовать рекурсивный алгоритм (DFS) с бэктрекингом, где на каждом шаге алгоритма добавляем любой символ из допустимых символов, и проверяем если текущая комбинация равна паролю, то возвращаем её.
-   D. Для решения задачи нужно перебрать все возможные строки через вложенные циклы.

**Правильный ответ: C**

**Объяснение:**

Для реализации "грубой силы" (brute-force), которая гарантирует нахождения пароля в заданных ограничениях по символам и длинне, необходимо применить рекурсивный алгоритм с использованием бэктрекинга. Рекурсия позволяет легко генерировать все возможные комбинации,  при этом  проверяя их на соответствие с входным значением.

*   **Алгоритм (рекурсивный с бэктрекингом):**
    1.  **Рекурсивная функция:** Создаем рекурсивную функцию, которая принимает:
        *   `current_combination` - текущую сгенерированную строку.
       *   `characters` - строку с допустимыми  символами.
        *   `max_length` - максимальная длина строки.
    2. **Базовый случай:**
          *  Если  `current_combination`  равно  искомому паролю, возвращаем  `current_combination`.
          *   Если длина  `current_combination` больше  `max_length`, то  возвращаем `None`.
    3.  **Итерация:** Перебираем  символы из строки `characters`.
        *    Добавляем  к текущей  строке `current_combination`  один  символ `char` , и вызываем  рекурсивную функцию, с новой подстрокой.
          *  Если результат  рекурсивного вызова  не равен `None`, то это верный пароль, и возвращаем его.
        *   После рекурсивного вызова, удаляем  `char` из `current_combination`.
    4.  **Результат:** Если цикл завершен, а  пароль не был найден, значит такого пароля не существует, и  возвращаем `None` (что противоречит условию задачи).

*   **Преимущества алгоритма:**
    *   **Перебор всех вариантов:**  Алгоритм перебирает все возможные строки (при заданных параметрах).
    *   **Рекурсивная природа:** Рекурсия  легко позволяет создавать комбинации строк различной  длинны.
   *  **Бэктрекинг:** Отбрасывает неверные пути, возвращаясь к предыдущим состояниям  при не совпадении.
   *   **Универсальность:** Позволяет использовать любой набор символов.

**Примеры (псевдокод):**

```
function brute_force(password, characters, max_length):
    function backtrack(current_combination):
        if current_combination is equal to password:
            return current_combination;
        if length(current_combination) > max_length:
          return null
         for char from characters:
          new_comb = current_combination + char
           if result is not null
            return result;
         backtrack("", characters)
     return None
```
**Примеры реализации в Python:**
```python
def brute_force(password, characters, max_length):
    def backtrack(current_combination):
        if current_combination == password:
            return current_combination
        if len(current_combination) > max_length:
            return None
        for char in characters:
          new_comb = current_combination + char
          result = backtrack(new_comb)
          if result is not None:
              return result
        return None
    return backtrack("", characters)


password1 = "c"
characters1 = "abc"
max_length1 = 3
print(f"Ввод: password = '{password1}', characters = '{characters1}', max_length = {max_length1}")
print(f"Вывод: '{brute_force(password1, characters1, max_length1)}'") # Выведет: 'c'
password2 = "abc"
characters2 = "abc"
max_length2 = 3
print(f"Ввод: password = '{password2}', characters = '{characters2}', max_length = {max_length2}")
print(f"Вывод: '{brute_force(password2, characters2, max_length2)}'")  # Выведет:  'abc'
password3 = "ad"
characters3 = "abcde"
max_length3 = 3
print(f"Ввод: password = '{password3}', characters = '{characters3}', max_length = {max_length3}")
print(f"Вывод: '{brute_force(password3, characters3, max_length3)}'") # Выведет:  'ad'
```
**Разбор вариантов:**
* **A. Для решения задачи необходимо использовать жадный алгоритм и каждый раз добавлять наиболее вероятные символы, до достижения пароля, при этом не перебирая все варианты.:** Неправильно. Жадный алгоритм не гарантирует нахождение пароля и не перебирает все возможные варианты.
*   **B. Для решения задачи нужно использовать генераторы, чтобы получить все варианты паролей и затем перебрать их.:** Неправильно. Генераторы не позволяют обойти все варианты без  рекурсии и бэктрекинга.
*  **C. Для решения задачи необходимо использовать рекурсивный алгоритм (DFS) с бэктрекингом, где на каждом шаге алгоритма добавляем любой символ из допустимых символов, и проверяем если текущая комбинация равна паролю, то возвращаем её.:** Правильно.
*  **D. Для решения задачи нужно перебрать все возможные строки через вложенные циклы.:** Неправильно, данный метод не является эффективным,  и будет требовать создание огромного количества циклов, в зависимости от `max_length` и `len(characters)`.

**В результате:**
*   Рекурсивный алгоритм с бэктрекингом позволяет  перебрать все возможные комбинации  паролей.
*   Используется  заглушка,  для  уменьшения  рекурсивных  вызовов.

Таким образом, правильным ответом является **C. Для решения задачи необходимо использовать рекурсивный алгоритм (DFS) с бэктрекингом, где на каждом шаге алгоритма добавляем любой символ из допустимых символов, и проверяем если текущая комбинация равна паролю, то возвращаем её.**
