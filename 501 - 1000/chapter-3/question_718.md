### `question_718.md`

**Вопрос 718.** Дан массив целых чисел `citations`, где `citations[i]` представляет количество цитирований `i`-ой статьи. Разработайте алгоритм для вычисления максимального h-индекса автора.

*   **h-индекс** - это наибольшее число `h`, такое, что у автора есть `h` статей, каждая из которых цитируется как минимум `h` раз.

**Примеры:**
```
Ввод: citations = [3, 0, 6, 1, 5]
Вывод: 3

Ввод: citations = [1, 1]
Вывод: 1
```

-   A. Для решения задачи нужно перебрать все возможные числа,  и проверить их на соответствие h-индексу.
-   B. Для решения задачи необходимо отсортировать массив и проверить значения с начала списка, пока не найдем наименьший элемент.
-   C. Для решения задачи необходимо использовать массив счетчиков, и отслеживать число статей с соответствующим кол-вом цитирований, а затем  перебрать массив в обратном порядке для поиска максимального h-индекса.
-   D.  Для решения задачи нужно использовать бинарный поиск.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи поиска h-индекса, оптимальным подходом является использование массива счетчиков и итерация по нему с конца для нахождения максимального индекса, удовлетворяющего критерию h-индекса.

*  **Алгоритм (с использованием массива счетчиков):**
    1.  **Инициализация:**
         *  Создается массив счетчиков  `counters`, где `counters[i]`  - количество статей с i  цитированиями,  где длина массива равна `length(citations) +1`.
    2.  **Подсчет вхождений:** Итерируемся по массиву `citations`. Для каждого элемента  `x`:
        *  Если `x`  меньше, чем длина  массива `citations` то увеличиваем счетчик на `1` по индексу `x`.
        *   Иначе (если `x`  больше или равно длине массива), то увеличиваем  счетчик для `n`.
     3.   **Создание "линейного" массива:** Создаем новый массив `m` в котором  `counters[x]`  раз повторяется число `x`.
      4. **Поиск h-индекса:**
          *   Проходим по `m`  с конца (индекса  `n` до 1 ) и для каждого индекса  проверяем, что значение больше или равно индексу.
         *   Если условие выполняется, значит данный индекс является  h-индексом (или одним из вариантов), и мы возвращаем его.

*  **Преимущества алгоритма:**
    *  **Линейная сложность:**  Алгоритм  имеет  временную сложность  `O(n)`,  где n - количество элементов в массиве `nums`.
    *   **Исключение повторений:** Массив `m`  используется для  устранения дубликатов и более легкой проверки.
*   **Почему другие варианты не подходят:**
   *   **Сортировка:** Сортировка, даже если её применить,  замедлит алгоритм,  а перебор всех значений  с последующей проверкой  будет неэффективным.
    *   **Рекурсия:** Использование рекурсии неэффективно.
   * **Жадный алгоритм:**  Жадные алгоритмы  не  являются оптимальными для решения задачи.
   *    **Бинарный поиск:** Бинарный поиск  не применим для не отсортированного массива, и не позволит найти  h-индекс.

**Примеры (псевдокод):**
```
function calculate_h_index(citations):
  n = length(citations)
  counts = new array with length n+1, with default 0

  for citation in citations:
      if citation < n:
          counts[citation] +=1
      else:
          counts[n] +=1
  m = new array
  for  i in range(n):
     add i to array m, counts[i] times.
  for  i from length(m) to 1:
      if m[n-1] >= i:
          return i
  return 0 # return 0 if h-index not found
```
**Примеры реализации в Python:**
```python
def calculate_h_index(citations):
    n = len(citations)
    s = [0] * (n + 1)
    for x in citations:
        if x < n:
            s[x] += 1
        else:
            s[n] += 1

    m = []
    for x in range(len(s)):
        m.extend([x] * s[x])

    for n in range(1, len(m) + 1):
        if m[-n] >= n:
            return n
    return 0

citations1 = [3, 0, 6, 1, 5]
print(f"Ввод: citations = {citations1}")
print(f"Вывод: {calculate_h_index(citations1)}")  # Вывод: 3

citations2 = [1,1]
print(f"Ввод: citations = {citations2}")
print(f"Вывод: {calculate_h_index(citations2)}")  # Вывод: 1

```
**Разбор вариантов:**
*  **A. Для решения задачи нужно перебрать все возможные числа, и проверить их на соответствие h-индексу.:** Неправильно.
*  **B. Для решения задачи необходимо отсортировать массив и проверить значения с начала списка, пока не найдем наименьший элемент.:** Неправильно.
*   **C. Для решения задачи необходимо использовать массив счетчиков, и отслеживать число статей с соответствующим кол-вом цитирований, а затем  перебрать массив в обратном порядке для поиска максимального h-индекса.:** Правильно.
*   **D. Для решения задачи нужно использовать бинарный поиск.:** Неправильно.

**В результате:**
* Использование массива счетчиков позволяет отслеживать количество статей с определенным количеством цитирований.
*  Обратный проход по массиву позволяет найти нужный h-индекс.
*  Алгоритм имеет сложность O(n) и не требует большого количества памяти.

Таким образом, правильным ответом является **C. Для решения задачи необходимо использовать массив счетчиков, и отслеживать число статей с соответствующим кол-вом цитирований, а затем  перебрать массив в обратном порядке для поиска максимального h-индекса.**
