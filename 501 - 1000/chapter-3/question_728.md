### `question_728.md`

**Вопрос 728.** Дан целочисленный массив `nums`. Разработайте алгоритм для поиска и возвращения всех уникальных неубывающих подпоследовательностей (не обязательно непрерывных) в массиве `nums`, длина которых не менее двух.

*   **Неубывающая подпоследовательность:** Последовательность элементов, где каждый следующий элемент больше или равен предыдущему (допускаются повторения).
*   Уникальные комбинации.

**Примеры:**

```
Ввод: nums = [4,6,7,7]
Вывод: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

Ввод: nums = [4,4,3,2,1]
Вывод: [[4,4]]
```

-   A. Для решения задачи нужно отсортировать массив и перебрать все подмассивы.
- B.  Для решения задачи нужно использовать жадный алгоритм, выбирая минимальный элемент и добавляя к нему больше, либо равный элементы.
-  C. Для решения задачи нужно использовать алгоритм динамического программирования, запоминая  результаты на каждом шаге.
-  D. Для решения задачи можно использовать  рекурсивный  алгоритм с бэктрекингом,  чтобы перебрать все возможные комбинации.

**Правильный ответ: D**

**Объяснение:**

Для решения задачи нахождения всех уникальных неубывающих подпоследовательностей в массиве, наиболее подходящим подходом является использование рекурсивного алгоритма с бэктрекингом (откатом), что позволяет эффективно перебрать все варианты, а также использовать `set` для устранения повторений на этапе нахождения подпоследовательности.

*   **Алгоритм (рекурсивный с бэктрекингом):**
    1.  **Создание множества:**  Создаем множество  `result`  для хранения всех уникальных последовательностей.
    2. **Рекурсивная функция:**  Создаем рекурсивную функцию, которая:
         *   Принимает  индекс текущего элемента  `index`,  текущую подпоследовательность  `current_subsequence` и результирующее множество `result`.
         *  **Базовый случай:** Если длина `current_subsequence`  больше или равна 2, добавляем  подпоследовательность в  множество  `result`,  преобразовав ее в кортеж (так как `set` не может содержать списки).
      *   **Итерация:** Итерируемся по  элементам `nums`  начиная с текущего `index`:
         *   **Проверка условия:** Если текущий элемент `nums[i]` больше или равен последнему элементу  `current_subsequence` (или если  `current_subsequence`  пустой), то
              *   Добавляем  элемент `nums[i]` в `current_subsequence`.
               * Рекурсивно вызываем функцию  для  следующего индекса.
             * **Бэктрекинг:**  После рекурсивного вызова удаляем последний элемент  из `current_subsequence` (откат), чтобы  исследовать другие комбинации.
    3.   **Вызов рекурсии:** Вызываем  функцию  с начальными параметрами, и в результате вернется множество (которое затем преобразовываем в список).

*   **Преимущества алгоритма:**
    *   **Полный перебор:** Позволяет исследовать все возможные варианты.
    *   **Бэктрекинг:** Позволяет исключить неверные варианты.
    *   **Устранение дубликатов:** Множество исключает повторы.

**Примеры (псевдокод):**
```
function find_all_non_decreasing_subsequences(nums):
  result = set()
  function backtrack(index, current_combination)
    if len(current_combination) >= 2:
      result.add(convert_to_tuple(current_combination))
    for i from index to length(nums)-1:
       if len(current_combination) == 0 or nums[i] >= last element from current_combination:
        current_combination.add(nums[i])
        backtrack(i+1, current_combination)
        current_combination.removeLast()

  backtrack(0,[])
  return convert_set_to_list(result)
```
**Примеры реализации в Python:**
```python
def find_all_non_decreasing_subsequences(nums):
    result = set()

    def backtrack(index, current_combination):
      if len(current_combination) >= 2:
         result.add(tuple(current_combination))
      for i in range(index, len(nums)):
        if not current_combination or nums[i] >= current_combination[-1]:
         current_combination.append(nums[i])
         backtrack(i + 1, current_combination)
         current_combination.pop()

    backtrack(0, [])
    return [list(seq) for seq in result]


nums1 = [4,6,7,7]
print(f"Ввод: nums = {nums1}")
print(f"Вывод: {find_all_non_decreasing_subsequences(nums1)}") # Вывод:  [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]

nums2 = [4,4,3,2,1]
print(f"Ввод: nums = {nums2}")
print(f"Вывод: {find_all_non_decreasing_subsequences(nums2)}") # Выведет Вывод: [[4, 4]]

nums3 = [1,2,3]
print(f"Ввод: nums = {nums3}")
print(f"Вывод: {find_all_non_decreasing_subsequences(nums3)}") # Выведет Вывод: [[1, 2], [1, 2, 3], [1, 3], [2, 3]]
```
**Разбор вариантов:**
*  **A. Для решения задачи нужно отсортировать массив и перебрать все подмассивы.:** Неправильно. Сортировка  не нужна, а перебор всех подмассивов будет неэффективен.
*  **B. Для решения задачи нужно использовать жадный алгоритм, выбирая минимальный элемент и добавляя к нему больше, либо равный элементы.:** Неправильно. Жадный алгоритм не найдет все комбинации.
*   **C. Для решения задачи нужно использовать алгоритм динамического программирования, запоминая  результаты на каждом шаге.:** Неправильно. Хотя ДП  может применяться, но подход с бэктрекингом является более понятным решением.
*   **D. Для решения задачи можно использовать  рекурсивный  алгоритм с бэктрекингом,  чтобы перебрать все возможные комбинации.:** Правильно.

**В результате:**
*   Рекурсивный алгоритм с бэктрекингом позволяет перебрать все  подпоследовательности,  удовлетворяющие условию.
*    Множество позволяет сохранить только уникальные  последовательности.
*  Алгоритм просматривает все варианты и  возвращает только валидные подпоследовательности.

Таким образом, правильным ответом является **D. Для решения задачи можно использовать рекурсивный  алгоритм с бэктрекингом,  чтобы перебрать все возможные комбинации.**
