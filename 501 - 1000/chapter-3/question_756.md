### `question_756.md`

**Вопрос 756.** Разработайте класс `MyStack` на Python, который реализует структуру данных "стек" с использованием только двух очередей (queues). Класс `MyStack` должен поддерживать следующие методы:

*   `__init__()`: Инициализирует пустой стек.
*   `push(x)`: Добавляет элемент `x` на вершину стека.
*   `pop()`: Удаляет элемент с вершины стека и возвращает его.
*   `top()`: Возвращает элемент на вершине стека, не удаляя его.
*   `empty()`: Возвращает `True`, если стек пустой, и `False` в противном случае.

**Примеры:**

```
Ввод: 
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
Вывод: [null, null, null, 2, 2, False]
Объяснение:
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
```

-   A. Для реализации стека  можно использовать только один массив, и добавление элемента происходит в конец массива, а удаление с начала.
-  B.  Для реализации стека можно использовать два списка, при этом все операции будут происходить только со вторым списком.
-  C. Для реализации стека можно использовать две очереди, при этом  новые элементы  добавляются в одну из очередей,  а удаление, показ и проверка на  пустоту происходят через вторую очередь (когда она не пустая).
-  D.  Для реализации стека нужно использовать только рекурсивный алгоритм.

**Правильный ответ: C**

**Объяснение:**

Для реализации стека с использованием двух очередей необходимо распределять элементы между очередями таким образом, чтобы при операциях `pop`, `top` и  `empty`  использовалась та очередь, в которой находится вершина стека.

*   **Алгоритм (с двумя очередями):**
    1.  **Инициализация:**
        *   Создаем две пустые очереди `q1` и `q2`.
        *  `top` - для хранения  последнего добавленного значения (которое находится на вершине стека).
    2. **Метод `push(x)`:**
         *  Записываем  значение в очередь  `q1`.
         * Обновляем переменную  `top`.
    3.  **Метод `pop()`:**
        *  Используем очередь `q1`, если она не пуста:
              *  Перемещаем все элементы `q1`, кроме последнего, в очередь `q2`,  а последний элемент  запоминаем как  `last` и возвращаем его.
             *   Меняем местами  `q1` и `q2`, так, что `q1`  всегда будет содержать все значения и является активной очередью.
        *  Если  `q1`  пустая, то возвращаем None.
     4.  **Метод `top()`:**  Возвращает  значение, сохраненное в переменной `top`.
     5. **Метод `empty()`:** Проверяем, пуста ли очередь  `q1` (и возвращаем `True` или `False`).

*   **Преимущества алгоритма:**
    *   **Реализация стека:** Позволяет реализовать стек, используя только очереди.
    *   **Простота:** Легко реализовать и понять.
     *  **Управление очередями:**  Для каждой операции требуется  выбор  активной очереди.
     * **Возврат значения:** Для pop возвращается значение из очереди, для top - возвращается сохраненная переменная.
     * **Четная и нечетная длина:** Метод работает даже для нечетной длины списка.

**Примеры (псевдокод):**
```
class MyStack:
    function __init__():
       q1 = empty queue
       q2 = empty queue
        top = None
     function push(val):
      add val to q1
       top = val

    function pop():
       if queue q1 is empty:
         return None
       while queue q1 size more than 1
          move head from q1 to q2
       last = head from queue q1
        swap q1 and q2
        return last
    function top()
        return top

    function empty()
        return q1 is empty;
```

**Примеры реализации в Python:**
```python
from collections import deque
class MyStack:

    def __init__(self):
        self.q1 = deque()
        self.q2 = deque()
        self.top = None
    def push(self, x: int) -> None:
        self.q1.append(x)
        self.top = x

    def pop(self) -> int | None:
        if not self.q1:
            return None
        while len(self.q1) > 1:
          self.q2.append(self.q1.popleft())
        last = self.q1.popleft()
        self.q1, self.q2 = self.q2, self.q1
        return last

    def top(self) -> int | None:
        return self.top

    def empty(self) -> bool:
        return not self.q1

myStack = MyStack()
myStack.push(1)
myStack.push(2)
print(f"top: {myStack.top()}") # Выведет: top: 2
print(f"pop: {myStack.pop()}") # Выведет: pop: 2
print(f"empty: {myStack.empty()}") # Выведет: empty: False
print(f"pop: {myStack.pop()}")
print(f"empty: {myStack.empty()}")
```

**Разбор вариантов:**
*   **A. Для реализации стека  можно использовать только один массив, и добавление элемента происходит в конец массива, а удаление с начала.:** Неправильно. Это реализация очереди, а не стека.
*   **B.  Для реализации стека можно использовать два списка, при этом все операции будут происходить только со вторым списком.:** Неправильно,  это не будет соответствовать требованию использования очередей.
*  **C.  Для реализации стека можно использовать две очереди, при этом  новые элементы  добавляются в одну из очередей,  а удаление, показ и проверка на  пустоту происходят через вторую очередь (когда она не пустая).:** Правильно.
*  **D. Для реализации стека нужно использовать только рекурсивный алгоритм.:** Неправильно.

**В результате:**
*  Использование двух очередей позволяет реализовать логику стека.
*   Правильная реализация push/pop и top  позволяет создать рабочую  структуру LIFO.

Таким образом, правильным ответом является **C. Для реализации стека можно использовать две очереди, при этом  новые элементы  добавляются в одну из очередей,  а удаление, показ и проверка на  пустоту происходят через вторую очередь (когда она не пустая).**
