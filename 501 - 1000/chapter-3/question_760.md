### `question_760.md`

**Вопрос 760.** Дан массив целых чисел `nums`. Разработайте алгоритм на Python, который находит и возвращает максимальную сумму, которую можно получить из непрерывного подмассива в массиве `nums`.

*   **Подмассив (subarray)**: непрерывная часть массива.

**Примеры:**
```
Ввод: nums = [-2,1,-3,4,-1,2,1,-5,4]
Вывод: 6
Объяснение: подмассив [4,-1,2,1] имеет наибольшую сумму 6.

Ввод: nums = [5,4,-1,7,8]
Вывод: 23
Объяснение: подмассив [5,4,-1,7,8] имеет наибольшую сумму 23.
```

-  A. Для решения задачи нужно использовать  только алгоритм  полного перебора всех подмассивов и выбирать наибольшую сумму.
-   B. Для решения задачи необходимо использовать  только алгоритм динамического программирования, и составить  таблицу значений, с максимальной суммой.
-   C. Для решения задачи нужно использовать только рекурсивный алгоритм.
-  D. Для решения задачи можно использовать алгоритм Кадане (Kadane), который итеративно  вычисляет максимальную сумму  текущего подмассива и общую максимальную  сумму подмассива.

**Правильный ответ: D**

**Объяснение:**

Для решения задачи поиска максимальной суммы непрерывного подмассива в массиве целых чисел, оптимальным является использование алгоритма Кадане (Kadane's Algorithm). Этот алгоритм позволяет эффективно решить задачу за один проход по массиву, обеспечивая линейную временную сложность O(n).

*   **Алгоритм Кадане (Kadane's Algorithm):**
    1.  **Инициализация:**
         *  Инициализируем `max_so_far` (максимальная сумма  на данный момент) минимально возможным значением  (например `float('-inf')`).
        *  Инициализируем  `max_ending_here` (максимальная сумма текущего подмассива) со значением 0.
    2.  **Перебор массива:**
        *   Перебираем  массив `nums` :
             *  Обновляем `max_ending_here`  суммой  `max_ending_here` и  текущего элемента  `num`.
            *   Если  `max_ending_here`  становится отрицательным, то сбрасываем его в  `0`.
             *  Обновляем `max_so_far` значением  `max(max_so_far, max_ending_here)`.
    3.  **Результат:**  После перебора всех  элементов, возвращаем значение  `max_so_far`.

*   **Преимущества алгоритма:**
    *   **Линейная сложность:**  Имеет временную сложность  `O(n)`, где n - длина массива, так как проход по списку делается один раз.
    *  **Постоянная память:**  Используется только постоянный объем дополнительной памяти, а не динамический массив.
     * **Эффективность:** Избегает пересчетов и отслеживает  максимальные суммы эффективно.

**Примеры (псевдокод):**
```
function find_max_subarray_sum(nums):
  max_so_far = - infinity
  max_ending_here = 0
  for num from nums:
      max_ending_here = max(num , num + max_ending_here)
     max_so_far =  max(max_so_far, max_ending_here)
   return max_so_far
```

**Примеры реализации в Python:**

```python
def maxSubArraySum(nums):
    max_so_far = float('-inf')
    max_ending_here = 0

    for num in nums:
        max_ending_here = max(num, num + max_ending_here)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

nums1 = [-2,1,-3,4,-1,2,1,-5,4]
print(f"Ввод: nums = {nums1}")
print(f"Вывод: {maxSubArraySum(nums1)}") # Выведет: Вывод: 6

nums2 = [5,4,-1,7,8]
print(f"Ввод: nums = {nums2}")
print(f"Вывод: {maxSubArraySum(nums2)}") # Выведет: Вывод: 23

nums3 = [-1,-2,-3]
print(f"Ввод: nums = {nums3}")
print(f"Вывод: {maxSubArraySum(nums3)}") # Выведет: Вывод: -1

```
**Разбор вариантов:**
*   **A. Для решения задачи нужно использовать алгоритм  полного перебора всех подмассивов и выбирать наибольшую сумму.:** Неправильно. Такой метод будет неэффективным и потребует O(n^3) времени.
*   **B. Для решения задачи необходимо использовать только жадный алгоритм, последовательно выбирая наибольшие значения, удовлетворяющие условию.:** Неправильно, жадный алгоритм не подходит для этой задачи.
*    **C. Для решения задачи нужно использовать только рекурсивный алгоритм.:** Неправильно, рекурсия не подходит и имеет сложность O(2^n).
*   **D. Для решения задачи можно использовать алгоритм Кадане (Kadane), который итеративно  вычисляет максимальную сумму  текущего подмассива и общую максимальную  сумму подмассива.:** Правильно.

**В результате:**
*   Алгоритм Кадане  позволяет  найти  максимальную  сумму  подмассива за один проход.
*  Использование  `max_ending_here`  и  `max_so_far` позволяет отслеживать текущую и глобальную максимальные суммы.
*  Алгоритм  избегает повторных вычислений и является очень эффективным.

Таким образом, правильным ответом является **D. Для решения задачи можно использовать алгоритм Кадане (Kadane), который итеративно  вычисляет максимальную сумму  текущего подмассива и общую максимальную  сумму подмассива.**
