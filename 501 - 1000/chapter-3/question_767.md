### `question_712.md`

**Вопрос 712.** Дан массив целых чисел `nums` и целое число `k`. Разработайте алгоритм на Python, который возвращает `True`, если в массиве существуют два уникальных индекса `i` и `j`, для которых выполняются условия:

-   `nums[i] == nums[j]`
-   `abs(i - j) <= k`

В противном случае, верните `False`.

**Примеры:**

```
Ввод: nums = [1,2,3,1], k = 3
Вывод: True
Объяснение: Существуют индексы i=0 и j=3, nums[0] == nums[3]  и abs(0 - 3) <= 3

Ввод: nums = [1,0,1,1], k = 1
Вывод: True
Объяснение: Существуют индексы i=1 и j=2, nums[1] == nums[2]  и abs(1 - 2) <= 1
```
-  A.  Для решения задачи необходимо использовать  двойной цикл, для проверки каждой пары индексов  в массиве.
- B.  Для решения задачи нужно использовать алгоритм сортировки, и после этого проверять все соседние элементы в массиве.
-   C. Для решения задачи нужно использовать  скользящее окно,  для проверки  каждого элемента  на соответсвие условию в  текущем окне.
- D.  Для решения задачи нужно использовать хеш таблицу для  хранения  индекса элемента, и  проверять  на то,  что бы  разница между  текущим индексом и значением  из хеш-таблицы не превышала  значения k.

**Правильный ответ: D**

**Объяснение:**

Для решения задачи поиска дубликатов на расстоянии не более `k`, оптимальным является использование хеш-таблицы (словаря).  Словарь позволит отслеживать индексы элементов и  эффективно проверять  расстояние между дубликатами, обеспечивая  решение за линейное время.

*   **Алгоритм (хеш-таблица):**
    1.  **Инициализация:** Создаем словарь `seen_indices` для хранения  индекса последнего  вхождения каждого элемента.
    2.  **Итерация:**  Проходим по массиву `nums`:
        *   **Проверка на дубликат:**  Проверяем, есть ли текущий элемент `nums[i]`  в словаре `seen_indices`.
             * Если есть, то вычисляем разницу индексов  `abs(i - seen_indices[nums[i]])`.  Если  разница  не больше чем `k`, то  возвращаем `True`.
        * **Обновление индекса:** Если дубликата не найдено или условие не выполнено,  то  обновляем  значение элемента  `seen_indices[nums[i]]`  текущим  индексом `i`.
    3.  **Возврат `False`:**  Если после перебора всех элементов не были найдены подходящие пары, то возвращаем `False`.

*  **Преимущества алгоритма:**
    *   **Линейная сложность:**  Алгоритм имеет временную сложность O(n), так как проходит по массиву  один раз.
    *   **Хеширование:** Хеш-таблица обеспечивает быстрый поиск элементов.
    *   **Простота:**  Код  лаконичный и легко реализуемый.

**Примеры (псевдокод):**
```
function check_duplicates_in_range(nums, k):
    seen_indices =  empty  dictionary() # map to store last seen index of values
    for i from 0 to length(nums) -1:
       if nums[i] is in seen_indices
           if abs(i - seen_indices[nums[i]]) <= k:
                return True
        seen_indices[nums[i]] = i
    return False
```
**Примеры реализации в Python:**

```python
def check_duplicates_in_range(nums, k):
    seen_indices = {} # dictionary for tracking last seen index
    for i, num in enumerate(nums):
        if num in seen_indices:
            if abs(i - seen_indices[num]) <= k:
                return True
        seen_indices[num] = i
    return False

nums1 = [1, 2, 3, 1]
k1 = 3
print(f"Ввод: nums = {nums1}, k = {k1}")
print(f"Вывод: {check_duplicates_in_range(nums1, k1)}")  # Выведет: True

nums2 = [1, 0, 1, 1]
k2 = 1
print(f"Ввод: nums = {nums2}, k = {k2}")
print(f"Вывод: {check_duplicates_in_range(nums2, k2)}")  # Выведет: True
```
**Разбор вариантов:**
*   **A. Для решения задачи необходимо использовать  двойной цикл, для проверки каждой пары индексов  в массиве.:** Неправильно.  Такой алгоритм имеет сложность O(n^2).
*   **B. Для решения задачи нужно использовать алгоритм сортировки, и после этого проверять все соседние элементы в массиве.:** Неправильно. Сортировка не  нужна, и данный  алгоритм  имеет сложность O(n log n).
*   **C. Для решения задачи нужно использовать  скользящее окно,  для проверки  каждого элемента  на соответсвие условию в  текущем окне.:** Неправильно. Хотя скользящее окно и подойдет, но сложность алгоритма с использованием словаря будет лучше.
*    **D. Для решения задачи нужно использовать хеш таблицу для  хранения  индекса элемента, и  проверять  на то,  что бы  разница между  текущим индексом и значением  из хеш-таблицы не превышала  значения k.:** Правильно.

**В результате:**
*   Хеш-таблица (словарь) позволяет  сохранить индекс последнего вхождения элемента.
*   Алгоритм  использует информацию из хеш-таблицы  для быстрой  проверки условия.
*   Алгоритм  имеет  линейную сложность и  оптимален для  поставленной задачи.

Таким образом, правильным ответом является **D. Для решения задачи нужно использовать хеш таблицу для хранения индекса элемента, и проверять  на то,  что бы  разница между  текущим индексом и значением  из хеш-таблицы не превышала  значения k.**
