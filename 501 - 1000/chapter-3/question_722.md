### `question_722.md`

**Вопрос 722.** Дан массив строк `words`, в котором гарантированно есть хотя бы одно слово. Разработайте алгоритм для поиска и возврата самой длинной общей подстроки-префикса (общего начала) для всех строк массива. Если общей подстроки-префикса не существует, вернуть пустую строку `""`.

**Примеры:**

```
Ввод: words = ["дог", "домен", "домра", "доширак"]
Вывод: "до"

Ввод: words = ["документ", "кот", "кум", "ум"]
Вывод: ""
```

- A. Для решения задачи нужно перебрать все возможные префиксы каждого слова и проверить их на соответствие.
- B. Для решения задачи необходимо использовать только циклы и условные операторы и проверять  префиксы по одному.
- C. Для решения задачи нужно использовать метод, который сравнивает символы в словах посимвольно до тех пор, пока либо не найдено различие, либо не достигнут конец одного из слов.
-  D. Для решения задачи необходимо отсортировать все слова по длинне и использовать  самое короткое слово, так как оно потенциально содержит максимальный префикс.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи поиска самого длинного общего префикса в массиве строк, оптимальным будет использование алгоритма, который сравнивает символы строк посимвольно. Такой подход гарантирует проверку минимального количества символов, избегая ненужных сравнений, и обеспечивает корректность результата.

* **Алгоритм (посимвольное сравнение):**
    1. **Пустая строка:** Если массив `words`  пустой, то  возвращаем пустую строку.
    2. **Определение короткого слова:** Берем первый элемент массива как `first_word`.
       *  Если есть пустая строка - возвращаем пустую строку сразу.
    3.  **Посимвольное сравнение:**  Итерируемся по символам `first_word`.
       *   В каждой итерации итерируемся по  остальным словам в массиве `words`:
             *  Если индекс выходит за границы длины другого слова или, символы в этом  индексе не совпадают,  то  возвращаем часть `first_word` до текущего индекса.
         * Если все проверки прошли,  то проверяется следующий символ.
   4.  **Результат:** Возвращаем  подстроку, до тех пор пока все символы совпадают. Если  выход  из итерации произошел в самом начале, то возвращается пустая строка.

*   **Преимущества алгоритма:**
    *   **Эффективность:**  Алгоритм имеет линейную временную сложность  `O(m * n)`, где `n` — длина массива, а `m` длина самой короткой строки в массиве.
    *  **Посимвольное сравнение:**  Позволяет избежать лишних сравнений, за счет проверки символов посимвольно.
    *  **Простота:**  Код просто понять и реализовать.

**Примеры (псевдокод):**
```
function longest_common_prefix(words):
  if length(words) == 0:
      return ""
  first_word = words[0]
  for index from 0 to length(first_word) -1 :
     for other_word in words:
        if index is beyond length of other_word or first_word[index] != other_word[index]
           return  first_word[0,index]

    return first_word
```

**Примеры реализации в Python:**
```python
def longest_common_prefix(words):
    if not words:
        return ""
    first_word = words[0]
    for index, char in enumerate(first_word):
        for other_word in words:
            if index >= len(other_word) or other_word[index] != char:
                return first_word[:index]
    return first_word


words1 = ["дог", "домен", "домра", "доширак"]
print(f"Ввод: words = {words1}")
print(f"Вывод: '{longest_common_prefix(words1)}'") # Выведет: Вывод: 'до'

words2 = ["документ", "кот", "кум", "ум"]
print(f"Ввод: words = {words2}")
print(f"Вывод: '{longest_common_prefix(words2)}'") # Выведет: Вывод: ''

words3 = ["flower","flow","flight"]
print(f"Ввод: words = {words3}")
print(f"Вывод: '{longest_common_prefix(words3)}'") # Выведет: Вывод: 'fl'
```

**Разбор вариантов:**
*  **A. Для решения задачи нужно перебрать все возможные подстроки каждого слова и проверить их на соответствие.:** Неправильно, такой подход является неэффективным.
*  **B. Для решения задачи необходимо использовать только циклы и условные операторы и проверять  префиксы по одному.:** Неправильно.
*   **C. Для решения задачи нужно использовать метод, который сравнивает символы в словах посимвольно до тех пор, пока либо не найдено различие, либо не достигнут конец одного из слов.:** Правильно.
*   **D. Для решения задачи необходимо отсортировать все слова по длинне и использовать  самое короткое слово, так как оно потенциально содержит максимальный префикс.:** Неправильно. Сортировка не нужна.

**В результате:**
*  Посимвольное сравнение позволяет эффективно  находить общий префикс.
*  Алгоритм  просматривает  символы в строке, пока  символы в других строках совпадают и пока не достигнут конец хотя бы одного слова.

Таким образом, правильным ответом является **C. Для решения задачи нужно использовать метод, который сравнивает символы в словах посимвольно до тех пор, пока либо не найдено различие, либо не достигнут конец одного из слов.**
