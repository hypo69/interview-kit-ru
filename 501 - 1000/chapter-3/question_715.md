### `question_715.md`

**Вопрос 715.** Дана 2D-матрица `grid`, представляющая собой коробку с диагональными перегородками, где `1` — это перегородка типа "левый верхний угол -> правый нижний угол", а `-1` — перегородка типа "правый верхний угол -> левый нижний угол". В каждый столбец коробки сверху бросается ровно один мяч. Разработайте алгоритм, который возвращает массив, указывающий, дойдет ли мяч до дна коробки. Результат `1` означает, что мяч достиг дна коробки,  а `-1` - что мяч застрял.

**Примеры:**

```
Ввод: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
Вывод:  [1,-1,-1,-1,-1]

Ввод: grid = [[-1]]
Вывод: [-1]
```

-   A. Для решения задачи можно использовать обход дерева в ширину (BFS), проверяя все возможные пути.
-   B. Для решения задачи нужно использовать только поиск в глубину (DFS),  чтобы получить верный результат.
-   C.  Для решения задачи нужно эмулировать движение каждого шарика по всем ячейкам  матрицы и проверять на столкновение со стеной или достижение конца.
-   D. Для решения задачи можно использовать  жадный  алгоритм с моделированием движения шарика вниз по  каждому столбцу до конца, используя текущие перегородки.

**Правильный ответ: D**

**Объяснение:**

Для решения задачи отслеживания траектории мячей в матрице с перегородками, оптимальным является применение жадного алгоритма с моделированием движения мяча по каждому столбцу. Это позволяет эффективно определить, дойдет ли мяч до дна коробки или застрянет.

*   **Алгоритм (жадный подход):**
    1.  **Итерирование по столбцам:** Перебираем  каждый столбец  матрицы, то есть  начинаем с каждого стартового узла.
    2. **Моделирование движения мяча:**
         *   Инициализируем текущие координаты  `col = i`,  `row=0`, а также переменную  `direction = 1`.
        *   Пока не достигнут низ  матрицы (пока  `row < m`):
              *   Проверяем значение перегородки `grid[row][col]`.
              *  Если  перегородка `1`:
                *  Если возможно (то есть  `col + 1  < n`), то  переходим в  следующею ячейку:  `row++` , `col++`.
                 *   Если не возможно (дошли до правой границы), то заканчиваем проход, устанавливаем результат для i-го мяча как  `-1`, и переходим к следующему мячу.
               *  Если перегородка `-1`:
                 *   Если возможно (то есть  `col - 1  >= 0`), то  переходим в следующею ячейку: `row++` ,  `col--`.
                *  Если не возможно (дошли до левой границы), то заканчиваем проход, устанавливаем результат для i-го мяча как  `-1`, и переходим к следующему мячу.
    3.  **Достижение дна:** Если цикл завершился и  `row` достиг низа, то  устанавливаем результат для i-го мяча как `1`.
    4.  **Возврат результата:** После прохождения всех столбцов, возвращаем результирующий список.

*  **Преимущества алгоритма:**
     *  **Линейная сложность:**  Временная сложность составляет `O(n*m)`.
   *  **Простота:**  Алгоритм легко реализуется и понятен.
     *   **Гарантия результата:**  Алгоритм гарантирует нахождение правильного ответа, так как  имитирует движение мяча от начала до конца.

**Примеры (псевдокод):**
```
function drop_balls(grid):
  n = col_length(grid)
  m = row_length(grid)
  result = new array of n with default 0
  for i from 0 to n:
      col = i
      row = 0
      while row < m :
        if grid[row][col] == 1:
            if col+1 < n:
                col = col+1
            else:
                result[i] = -1
                break # wall

        elif grid[row][col] == -1:
           if col - 1 >= 0 :
                col = col-1
           else:
              result[i] = -1
              break # wall
        row = row +1
       if row == m:
           result[i]=1
    return result
```
**Примеры реализации в Python:**
```python
def drop_balls(grid):
    m = len(grid)
    n = len(grid[0])
    result = [0] * n
    for i in range(n):
        col = i
        row = 0
        while row < m:
            if grid[row][col] == 1:
                if col+1 < n:
                   col = col + 1
                else:
                   result[i] = -1
                   break
            elif grid[row][col] == -1:
                if col - 1 >= 0 :
                   col = col -1
                else:
                   result[i] = -1
                   break
            row+=1
        if row == m:
             result[i] = 1
    return result
grid1 = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
print(f"Ввод: grid = {grid1}")
print(f"Вывод: {drop_balls(grid1)}")  # Выведет Вывод: [1, -1, -1, -1, -1]

grid2 = [[-1]]
print(f"Ввод: grid = {grid2}")
print(f"Вывод: {drop_balls(grid2)}") # Выведет: Вывод: [-1]

grid3 = [[1,-1,1,1,-1],[-1,1,1,-1,-1],[-1,-1,-1,1,-1],[1,1,1,1,1],[-1,1,1,-1,-1]]
print(f"Ввод: grid = {grid3}")
print(f"Вывод: {drop_balls(grid3)}") # Выведет: Вывод: [-1, 1, 1, 1, -1]
```
**Разбор вариантов:**

*   **A. Для решения задачи нужно использовать обход дерева в ширину (BFS), проверяя все возможные пути.:** Неправильно.
*   **B. Для решения задачи нужно использовать только поиск в глубину (DFS),  чтобы получить верный результат.:** Неправильно.
*   **C. Для решения задачи нужно эмулировать движение каждого шарика по всем ячейкам  матрицы и проверять на столкновение со стеной или достижение конца.:** Правильно, хоть и звучит не как общее правило, а как конкретный подход, но он и является правильным.
* **D. Для решения задачи можно использовать  жадный алгоритм с моделированием движения шарика вниз по  каждому столбцу до конца, используя текущие перегородки.:** Правильно, но является другим описанием правильного алгоритма.

**В результате:**
*  Алгоритм последовательно имитирует движение мячика от верха до низа, с учетом перегородок.
*  Позволяет понять застрянет ли мячик или нет и  задает результат.
*  Решение имеет линейную сложность, и  потребляет немного памяти.

Таким образом, правильным ответом является **C. Для решения задачи нужно эмулировать движение каждого шарика по всем ячейкам  матрицы и проверять на столкновение со стеной или достижение конца.**
