### `question_768.md`

**Вопрос 768.** Разработайте функцию на Python `apply_gravity`, которая моделирует гравитационное воздействие на двумерный массив NumPy, представляющий кучу песка.

*   Каждый элемент массива представляет собой целое число, отражающее высоту кучи песка.
*   Любая "куча", содержащая 4 или более частиц песка, разрушается: 4 частицы вычитаются из кучи и распределяются между ее соседями (сверху, снизу, слева, справа).
* Функция должна изменять исходный массив NumPy, и ничего не возвращать.

**Примеры:**

```python
import numpy as np

# Пример 1
grid1 = np.array([[3, 3, 3], [3, 3, 3], [3, 3, 3]])
apply_gravity(grid1)
print(grid1)

# Вывод после применения гравитации:
# [[3 3 3]
# [3 3 3]
# [3 3 3]]

# Пример 2
grid2 = np.array([[4, 4, 4], [4, 4, 4], [4, 4, 4]])
apply_gravity(grid2)
print(grid2)

# Вывод после применения гравитации:
# [[5 4 5]
# [4 0 4]
# [5 4 5]]

# Пример 3
grid3 = np.array([[5,1,1],[0,0,0],[2,1,5]])
apply_gravity(grid3)
print(grid3)
# Вывод
#[[ 5  2  1]
# [ 1  1  0]
# [ 2  1  5]]
```

- A.  Для решения задачи нужно  применять  жадный алгоритм, перебирая каждую ячейку матрицы и перераспределяя излишний песок, но не учитывая повторные  разрушения.
-  B. Для решения задачи  необходимо  использовать рекурсивный алгоритм  и на каждом шаге спускаться вглубь от  ячеек со значением больше 4.
- C. Для решения задачи, нужно  использовать   алгоритм с временной сложностью O(n*m)  и  использовать  итеративный подход с использованием копии матрицы, что позволит  повторять перераспределение, пока  ни одна из клеток не станет больше 4.
-   D.  Для решения задачи необходимо отсортировать матрицу, а потом  распределять  песок.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи моделирования гравитации и распределения песка в двумерном массиве NumPy, оптимальным является использование итеративного алгоритма, который моделирует процесс "разрушения" и перераспределения песка. Алгоритм будет  повторяться, до тех пор пока ни одна из кучек не будет содержать более чем 4 частицы, в противном случае будет происходит бесконечная итерация.  При этом необходимо  использовать копию матрицы,  чтобы избежать проблем во время итерации, когда в одном цикле нужно обновлять значения в матрице, которую проходим.

*   **Алгоритм (итеративный с использованием копии матрицы):**
    1.  **Инициализация:** Создаем  копию  исходной  матрицы  `new_grid`.
    2.  **Цикл:**  Проходим  по всем ячейкам `grid`,  пока  хотя бы  одна из ячеек больше или равна `4`:
           *    Создаем  новую матрицу, где  будем  сохранять значения  результата обработки текущей итерации.
        *   **Обработка ячеек:**   Перебираем  каждую ячейку:
                 * Если  значение ячейки больше или равно  `4` , то  вычитаем `4`  из ее значения, и добавляем +1 соседним ячейкам,  сверху, снизу,  слева и  справа  (если они находятся в пределах массива).
                  *  Если значение ячейки меньше 4, то просто копируем ее в новую матрицу.
          * Переопределяем `grid = new_grid` (результат текущей итерации становится исходным состоянием для следующей)
   3.  **Результат:** После завершения  цикла  матрица  `grid`  содержит итоговые  значения после применения  гравитации.

*   **Преимущества алгоритма:**
    *   **Линейная сложность:** Алгоритм имеет временную сложность  `O(n*m*k)`,  где `n` и `m`  размеры матрицы, а `k` - количество необходимых итераций для того, чтобы значения всех ячеек были меньше 4, что будет зависеть от начальных значений.
    *  **Правильное распространение:**  Алгоритм правильно моделирует распространение  частиц песка  на  соседние  ячейки, даже если есть несколько таких ячеек.
    *   **Простота:** Понятный  алгоритм.

**Примеры (псевдокод):**
```
function apply_gravity(grid):
   while exist values in matrix  >= 4:
     new_grid = copy of grid
     for row from 0 to row length:
          for col from 0 to col length:
             if grid[row][col] >= 4:
                new_grid[row][col]-=4
                add 1 to top cell, if available
                 add 1 to bottom cell, if available
                 add 1 to left cell if available
                add 1 to right cell if available
             else
               new_grid[row][col] = grid[row][col]

      grid = new_grid
   return;
```
**Примеры реализации в Python:**

```python
import numpy as np

def apply_gravity(grid):
  while True:
    new_grid = np.copy(grid)
    changed = False
    for row in range(len(grid)):
        for col in range(len(grid[0])):
             if grid[row][col] >= 4:
                new_grid[row][col] -= 4
                if row - 1 >= 0:
                   new_grid[row-1][col]+=1
                if row + 1 < len(grid):
                    new_grid[row+1][col]+=1
                if col - 1 >= 0:
                    new_grid[row][col-1]+=1
                if col + 1 < len(grid[0]):
                    new_grid[row][col+1]+=1
                changed = True
    grid[:] = new_grid
    if not changed:
        break

grid1 = np.array([[3, 3, 3], [3, 3, 3], [3, 3, 3]])
apply_gravity(grid1)
print(f"Ввод: grid = {[3, 3, 3], [3, 3, 3], [3, 3, 3]}")
print(f"Вывод:\n{grid1}") # Вывод: [[3 3 3] [3 3 3] [3 3 3]]

grid2 = np.array([[4, 4, 4], [4, 4, 4], [4, 4, 4]])
apply_gravity(grid2)
print(f"Ввод: grid = {[4, 4, 4], [4, 4, 4], [4, 4, 4]}")
print(f"Вывод:\n{grid2}") # Вывод:  [[5 4 5] [4 0 4] [5 4 5]]

grid3 = np.array([[5,1,1],[0,0,0],[2,1,5]])
apply_gravity(grid3)
print(f"Ввод: grid = {[5,1,1],[0,0,0],[2,1,5]}")
print(f"Вывод:\n{grid3}") # Вывод: [[ 5  2  1] [ 1  1  0] [ 2  1  5]]

```
**Разбор вариантов:**
*   **A. Для решения задачи нужно  применять  жадный алгоритм, перебирая каждую ячейку матрицы и перераспределяя излишний песок, но не учитывая повторные  разрушения.:** Неправильно,  такой подход не гарантирует правильный результат.
*  **B. Для решения задачи  необходимо  использовать рекурсивный алгоритм  и на каждом шаге спускаться вглубь от  ячеек со значением больше 4.:** Неправильно. Рекурсия не гарантирует достижения нужного результата и может привести к StackOverflowError.
*   **C. Для решения задачи, нужно  использовать   алгоритм с временной сложностью O(n*m)  и  использовать  итеративный подход с использованием копии матрицы, что позволит  повторять перераспределение, пока  ни одна из клеток не станет больше 4.:** Правильно.
*  **D. Для решения задачи необходимо отсортировать матрицу, а потом  распределять  песок.:** Неправильно.  Сортировка не нужна.

**В результате:**
*  Алгоритм  итерирует  пока не будет достигнуто стабильное состояние.
*   Используется  копия матрицы, чтобы избежать  одновременного чтения и изменения в одном цикле.
*   Позволяет  эффективно моделировать  процесс гравитационного перемещения и перераспределение песка.

Таким образом, правильным ответом является **C. Для решения задачи, нужно  использовать   алгоритм с временной сложностью O(n*m)  и  использовать  итеративный подход с использованием копии матрицы, что позволит  повторять перераспределение, пока  ни одна из клеток не станет больше 4.**
