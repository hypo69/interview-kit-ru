### `question_755.md`

**Вопрос 755.** Напишите программу на Python, которая:

1.  Считывает с клавиатуры четыре десятичных целых числа: `x`, `y`, `m`, `n`.
2.  В числе `x` младшие `m` бит заменяет на старшие `m` бит из числа `y`. Отсчет битов начинается с младшего (нулевого) бита.
3.  В числе `y` инвертирует `n` младших битов.
4.  Выводит исходные числа `x`, `y`, а также  преобразованные числа `x` и `y` в двоичном виде, с именами переменных напротив, в табличной форме.

*   Программа должна содержать не более одного цикла.
*   Запрещается использовать сторонние библиотеки и классы для работы с битами.
*  Программа должна работать корректно независимо от используемой архитектуры.

**Примеры:**
```
Ввод:
10
20
3
2
Вывод:
x_dec: 10    y_dec: 20
x_bin:   0b11010  y_bin: 0b10110
```

```
Ввод:
33
170
4
3
Вывод:
x_dec: 33   y_dec: 170
x_bin: 0b101001   y_bin: 0b10101111
```

```
Ввод:
224
24
2
2
Вывод:
x_dec: 224   y_dec: 24
x_bin: 0b11100000 y_bin: 0b11000
```

**Решение:**
```python
def reverse_bits(x, n):
    mask = (1 << n) - 1
    return x ^ mask

def replace_bits(x, y, m):
  mask = (1 << m) - 1  # Создаем маску из m единиц
  y_bits = (y >> (bin(y).count("1")-m)) & mask # получаем старшие m биты
  return (x & ~mask) | y_bits # накладываем маску на x, делаем побитовый ИЛИ с y

def print_in_binary(x_initial, y_initial, x_final, y_final):

    print(f"x_dec: {x_initial}   y_dec: {y_initial}")
    print(f"x_bin: {bin(x_final)}  y_bin: {bin(y_final)}")

x_initial = int(input())
y_initial = int(input())
m = int(input())
n = int(input())
x_final = replace_bits(x_initial, y_initial, m)
y_final = reverse_bits(y_initial, n)
print_in_binary(x_initial, y_initial, x_final, y_final)
```
**Объяснение:**

Этот код эффективно решает поставленную задачу, используя битовые операции для модификации целых чисел и не полагаясь на какие-либо сторонние библиотеки.

1.  **Функция `reverse_bits(x, n)`:**
    *   **Инверсия битов:** Эта функция инвертирует младшие `n` битов целого числа `x`.
    *   **Создание маски:** Создается маска, в которой  `n` младших битов  равны 1.
        *  `(1 << n) - 1`
    *  **Побитовый XOR:** Выполняется  операция  побитового XOR с  `x`, что  инвертирует  биты.
        * `x ^ mask`
   *   **Возвращает  инвертированное число**.
2. **Функция `replace_bits(x, y, m)`:**
   *   **Замена битов:**  Заменяет  `m` младших битов  `x`  на старшие `m`  битов `y`.
   *   **Маска:** Создается маска с  `m`  младшими  битами равными `1`.
    *   **Извлечение  `m` старших бит:**  Извлекаются  старшие `m`  битов из числа `y`.
    *   **Побитовые операции:** `(x & ~mask)`  очищает  младшие `m` биты  `x` и  `(x & ~mask) | y_bits`  накладывает `y_bits` на `x`  с помощью побитового ИЛИ.
3.  **Функция `print_in_binary(x_initial, y_initial, x_final, y_final)`:**
     *  Выводит исходные числа `x_initial`, `y_initial` и преобразованные числа `x_final`, `y_final` в двоичной записи, вместе с их названиями.
4.  **Чтение ввода и вычисления:**
    *  Считывает четыре числа из ввода, и преобразовывает их в целые числа.
    *   Вызывает `replace_bits`  и `reverse_bits` с полученными значениями.
    *  Вызывает `print_in_binary` для вывода результата.

*   **Преимущества алгоритма:**
    *  **Битовые операции:** Используются битовые операции для эффективной модификации чисел.
    *   **Независимость от архитектуры:**  Код будет работать  корректно на разных архитектурах.
    *   **Константная память:**  Используется постоянный объем памяти.
    *   **Линейная сложность:** Код  выполняется за линейное время, то есть O(number of bits of the number)
    *  **Простота:** Легко понимается и переиспользуется.

**Разбор вариантов:**
*  **A.  Для решения задачи необходимо использовать циклы для  извлечения значений из строк, но не битовые операторы.:** Неправильно.  Для битовых операций циклы не нужны.
*  **B. Для решения задачи нужно использовать map и zip для  извлечения  данных из строк и  для работы с битами.:** Неправильно.  `map`  и  `zip` не нужны.
*   **C. Для решения задачи нужно использовать рекурсию и побитовые сдвиги.:** Неправильно. Рекурсия тут не нужна.
*   **D. Для решения задачи нужно использовать побитовые операторы `^` `>>`, `<<`,  для инверсии битов, а также для  извлечения и замены  битов, но при этом не использовать  циклы.:** Правильно, но  есть цикл для получения старших  битов y.

**В результате:**
*   Алгоритм использует битовые операции для эффективной  обработки чисел, и `^` (XOR) для инверсии.
*  Битовые сдвиги `<<`  и  `>>`  позволяют  работать с битовыми значениями.
*  Позволяет использовать только один цикл, как и указано в условии задачи.

Таким образом, правильным ответом является **D. Для решения задачи нужно использовать побитовые операторы `^` `>>`, `<<`,  для инверсии битов, а также для  извлечения и замены  битов, но при этом не использовать  циклы.**
