### `question_721.md`

**Вопрос 721.** Дан массив бинарных чисел `nums` (состоящий из 0 и 1), и целое число `k`, обозначающее максимальное количество нулей, которые можно заменить на единицы. Разработайте алгоритм для нахождения максимальной длины подпоследовательности единиц в `nums` после замены не более `k` нулей на единицы.

**Пример:**
```
Ввод: nums = [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1], k = 3
Вывод: 10
```

-   A. Для решения этой задачи нужно использовать рекурсивный алгоритм  и пробовать все комбинации замены нулей, запоминая  максимальный  результат.
-   B. Для решения этой задачи, необходимо использовать жадный алгоритм,  где сначала будут заменены все левые нули.
-  C.  Для решения задачи необходимо использовать метод  двух указателей (скользящего окна), который отслеживает количество нулей в  окне,  при этом  гарантируя  максимальную длину.
-   D. Для решения задачи нужно сначала отсортировать массив и получить его длину.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи нахождения максимальной длины подпоследовательности единиц с заменой `k` нулей, оптимальным подходом является использование метода скользящего окна (sliding window) с двумя указателями. Этот метод позволяет эффективно отслеживать количество нулей в текущем окне и находить максимальную длину.

*   **Алгоритм (скользящее окно):**
    1.  **Инициализация:**
         *  `left` - Указатель на левую границу окна.
        *   `right` - Указатель на правую границу окна.
         * `max1`  - Текущая максимальная длина последовательности.
        *   `zeros` - текущее количество нулей в  окне.
    2.  **Передвижение правой границы:** Пока `right` не достигнет конца массива:
          *   Если `nums[right]` равно 0, увеличиваем `zeros` на 1.
        *   **Сокращение окна:** Пока `zeros` больше `k`, удаляем  элементы с левой границы окна  (т.е. двигаем `left` в право).
               * Если элемент,  на который указывает `left`  был равен 0, то  уменьшаем `zeros` на `1`.
        *  **Вычисление максимума:** На каждом шаге вычисляем  максимальную длину последовательности, как `right - left + 1`, и сохраняем её.
         *  Двигаем правую границу окна  `right` вправо на 1.
    3. **Результат:**  Возвращаем максимальную длину последовательности.

*   **Преимущества алгоритма:**
    *   **Линейная сложность:** Алгоритм обходит массив один раз, что обеспечивает временную сложность O(n).
    *  **Эффективность:**  Метод скользящего окна  позволяет не перебирать лишние подпоследовательности.
    *  **Постоянная память:**   Использует  постоянный объем дополнительной памяти.

**Примеры (псевдокод):**
```
function max_ones(nums, k):
   left = 0
    right = 0
    max1 = 0
    zeros = 0
    while right < length(nums):
        if nums[right] == 0:
          zeros +=1
        while zeros > k:
            if nums[left] == 0:
                zeros -=1
            left += 1

        max1 = max(max1, right - left + 1)
        right+=1
    return max1
```

**Примеры реализации в Python:**
```python
def max_ones(nums, k):
    left = right = max1 = zeros = 0
    while right < len(nums):
        if nums[right] == 0:
            zeros += 1
        while zeros > k:
            if nums[left] == 0:
                zeros -= 1
            left += 1
        max1 = max(max1, right - left + 1)
        right += 1
    return max1

nums1 = [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1]
k1 = 3
print(f"Ввод: nums = {nums1}, k = {k1}")
print(f"Вывод: {max_ones(nums1,k1)}") # Выведет: 10

nums2 = [1,1,1,1,1,1,1]
k2 = 0
print(f"Ввод: nums = {nums2}, k = {k2}")
print(f"Вывод: {max_ones(nums2,k2)}")  # Выведет: 7
```
**Разбор вариантов:**
*   **A. Для решения этой задачи нужно использовать рекурсивный алгоритм  и пробовать все комбинации замены нулей, запоминая  максимальный  результат.:** Неправильно. Рекурсивные алгоритмы требуют больше памяти и не оптимальны.
*  **B. Для решения этой задачи, необходимо использовать жадный алгоритм,  где сначала будут заменены все левые нули.:** Неправильно. Такой алгоритм не гарантирует правильного результата.
*   **C.  Для решения этой задачи необходимо использовать метод  двух указателей (скользящего окна), который отслеживает количество нулей в  окне,  при этом  гарантируя  максимальную длину.:** Правильно.
*   **D. Для решения этой задачи нужно сначала отсортировать массив и получить его длину.:** Неправильно. Сортировка не нужна.

**В результате:**
*  Метод скользящего окна позволяет эффективно решить данную задачу.
*  Алгоритм  поддерживает окно определенной длины и итерируется по массиву только один раз.
*  Алгоритм является простым и эффективным для  нахождения максимальной подпоследовательности единиц.

Таким образом, правильным ответом является **C. 
Для решения этой задачи необходимо использовать метод  двух указателей (скользящего окна), 
который отслеживает количество нулей в  окне,  при этом  гарантируя  максимальную длину.**
