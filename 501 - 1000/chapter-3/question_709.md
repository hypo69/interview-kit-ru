### `question_709.md`

**Вопрос 709.** Дан указатель на начало отсортированного связного списка. Разработайте алгоритм, который удаляет все узлы, содержащие дублирующиеся значения, так что в результате остается только список уникальных элементов, отсортированный по возрастанию.

**Примеры:**

```
Ввод: head = [1,2,3,3,4,4,5]
Вывод: [1,2,5]

Ввод: head = [1,1,1,2,3]
Вывод: [2,3]
```

-   A. Для решения задачи нужно использовать рекурсию и возвращать новый отсортированный список без дубликатов.
-   B.  Для решения задачи нужно использовать только стек и  динамически добавлять и удалять значения в стек, пока не получим все уникальные.
-   C.  Для решения задачи можно использовать итеративный подход с двумя указателями, чтобы отслеживать текущий узел и удалять  дублирующиеся узлы.
-   D.  Для решения задачи нужно сначала отсортировать список а потом удалить дубликаты, это гарантирует результат.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи удаления дубликатов из отсортированного связного списка наиболее эффективным является использование итеративного подхода с двумя указателями, который позволит изменять существующий список, а не создавать новый. Этот алгоритм использует свойство того, что список отсортирован.

*   **Алгоритм (итеративный с двумя указателями):**
    1. **Проверка пустого списка:**  Если список пуст, то выходим из алгоритма, и возвращаем  `None`.
    2.  **Инициализация:** Создаем указатель `current`, который указывает на начало списка, и  `prev`  который указывает на предыдущий обьект.
    3. **Итерация:** Перебираем список и сравниваем значение текущего узла  `current.next`  с  значением  `current`
      * **Проверка дубликатов:**  Если  значение  `current.next` равно `current`, то значит  это дубликат. В  этом случае  удаляем текущий узел  `current.next` и *не продвигаем  `current`*.
      * **Переход к следующему элементу:**  Если дубликатов нет, то `current` переходит к следующему узлу.
    4. **Проверка первого элемента (необходима):** Если `head` все еще дублируется с последующим узлом, то нужно обновить `head`.
  5. **Возврат результата:**  Возвращаем начало  отсортированного списка без дубликатов.

* **Преимущества алгоритма:**
    *   **Линейная сложность:** Алгоритм обходит список один раз, поэтому временная сложность равна O(n).
    *   **Постоянная память:**   Алгоритм не использует дополнительную память O(1), так как он модифицирует исходный список на месте.
    *  **Простота:** Легко реализуемый алгоритм.

**Примеры (псевдокод):**

```
function remove_duplicates_sorted_linked_list(head):
    if head is null
         return null;
    current = head;
    prev = null
    while current.next != null:
      if current.val == current.next.val:
        current.next = current.next.next
      else:
       prev = current;
       current= current.next;

    if head is not null:
       if head.val == head.next.val:
           head = head.next

     return head;
```
**Примеры реализации в Python:**

```python
#  Реализация ListNode для связного списка
class ListNode:
   def __init__(self, val=0, next=None):
     self.val = val
     self.next = next

def remove_duplicates_sorted_linked_list(head):
    if not head:
        return None
    current = head
    while current.next:
        if current.val == current.next.val:
            current.next = current.next.next
        else:
           current = current.next

    if head and head.next:
        if head.val == head.next.val:
           head = head.next
    return head

# helper method for print linked list
def print_linked_list(head):
    res = []
    while head:
        res.append(head.val)
        head = head.next
    print(res)

list1 = ListNode(1, ListNode(2, ListNode(3, ListNode(3, ListNode(4, ListNode(4, ListNode(5)))))))
print("Ввод: list1 = [1,2,3,3,4,4,5]")
print("Вывод: ")
print_linked_list(remove_duplicates_sorted_linked_list(list1))# [1, 2, 5]

list2 = ListNode(1, ListNode(1, ListNode(1, ListNode(2, ListNode(3)))))
print("Ввод: list2 = [1,1,1,2,3]")
print("Вывод: ")
print_linked_list(remove_duplicates_sorted_linked_list(list2)) #[2, 3]
```
**Разбор вариантов:**
*  **A. Для решения задачи нужно использовать рекурсию и возвращать новый отсортированный список без дубликатов.:** Неправильно. Итеративный способ, описанный выше, более оптимальный.
*   **B.  Для решения задачи нужно использовать только стек и  динамически добавлять и удалять значения в стек, пока не получим все уникальные.:** Неправильно, такой метод сложнее и не позволит эффективно обходить список.
*   **C. Для решения задачи можно использовать итеративный подход с двумя указателями, чтобы отслеживать текущий узел и удалять  дублирующиеся узлы.:** Правильно.
*   **D. Для решения задачи нужно сначала отсортировать список а потом удалить дубликаты, это гарантирует результат.:** Неправильно, список уже отсортирован.

**В результате:**
*  Использование двух указателей,  позволяет эффективно удалять дубликаты из списка  со сложностью O(n).
*  При удалении дубликатов происходит проверка на то, не является ли голова списка дубликатом.

Таким образом, правильным ответом является **C. Для решения задачи можно использовать итеративный подход с двумя указателями, чтобы отслеживать текущий узел и удалять  дублирующиеся узлы.**
