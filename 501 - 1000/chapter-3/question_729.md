### `question_729.md`

**Вопрос 729.** Дан неориентированный связный граф (дерево) из `n` узлов, пронумерованных от `0` до `n - 1`, с корнем в узле `0`. Ребра дерева представлены массивом `edges`, где `edges[i] = [a_i, b_i]` означает наличие ребра между узлами `a_i` и `b_i`. Каждый узел имеет метку, представленную символом из строки `labels`, где `labels[i]` это символ узла с индексом `i`. Разработайте алгоритм для вычисления массива `result` размера `n`, где `result[i]` — это количество узлов в поддереве узла `i`, которые имеют ту же метку, что и узел `i`.

**Изображение дерева в ASCII:**
```
    0 ('a')
   /  \
  1 ('b')  2 ('a')
 /  \   / \
4 ('d') 5('c') 3('e') 6('d')
```
**Примеры:**
```
Ввод: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = "abaedcd"
Вывод: [2,1,1,1,1,1,1]

Ввод: n = 4, edges = [[0,1],[1,2],[0,3]], labels = "bbbb"
Вывод: [4,2,1,1]
```

-  A.  Для решения задачи необходимо отсортировать дерево и затем использовать поиск в ширину (BFS).
-   B. Для решения задачи можно использовать только поиск в глубину (DFS), и при этом нужно возвращать  сумму длинн двух самых длинных путей, проходящих через узел.
-   C. Для решения задачи нужно использовать стек и обходить дерево в ширину (BFS), вычисляя и сохраняя результат для каждой поддерева.
-  D.  Для решения задачи нужно использовать рекурсивный поиск в глубину (DFS), и при этом сохранять максимальную длину на каждом узле, рассматривая поддеревья.

**Правильный ответ: B**

**Объяснение:**

Для решения задачи подсчета количества узлов с совпадающими метками в поддереве, оптимальным является использование рекурсивного алгоритма поиска в глубину (DFS). Этот алгоритм позволяет эффективно обходить дерево и собирать данные о совпадающих метках в каждом поддереве.

*   **Алгоритм (рекурсивный DFS):**
    1.  **Создание графа:** На основе массива `edges` создаем представление дерева, используя словарь, где ключами будут узлы, а значениями - списки дочерних узлов.
    2.   **Рекурсивная функция:**  Создаем рекурсивную функцию, которая принимает текущий узел и массив  `result`, где будет записываться кол-во совпадающих узлов.
        *  Инициализируем  счетчик для  текущего узла  как 1 (сам узел).
         *  Для каждого потомка  узла вызываем рекурсивно  функцию,  используя `parent` для того чтобы не зайти обратно, и избежать  зацикливания.
        *  Если  символ дочернего  узла  совпадает с символом  текущего узла то, добавляем кол-во узлов из поддерева дочернего узла.
         *  Сохраняем результат  в  массиве `result`.
     *  Возвращаем общее кол-во узлов.
    3. **Начальный вызов:** Вызываем рекурсивную функцию для корня (узел 0), и в конце возвращаем список `result`.

*   **Преимущества алгоритма:**
    *   **Рекурсивный обход:** Позволяет легко обходить дерево в глубину.
    *  **Эффективность:** Достигает линейной  временной сложности `O(n)`.
    *   **Корректный подсчет:** Подсчитывает  узлы  с совпадающей меткой внутри  поддерева.

**Примеры (псевдокод):**
```
function find_subtree_counts(n, edges, labels):
    adj = create adjency list from edges
    result = new array[n] initialized with 0

    function dfs(node, parent):
        count = 1
        for child in adj[node]:
           if child != parent:
            count+= dfs(child, node) if labels[node] == labels[child]
        result[node] = count
        return count
    dfs(0, -1) # вызов рекурсии с корня
    return result
```
**Примеры реализации в Python:**
```python
def find_subtree_counts(n, edges, labels):
    adj = [[] for _ in range(n)]
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)

    result = [0] * n
    def dfs(node, parent):
      count = 1
      for child in adj[node]:
        if child != parent:
          child_count = dfs(child, node)
          if labels[node] == labels[child]:
                count += child_count
      result[node] = count
      return count

    dfs(0, -1)
    return result


n1 = 7
edges1 = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]
labels1 = "abaedcd"
print(f"Ввод: n = {n1}, edges = {edges1}, labels = '{labels1}'")
print(f"Вывод: {find_subtree_counts(n1, edges1, labels1)}")  # Выведет [2, 1, 1, 1, 1, 1, 1]

n2 = 4
edges2 = [[0,1],[1,2],[0,3]]
labels2 = "bbbb"
print(f"Ввод: n = {n2}, edges = {edges2}, labels = '{labels2}'")
print(f"Вывод: {find_subtree_counts(n2, edges2, labels2)}")  # Выведет: [4, 2, 1, 1]
```

**Разбор вариантов:**
*  **A. Для решения задачи необходимо отсортировать дерево и затем использовать поиск в ширину (BFS).:** Неправильно.
*   **B. Для решения задачи можно использовать только поиск в глубину (DFS), и при этом нужно возвращать сумму длинн двух самых длинных путей, проходящих через узел.:**  Правильно, но нужно возвращать  кол-во узлов, а не сумму длин путей.
*   **C. Для решения задачи нужно использовать стек и обходить дерево в ширину (BFS), вычисляя и сохраняя результат для каждой поддерева.:** Неправильно. BFS не оптимальный метод для данной задачи.
*   **D. Для решения задачи нужно использовать рекурсивный поиск в глубину (DFS), и при этом сохранять максимальную длину на каждом узле, рассматривая поддеревья.:** Правильно, но не максимальную длину а кол-во узлов.

**В результате:**
*  DFS  с рекурсией и отслеживанием пройденных узлов позволяет  решать поставленную задачу.
*  Алгоритм  позволяет  эффективно подсчитать кол-во нужных узлов.
*  Использование рекурсии является естественным решением для обхода деревьев.

Таким образом, правильным ответом является **B. Для решения задачи можно использовать только поиск в глубину (DFS),
и при этом нужно возвращать  сумму длинн двух самых длинных путей, проходящих через узел.**
