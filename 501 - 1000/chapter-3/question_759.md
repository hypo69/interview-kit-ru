### `question_759.md`

**Вопрос 759.** Дан массив строк `words`, где каждый элемент представляет собой строку из двух букв английского алфавита в нижнем регистре. Разработайте алгоритм на Python, который находит и возвращает максимальную длину палиндрома, который можно сформировать, выбирая подмножество строк из `words` и конкатенируя их в произвольном порядке. Каждую строку можно использовать не более одного раза.

*   **Палиндром:** Строка, которая читается одинаково в обоих направлениях (слева направо и справа налево).

**Примеры:**

```
Ввод: words = ["lc","cl","gg"]
Вывод: 6
Объяснение: Можно составить палиндром "lc" + "gg" + "cl" = "lcggcl" или "clgglc", имеющие длину 6.

Ввод: words = ["ab","ty","yt","lc","cl","ab"]
Вывод: 8
Объяснение: "ty" + "lc" + "cl" + "yt" +  "ab" +  "ba" = "tylcclyt" или "lcyttycl" и т.д,  но если выбрать "ab", то  еще есть  другой "ab", которое может испортить результат.

Ввод: words = ["cc","ll","xx"]
Вывод: 2
Объяснение: Можно выбрать только одно  слово из палиндромов "cc", "ll" или "xx".
```

-   A. Для решения задачи необходимо использовать только жадный алгоритм, выбирая  на каждой итерации самое длинное палиндромное слово, и все остальные слова из обратной пары.
-  B. Для решения задачи нужно использовать  рекурсивный алгоритм,  и последовательно перебирать слова и проверять на палиндромность, и потом суммировать длины.
-  C.  Для решения задачи нужно использовать  словарь (хеш-таблицу) для подсчета  встречающихся пар и  сформировать результирующую длину, а также использовать специальную логику для  обработки палиндромных слов.
-   D.  Для решения задачи нужно сначала отсортировать массив, а затем составить строку  в обратном порядке.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи поиска максимальной длины палиндрома, составленного из заданного массива строк, оптимальным подходом является использование хеш-таблицы (словаря) для подсчета частоты встречающихся строк и их инверсий.  Такой подход  позволяет эффективно обрабатывать пары строк,  которые могут образовывать палиндром, а  также  обрабатывать одиночные палиндромные строки.

*   **Алгоритм (хеш-таблица с  подсчетом пар):**
    1.  **Подсчет частоты строк:**
        *   Создаем словарь  `counts`, где ключ - это слово, а значение - сколько раз оно встречается.
        *   Итерируемся по списку `words`, и  считаем  количество  слов.
    2.  **Создание палиндрома:**
        *  Инициализируем переменную `length` равную `0`.
      *  Итерируем  по ключам словаря `counts`:
          *  Если ключ (слово)  палиндром ( т.е. `word == word[::-1]`),  то:
                * Если кол-во  слов является четным, то  увеличиваем `length` на  `len(word)* кол-во`.
                *  Если кол-во  слов является нечетным, то увеличиваем  `length` на  `len(word)*(кол-во-1)`, и запоминаем факт что мы использовали  палиндром (переменную  `central_palindrom` устанавливаем в `True`).
          * Если ключ не палиндром:
              * Находим слово-дубликат с обратным  порядком символов `reversed_word` в словаре, и проверяем, есть ли такое  слово.
             *   Если такое слово существует, то  увеличиваем `length` на `len(word)* (минимальное кол-во слов  `word` и `reversed_word`)`, и обнуляем  эти значения в словаре.
        * Если  есть  не использованный палиндром (т.е  `central_palindrom` равно `True`), то добавляем  длину  палиндрома  `len(word)`.
     3.  **Возврат результата:**  После обработки всех слов,  возвращаем  `length`.

*  **Преимущества алгоритма:**
    *   **Эффективность:** Использует  хеш таблицу, что обеспечивает быстроту поиска,  и не требует  дополнительной  сортировки.
    *  **Линейная сложность:**  Имеет  временную сложность `O(n)`, где  n -  длинна массива строк `words`.
    *   **Корректность:**  Обеспечивает правильный подсчет максимальной длины палиндрома с учетом  всех условий.

**Примеры (псевдокод):**

```
function max_palindrome_length(words):
    counts = dictionary of words and their counts
    for word in words:
        add word to counts or increment by 1
    length = 0;
    central_palindrome = False
     for word in counts
        if word == word[::-1] # palindrome
           if counts[word] % 2 == 0:
                length += length(word) * count
            else:
                length += length(word) * (count-1)
                central_palindrome = True

         if reversed_word exists in counts
            length += length(word) * min( counts[word], counts[reversed_word])
           counts[word]=0
            counts[reversed_word] = 0
       if central_palindrome
         length+=2

     return length
```
**Примеры реализации в Python:**

```python
from collections import Counter

def max_palindrome_length(words):
    counts = Counter(words)
    length = 0
    central_palindrome = False
    for word in counts:
        if word == word[::-1]:
            if counts[word] % 2 == 0:
                length += len(word) * counts[word]
            else:
                length += len(word) * (counts[word] - 1)
                central_palindrome = True
        else:
            reversed_word = word[::-1]
            if reversed_word in counts:
              length += len(word) * min(counts[word], counts[reversed_word])
              counts[word] = 0
              counts[reversed_word] = 0

    if central_palindrome:
        for word in counts:
           if counts[word] > 0 and word == word[::-1]:
            length+=len(word)
            break

    return length

words1 = ["lc", "cl", "gg"]
print(f"Ввод: words = {words1}")
print(f"Вывод: {max_palindrome_length(words1)}") # Выведет: Вывод: 6

words2 = ["ab","ty","yt","lc","cl","ab"]
print(f"Ввод: words = {words2}")
print(f"Вывод: {max_palindrome_length(words2)}") # Выведет: Вывод: 8

words3 = ["cc","ll","xx"]
print(f"Ввод: words = {words3}")
print(f"Вывод: {max_palindrome_length(words3)}") # Выведет: Вывод: 2
```

**Разбор вариантов:**

*   **A. Для решения задачи необходимо использовать только жадный алгоритм, выбирая  на каждой итерации самое длинное палиндромное слово, и все остальные слова из обратной пары.:** Неправильно.
*   **B. Для решения задачи нужно использовать  рекурсивный алгоритм,  и последовательно перебирать слова и проверять на палиндромность, и потом суммировать длины.:** Неправильно.
*   **C. Для решения задачи нужно использовать  словарь (хеш-таблицу) для подсчета  встречающихся пар и  сформировать результирующую длину, а также использовать специальную логику для  обработки палиндромных слов.:** Правильно.
*   **D. Для решения задачи нужно сначала отсортировать массив, а затем составить строку в обратном порядке.:** Неправильно.

**В результате:**
*  Алгоритм на основе хеш-таблицы позволяет эффективно посчитать количество  слов.
*  Обработка палиндромных строк происходит с учетом четности.
*  Алгоритм позволяет получить правильную  максимальную длину палиндрома.

Таким образом, правильным ответом является **C. Для решения задачи нужно использовать словарь (хеш-таблицу) для подсчета  встречающихся пар и  сформировать результирующую длину, а также использовать специальную логику для обработки палиндромных слов.**
