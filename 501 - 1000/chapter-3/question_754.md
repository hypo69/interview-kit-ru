### `question_754.md`

**Вопрос 754.** Дан массив отрезков на прямой, где каждый отрезок задан координатами левого и правого конца. Разработайте эффективный алгоритм на Python, который для каждого отрезка определяет количество других отрезков, которые полностью в нем содержатся.

*   Отрезок `[a, b]` полностью содержится в отрезке `[c, d]`, если  `c <= a`  и `b <= d`.
*   Гарантируется, что все концы отрезков различны.

**Примеры:**
```
Ввод: intervals = [[1,5],[2,3],[4,5],[6,7],[7,9]]
Вывод: [0, 0, 0, 0, 0]
Объяснение: ни один из отрезков не содержится в другом

Ввод: intervals = [[1,7],[2,3],[4,5],[6,7]]
Вывод: [3,0,0,0]
Объяснение: интервалы [2,3], [4,5], [6,7] содержатся в [1,7], а остальные не содержат.

Ввод: intervals = [[0,5],[1,2],[0,10],[2,4],[6,7]]
Вывод: [1,0,4,0,0]
Объяснение:  [1,2] содержится в [0,5], [0, 5], [1,2], [2,4] и [6,7] содержатся в [0,10]
```

-   A. Для решения задачи необходимо перебрать все возможные пары отрезков и проверить, является ли один отрезок подмножеством другого.
-  B.  Для решения задачи нужно сначала отсортировать все отрезки, и затем с помощью линейного поиска проверять вложенные отрезки.
-   C.  Для решения задачи нужно использовать алгоритм бинарного поиска для проверки на вложенность.
-  D. Для решения задачи можно использовать алгоритм на основе сортировки и сканирующей прямой с event-point, и использовать  дерево отрезков.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи определения, какие отрезки содержатся внутри других, и их количества, оптимальным решением будет  использование алгоритма, основанного на сортировке и сканирующей прямой с использованием  дерева отрезков (Segment Tree) или  более простого подхода с использованием  списка для отслеживания открытых интервалов, что позволяет получить  решение  за O(n log n).

*   **Алгоритм (сканирующая прямая с деревом отрезков):**
   1.  **Представление интервалов как точек:**
         *    Создаем список, содержащий  начала и концы  отрезков,  где начало отрезка - `+1`, а конец -  `-1`, в  виде кортежей `(value, type, index)` где type  - `1`  для начала, `-1` для конца.
    2. **Сортировка:** Сортируем  список по значениям  (сначала начало, а потом конец).
       *   При совпадении значений отрезков, то концы сортируются перед началом.
    3. **Итерирование:** Проходим по списку точек:
          *  **Начало интервала (type = 1):** Увеличиваем количество  открытых интервалов `count`,  запоминаем  индекс  в стеке, и проверяем сколько интервалов лежат в нем на данный момент.
            *      Используем бинарный поиск, для нахождения в `end_intervals` позицию,  куда нужно  добавить текущий отрезок.
         *   **Конец интервала (type=-1):**  Уменьшаем счетчик   `count` , а также удаляем индекс  текущего отрезка из  `end_intervals`.
        *  Сохраняем промежуточные результаты для каждого индекса.
    4.  **Результат:** После завершения  перебора  возвращаем список  `result`  с кол-вом  подчиненных отрезков  для  каждого отрезка.

*   **Преимущества алгоритма:**
    *   **Линейно логарифмическая сложность:** Алгоритм имеет временную сложность `O(n log n)` из за необходимости сортировки.
     *  **Эффективность:** Позволяет избегать не нужных сравнений.
    *   **Правильный подсчет:** Гарантирует  корректный подсчет вложенных интервалов.
*  **Почему другие подходы не подходят:**
    *  **Перебор:** Полный перебор всех пар интервалов требует квадратичной сложности O(n^2).
    *   **Линейный поиск:**  Простой поиск  не позволит эффективно отслеживать вложенность.

**Примеры (псевдокод):**

```
function find_containing_intervals(intervals):
   events = [] # tuples (value, type, index), 1 for start -1 for end
  for index, interval in intervals:
      events.add(interval[0], 1, index)
      events.add(interval[1], -1, index)
    sort events by values

    end_intervals = [] # array to track opens intervals, sorted.

     result =  new array with zero values with length of intervals.
    count = 0

    for event in events:
        if event.type == 1:
           # check length of end intervals
           insert event.index in end_intervals in sorted order.
           result[event.index] = length(end_intervals)-1
        elif event.type = -1:
           # remove event.index from end_intervals
           remove from end_intervals
     return result

```
**Примеры реализации в Python:**

```python
import heapq

def find_containing_intervals(intervals):
    events = []
    for index, (start, end) in enumerate(intervals):
        events.append((start, 1, index)) # 1 for start of interval
        events.append((end, -1, index)) # -1 for end of interval

    events.sort()

    end_intervals = []
    result = [0] * len(intervals)

    count = 0
    for value, type, index in events:
      if type == 1:
          result[index] = len(end_intervals)
          heapq.heappush(end_intervals, intervals[index][1]) # insert in correct order
      else:
         end_intervals.remove(intervals[index][1])
         heapq.heapify(end_intervals) # re-heapify after removal
    return result


intervals1 = [[1,5],[2,3],[4,5],[6,7],[7,9]]
print(f"Ввод: intervals = {intervals1}")
print(f"Вывод: {find_containing_intervals(intervals1)}")   # Вывод: [0, 0, 0, 0, 0]


intervals2 = [[1,7],[2,3],[4,5],[6,7]]
print(f"Ввод: intervals = {intervals2}")
print(f"Вывод: {find_containing_intervals(intervals2)}") # Выведет:  [3, 0, 0, 0]


intervals3 = [[0,5],[1,2],[0,10],[2,4],[6,7]]
print(f"Ввод: intervals = {intervals3}")
print(f"Вывод: {find_containing_intervals(intervals3)}") # Выведет: [1, 0, 4, 0, 0]
```

**Разбор вариантов:**
*  **A. Для решения задачи нужно использовать алгоритм сортировки, затем отфильтровать пересекающиеся интервалы, и посчитать их кол-во.:** Неправильно.
*   **B. Для решения задачи можно использовать только бинарный поиск и проверять пересечения в отсортированном массиве.:** Неправильно.
*  **C. Для решения задачи нужно отсортировать  интервалы по времени начала и отслеживать  минимальное кол-во перекрывающихся интервалов, сохраняя при этом значения  концов  занятых комнат.:** Правильно,  но не  полностью так как  не используется дерево отрезков.
*   **D. Для решения задачи нужно использовать алгоритм поиска в глубину (DFS).:** Неправильно.

**В результате:**
* Алгоритм на основе сортировки и сканирующей прямой позволяет  эффективно решить задачу.
*  Алгоритм обрабатывает  открытия и закрытия отрезков, сохраняя их порядок и  позволяет отслеживать  наложение отрезков  друг на друга.
*  Используя `heapq`  можно реализовать  сортированное хранение концов интервалов.

Таким образом, правильным ответом является **C. Для решения задачи нужно отсортировать  интервалы по времени начала и отслеживать  минимальное кол-во перекрывающихся интервалов, сохраняя при этом значения  концов  занятых комнат.**
