### `question_793.md`

**Вопрос 793.** Разработайте декоратор `TimeDecorator` в Python, который измеряет время выполнения декорированной функции и выводит на экран строку в формате `"Затрачено N секунд"`, где N – это время выполнения функции в секундах. При этом декорированная функция должна работать как обычно и возвращать свой результат.

**Пример:**
```python
@TimeDecorator
def func():
    time.sleep(0.5)
    print('Я закончила работать!')

func()
# Вывод должен быть
# Затрачено 0.5 секунд
# Я закончила работать!
```

-   A. Для реализации декоратора  `TimeDecorator`, необходимо  только использовать `time.sleep()`
-   B. Для реализации  декоратора `TimeDecorator`, необходимо использовать  вложенную функцию и  `time.time()` для измерения времени до и после вызова основной функции.
-   C.  Для реализации декоратора `TimeDecorator` нужно переопределить  методы  `__get__()` и `__set__()`.
-   D. Для реализации декоратора `TimeDecorator` необходимо применить  метод  `@profile`.

**Правильный ответ: B**

**Объяснение:**

Для решения задачи создания декоратора `TimeDecorator`, который измеряет время выполнения декорированной функции и выводит результат на экран, нужно использовать вложенную функцию, а так же использовать  `time.time()` для отслеживания времени до и после вызова.

*   **Декоратор `TimeDecorator`:**
    *   **Функция-обертка:** Декоратор  является функцией, которая  принимает функцию как аргумент и возвращает новую функцию, в которой и осуществляется измерение времени.
   *    **`time.time()`:**  Используется для  измерения времени  до и после вызова декорируемой функции.
    *    **Вывод сообщения:** Выводит на экран время выполнения функции  в виде строки `"Затрачено N секунд"`.
    * **Вызов оригинальной функции:** Возвращаемая функция должна вызывать оригинальную функцию, и  возвращает ее результат.

**Примеры (псевдокод):**
```
function  TimeDecorator(func):
    function wrapper(*args, **kwargs):
      time_start =  start_time()
      result = func(*args, **kwargs)
        time_end  =  stop_time();
       print `затрачено `  + time_end-time_start + ` секунд`
        return result
    return wrapper
```

**Примеры реализации в Python:**

```python
import time
from functools import wraps

def TimeDecorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"Затрачено {end-start:.1f} секунд")
        return result
    return wrapper

@TimeDecorator
def func():
    time.sleep(0.5)
    print('Я закончила работать!')

func()
# Вывод будет (похож на):
# Затрачено 0.5 секунд
# Я закончила работать!

@TimeDecorator
def add(a,b):
   return a+b
print(add(10,5))
# Выведет
# Вызвана функция add  аргументы : (10, 5) {}
# Функция add вернула результат: 15
# 15
```
**Разбор вариантов:**

*  **A. Для реализации декоратора  `TimeDecorator`, необходимо  только использовать `time.sleep()`.:** Неправильно.
*   **B. Для реализации  декоратора `TimeDecorator`, необходимо использовать  вложенную функцию и  `time.time()` для измерения времени до и после вызова основной функции.:** Правильно.
*   **C. Для реализации декоратора `TimeDecorator` нужно переопределить  методы  `__get__()` и `__set__()`.:** Неправильно.
*   **D. Для реализации декоратора `TimeDecorator` необходимо применить  метод  `@profile`.:** Неправильно.

**В результате:**
*   Декоратор `TimeDecorator` позволяет  измерять время выполнения функции.
*   Вложенная функция  позволяет  вызвать функцию, и после ее завершения  вывести информацию о времени выполнения.
*  `time.time()`  и  декоратор позволяют  эффективно реализовать  замеры времени.

Таким образом, правильным ответом является **B. Для реализации  декоратора `TimeDecorator`, необходимо использовать  вложенную функцию и  `time.time()` для измерения времени до и после вызова основной функции.**
