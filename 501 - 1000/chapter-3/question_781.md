### `question_781.md`

**Вопрос 781.** Дан двумерный массив `grid`, представляющий карту, где `0` означает остров (сушу) и `1` означает воду. Остров считается изолированным, если он состоит только из `0` и со всех сторон окружен `1`. Разработайте алгоритм на Python для подсчета количества изолированных островов в матрице `grid`.

**Примеры:**
```
Ввод: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
Вывод: 2

Ввод: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
Вывод: 1
```
-   A. Для решения задачи можно использовать жадный алгоритм,  перебирая  ячейки  с 0, и если они изолированны, то увеличивать счетчик.
-  B. Для решения задачи, нужно использовать только цикл `for`, и  если  значение элемента 0, то проверять соседние значения.
-   C.  Для решения задачи  нужно использовать рекурсивный алгоритм обхода в глубину (DFS), который будет проверять ячейки, и  возвращать  1 или 0 в зависимости от того,  находится  ли ячейка в изолированном острове.
-   D. Для решения задачи, нужно использовать алгоритм поиска в ширину (BFS), и обходить  только  те элементы  которые  равны 0.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи подсчета изолированных островов в двумерном массиве, оптимальным является использование рекурсивного алгоритма поиска в глубину (DFS) с итерированием по матрице. DFS  позволит обойти все ячейки  острова, и  убедиться в том, что  он является  изолированным.

*   **Алгоритм (рекурсивный DFS):**
    1.  **Инициализация:** Инициализируем  переменную  `island_count = 0`  которая  будет считать количество изолированных островов.
   2. **Перебор матрицы:** Проходим  по всем ячейкам  матрицы:
        *   **Проверка ячейки:** Если текущая ячейка равна `0` (суша) и ещё не была посещена, то  вызываем  функцию  `dfs`  для этого  элемента,  которая и  будет проверять является ли он изолированным островом.
       * Если  `dfs` вернула  1,  увеличиваем  `island_count`.
    3. **Рекурсивная функция `dfs(row, col)`:**
          *  **Проверка границ:** Если текущие координаты за пределами матрицы,  или ячейка уже посещена, или значение ячейки 1 - то возвращаем 0.
        *  **Пометка ячейки:** Иначе,  меняем  значение текущей ячейки на  `-1` , для отметки о посещении (т.е. для  устранения  повторного перебора).
       *    **Проверка соседних ячеек:** Проверяем соседние ячейки  (сверху, снизу, слева, справа) и  вызываем  рекурсивную функцию для них.
     *  **Проверка изолированности:**  Если  все соседние ячейки  вернули  0,  значит  текущая  ячейка  является  началом  изолированного острова, то  возвращаем  `1`,  иначе `0`.
    4.   **Результат:** После  завершения перебора,  возвращаем  `island_count`.

*   **Преимущества алгоритма:**
    * **Рекурсивный обход:** Использует DFS, который позволяет эффективно  обходить   соединенные  области,  при этом  гарантирует  обход всех  ячеек острова.
   *  **Проверка на изолированность:**  При рекурсивном вызове проверяются только нужные ячейки.
    *  **Эффективность:** Алгоритм  имеет временную сложность  `O(n*m)`.
     *  **Постоянная память**:  Используется  постоянное кол-во дополнительной памяти, так как изменения  происходят непосредственно в массиве, за счет  присваивания  `-1`  значения.

**Примеры (псевдокод):**

```
function  count_isolated_islands(grid):
   max_island = 0
     for i  from 0 to rows length:
       for j from 0 to cols length:
         if grid[i][j] == 0:
              max_area += dfs(i,j)

  return max_area;
function dfs(row, col, grid):
   if row out of bounds or col out of bounds or grid[row][col] is not 0
     return 0;
   grid[row][col] = -1 # mark as visited
   return  dfs(row+1, col) + dfs(row-1, col) + dfs(row, col+1) + dfs(row, col-1)


```
**Примеры реализации в Python:**

```python
def count_isolated_islands(grid):
    if not grid:
        return 0
    rows = len(grid)
    cols = len(grid[0])
    island_count = 0
    def dfs(row, col):
        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 0:
            return 0
        grid[row][col] = -1 # mark as visited
        return (dfs(row+1, col) +
                dfs(row-1, col) +
                dfs(row, col+1)+
                dfs(row, col-1)
               or 1)  # 1 если  это  часть изолированного островка
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 0:
               island_count += dfs(i,j)
    return island_count
grid1 = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
print(f"Ввод: grid = {grid1}")
print(f"Вывод: {count_isolated_islands(grid1)}") # Выведет: Вывод: 2


grid2 = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
print(f"Ввод: grid = {grid2}")
print(f"Вывод: {count_isolated_islands(grid2)}") # Выведет: Вывод: 1

grid3 = [[0,0,0,0,0,0,0,0]]
print(f"Ввод: grid = {grid3}")
print(f"Вывод: {count_isolated_islands(grid3)}") # Выведет: 0
```

**Разбор вариантов:**

*  **A. Для решения задачи нужно использовать жадный алгоритм, перебирая каждую ячейку матрицы и перераспределяя излишний песок, но не учитывая повторные  разрушения.:** Неправильно. Жадный алгоритм тут не подойдет.
*   **B. Для решения задачи нужно использовать рекурсивный обход графа в глубину (DFS), который будет проверять ячейки, и  возвращать  1 или 0 в зависимости от того,  находится  ли ячейка в изолированном острове.:** Правильно.
*   **C. Для решения задачи нужно использовать обход в ширину (BFS) и очередь.:** Неправильно. BFS не является наиболее оптимальным способом для решения данной задачи.
*  **D. Для решения задачи требуется алгоритм динамического программирования, при этом необходимо будет сохранять промежуточные данные о площади островов.:** Неправильно. Динамическое программирование не является оптимальным решением.

**В результате:**
*   Рекурсивный  DFS позволяет эффективно  обходить все элементы  острова.
*  Алгоритм  устанавливает  значение в `-1` для того чтобы  не перебирать ячейку повторно.
* Алгоритм  возвращает  количество изолированных  островов, имеющих  все граничные условия, где  все соседи — `1`.
* Алгоритм  имеет  линейную сложность, что является достаточно эффективным решением для  этой задачи.

Таким образом, правильным ответом является **B. Для решения задачи нужно использовать рекурсивный обход графа в глубину (DFS), который будет проверять ячейки, и  возвращать  1 или 0 в зависимости от того,  находится  ли ячейка в изолированном острове.**
