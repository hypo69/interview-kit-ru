### `question_687.md`

**Вопрос 687.** Имеется программный продукт с `n` версиями, пронумерованных от 1 до `n`. Вам предоставляется API `bool isBadVersion(version)`, который возвращает `True`, если версия `version` является дефектной, и `False` в противном случае. Известно, что все версии после дефектной также дефектные. Разработайте алгоритм для поиска первой дефектной версии с использованием минимального числа вызовов API.

**Примеры:**

```
Ввод: n = 5, bad = 4
Вывод: 4
Объяснение:
call isBadVersion(3) -> False
call isBadVersion(5) -> True
call isBadVersion(4) -> True
4 - первая испорченная версия.

Ввод: n = 10, bad = 6
Вывод: 6
```

-   A.  Для решения задачи нужно использовать линейный поиск, последовательно проверяя каждую версию.
-   B.  Для решения задачи необходимо использовать цикл while и перебирать все значения в обратном порядке.
-   C. Для решения задачи необходимо использовать бинарный поиск для нахождения первой дефектной версии, так как поиск происходит в отсортированной последовательности.
-   D.  Для решения задачи можно использовать жадный алгоритм, всегда выбирая первое попавшееся плохое значение.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи поиска первой дефектной версии, в упорядоченном списке версий с помощью минимального кол-ва проверок, необходимо применить алгоритм бинарного поиска,  который позволяет исключать не нужные варианты на каждом шагу, тем самым позволяя достичь логарифмической сложности O(log n).

*   **Алгоритм (бинарный поиск):**
    1. **Инициализация:** Устанавливаем `left` на 1 и `right` на `n` (максимальное число версий).
    2.  **Итерация (бинарный поиск):** Пока левая граница `left` меньше или равна правой границе `right`:
            *  Находим середину: `mid = left + (right - left) // 2`
             *  **Проверка:** Вызываем  `isBadVersion(mid)`:
                *   Если `isBadVersion(mid)` возвращает `True`,  значит  `mid` является потенциальной "плохой версией", и нужно сузить поиск в левой половине `right = mid - 1`,  запоминая `mid` в качестве потенциального ответа.
                *    Если  `isBadVersion(mid)`  возвращает `False`, значит  `mid`  является "хорошей версией",  и  нужно сузить поиск  в правой половине  `left = mid + 1`.
    3. **Результат:** После цикла `while`, возвращаем последний найденный  `index`  или  `left`.

*   **Преимущества алгоритма:**
    *  **Логарифмическая сложность:**  Алгоритм обеспечивает временную сложность O(log n), поскольку на каждом шаге мы уменьшаем размер поиска вдвое.
    *   **Минимальное количество проверок:**  Использует  наименьшее количество вызовов `isBadVersion()`.
    *   **Оптимальность:** Позволяет найти  первую "плохую" версию  в  отсортированной последовательности  версий.

**Примеры (псевдокод):**
```
function find_first_bad_version(n):
   left = 1
   right = n
   result = -1
   while left <= right:
     mid = left + (right - left) // 2
     if isBadVersion(mid):
       result = mid;
       right = mid - 1 # go to left half
     else:
       left = mid + 1  # go to right half
   return result
```

**Примеры реализации в Python:**
```python
def isBadVersion(version, bad): # вспомогательная функция для проверки "плохой" версии.
  return version >= bad

def find_first_bad_version(n, bad):
    left = 1
    right = n
    result = -1
    while left <= right:
        mid = left + (right - left) // 2
        if isBadVersion(mid, bad):
            result = mid
            right = mid - 1
        else:
           left = mid + 1
    return result

n1 = 5
bad1 = 4
print(f"Ввод: n = {n1}, bad = {bad1}")
print(f"Вывод: {find_first_bad_version(n1, bad1)}") # Выведет: Вывод: 4

n2 = 10
bad2 = 6
print(f"Ввод: n = {n2}, bad = {bad2}")
print(f"Вывод: {find_first_bad_version(n2, bad2)}") # Выведет: Вывод: 6

```

**Разбор вариантов:**

*   **A. Для решения задачи нужно использовать линейный поиск, последовательно проверяя каждую версию.:** Неправильно.
*  **B. Для решения задачи необходимо использовать цикл while и перебирать все значения в обратном порядке.:** Неправильно.
*   **C. Для решения задачи нужно использовать бинарный поиск для нахождения первой дефектной версии, так как поиск происходит в отсортированной последовательности.:** Правильно.
*   **D. Для решения задачи можно использовать жадный алгоритм, всегда выбирая первое попавшееся плохое значение.:** Неправильно.

**В результате:**
*   Бинарный поиск позволяет эффективно найти первое неисправное значение.
*   Алгоритм  гарантирует логарифмическую сложность `O(log n)`.
*  Алгоритм  использует знание, что версии отсортированы и  может пропускать не нужные варианты для поиска правильного ответа.

Таким образом, правильным ответом является **C. Для решения задачи нужно использовать бинарный поиск для нахождения первой дефектной версии, так как поиск происходит в отсортированной последовательности.**
