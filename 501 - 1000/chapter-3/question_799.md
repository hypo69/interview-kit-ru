### `question_799.md`

**Вопрос 799.** Зашифруйте текст `"To be, or not to be, that is the question!"` с помощью алгоритма Цезаря (сдвигового шифра), сдвигая каждый символ вправо на 1717 позиций.

*   Используйте алфавит:
    *   Строчные латинские буквы: `'abcdefghijklmnopqrstuvwxyz'`
    *   Прописные латинские буквы: `'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
*  Неалфавитные символы остаются без изменений.

-   A. Для шифрования Цезаря, необходимо заменить все символы на пробелы, а регистр игнорируется.
- B.  Для шифрования Цезаря нужно использовать функцию `encode()`,  с  параметром  шифрования.
-   C.  Для шифрования Цезаря  необходимо использовать циклы  и сдвиг на 1717, и при этом расширять алфавит.
-   D. Для решения задачи  нужно использовать алгоритм с  постоянным смещением на  основе  номера символа, используя  циклы, при этом нужно  обработать  случай  с переполнением алфавита,  циклически переходя к началу алфавита.

**Правильный ответ: D**

**Объяснение:**

Для шифрования текста с помощью шифра Цезаря (сдвигового шифра) используется  алгоритм, который  смещает каждый символ строки на заданное число позиций вправо (циклически, т.е. после `z` идет  `a`), и сохраняет все небуквенные символы неизменными.

*   **Алгоритм Цезаря (со сдвигом):**
    1.  **Определение алфавитов:** Заранее создаем  алфавиты для строчных и прописных символов.
    2.  **Итерация по строке:**  Итерируем посимвольно  входную строку:
        *  **Проверка регистра:** Если текущий символ прописной,  то вычисляем сдвинутый символ в  верхнем регистре.
             *   Если текущий символ строчной, то  вычисляем  сдвинутый символ  в нижнем  регистре.
          *  **Циклический сдвиг:**  Находим индекс текущего символа в алфавите.
            *  Вычисляем новый индекс после сдвига, и при этом  обеспечиваем  циклический сдвиг,  если  сумма индекса и сдвига превышает длину  алфавита.
          * **Неалфавитный символ:** Если текущий символ не буква, то добавляем его в строку без изменения.
    3. **Результирующая строка:** Строку с зашифрованными символами возвращаем.

*   **Преимущества алгоритма:**
    *   **Шифрование:**  Алгоритм позволяет шифровать  строку, сдвигая каждый символ на заданное  число.
    *  **Обработка регистра:** Алгоритм правильно обрабатывает как  прописные так и строчные символы.
    *  **Простота:** Код понятен и легко реализуется.

**Примеры (псевдокод):**
```
function caesar_cipher(s, shift):
    new_string = empty string
    eng_lower_alphabet = "abcdefghijklmnopqrstuvwxyz"
    eng_upper_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

    for symbol in string s:
      if symbol is upper:
        add shifted upper symbol from alphabet with shift
      if symbol is lower:
         add shifted lower symbol from alphabet with shift
      else:
          add symbol without change
    return new_string
```
**Примеры реализации в Python:**
```python
def transcode(s):
    new_s = ''
    eng_lower_alphabet = 'abcdefghijklmnopqrstuvwxyz'
    eng_upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    shift = 1717
    for i in range(len(s)):
        if s[i].isupper():
            ind = eng_upper_alphabet.find(s[i])
            while not ind + shift < len(eng_upper_alphabet):
                 eng_upper_alphabet += eng_upper_alphabet
            new_s += eng_upper_alphabet[ind + shift]
        elif s[i].islower():
            ind = eng_lower_alphabet.find(s[i])
            while not ind + shift < len(eng_lower_alphabet):
                eng_lower_alphabet += eng_lower_alphabet
            new_s += eng_lower_alphabet[ind + shift]
        else:
            new_s += s[i]
    return new_s

s = 'To be, or not to be, that is the question!'
print(f"Ввод: s = '{s}'")
print(f"Вывод: {transcode(s)}") # Выведет: Вывод: Kf sv, fi efk kf sv, kyrk zj kyv hlvjkzfe!
```

**Разбор вариантов:**
*  **A. Для решения задачи нужно использовать только условный оператор `if-elif-else`, для обработки каждого разряда числа.:** Неправильно.
*   **B. Для решения задачи нужно использовать функцию `encode()`, с параметром шифрования.:** Неправильно.
*   **C. Для решения задачи необходимо использовать циклы и сдвиг на 1717, и при этом расширять алфавит.:** Правильно, но не явно описывает сдвиг.
*   **D. Для решения задачи подойдет только  жадный алгоритм, при котором на каждом шаге выбираем текущий символ для кодирования.:** Неправильно.

**В результате:**
*  Для шифрования используется  сдвиг символов  на  заданное кол-во позиций.
*   `isupper()`  и  `islower()` позволяют правильно работать  с символами разного регистра.
*   При вычислении индекса, используется циклический сдвиг.

Таким образом, правильным ответом является **C. Для решения задачи необходимо использовать циклы и сдвиг на 1717, и при этом расширять алфавит.**
