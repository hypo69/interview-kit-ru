### `question_710.md`

**Вопрос 710.** Дана строка `s`. Разработайте алгоритм для поиска и возвращения самого длинного палиндрома в строке.

*   Палиндром — это строка, которая одинаково читается как слева направо, так и справа налево.

**Примеры:**

```
Ввод: s = "babad"
Вывод: "bab"
Объяснение: "aba" также является ответом

Ввод: s = "cbbd"
Вывод: "bb"
```

-   A. Для решения задачи нужно перебрать все возможные подстроки, и при этом проверить их на палиндромность.
-   B. Для решения задачи нужно использовать алгоритм быстрой сортировки и сравнить отсортированные подстроки.
-   C. Для решения задачи нужно использовать алгоритм динамического программирования, который находит все палиндромы, и запоминает самый длинный.
-  D. Для решения задачи, нужно проверить каждую позицию в строке и  расширять палиндром  налево и направо, пока это возможно, и сохранять самый длинный.

**Правильный ответ: D**

**Объяснение:**

Для нахождения самой длинной подстроки палиндрома в строке, оптимальным будет использование подхода, который просматривает все возможные палиндромы от каждой позиции, используя расширяющийся метод, который имеет  линейную сложность по времени и не требует дополнительной памяти.

*   **Алгоритм (с центрированием и расширением):**
    1.  **Инициализация:** Устанавливаем начальную самую длинную подстроку как пустую.
    2.  **Итерирование по строке:** Проходим по каждому символу в строке.
        *    **Центр как один символ:**  Считаем текущий символ как центр палиндрома, и  проверяем максимальный палиндром расширением в обе стороны.
      * **Центр между двумя символами:**  Считаем, что центр палиндрома находится между текущим и следующим  символом,  и  так же  расширяем в обе стороны
       *    **Сравнение с максимумом:** Если новый палиндром длиннее текущего максимального палиндрома, то запоминаем новый.
    3.   **Возвращаем результат:** После прохождения всех элементов возвращаем самый длинный палиндром.

*   **Преимущества алгоритма:**
    *   **Линейная сложность:** Алгоритм  имеет временную сложность `O(n^2)`, что является наиболее оптимальным решением.
    *   **Эффективность:** Проверяет только необходимые комбинации.
    *   **Простота:** Алгоритм легок в реализации.
     *   **Постоянная память:**  Не требует дополнительную память.

**Примеры (псевдокод):**
```
function longest_palindrome(s):
    longest_palindrome_string = ""
    for i in range (length(s)):
       # Проверяем палиндромность, центр в точке i
        l1 = expand_around_center(s, i, i)
       # Проверяем палиндромность, центр между i и i+1
       l2 = expand_around_center(s, i, i+1)
       longest_palindrome_string =  max(longest_palindrome_string, l1, l2)
     return longest_palindrome_string
 function expand_around_center(s, left, right):
   while left >=0 and right < len(s) and s[left] == s[right]:
     left = left-1
     right=right+1
   return s[left+1:right]
```

**Примеры реализации в Python:**

```python
def longest_palindrome(s):
    longest_palindrome_string = ""

    def expand_around_center(s, left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left+1:right]

    for i in range(len(s)):
        palindrome1 = expand_around_center(s, i, i)
        palindrome2 = expand_around_center(s, i, i+1)
        longest_palindrome_string = max(longest_palindrome_string, palindrome1, palindrome2, key=len)

    return longest_palindrome_string
print(f"Ввод: s = 'babad'")
print(f"Вывод: '{longest_palindrome('babad')}'") # Выведет: Вывод: 'bab'

print(f"Ввод: s = 'cbbd'")
print(f"Вывод: '{longest_palindrome('cbbd')}'") # Выведет: Вывод: 'bb'

print(f"Ввод: s = 'testpalindromemordnilaptest'")
print(f"Вывод: '{longest_palindrome('testpalindromemordnilaptest')}'") # Выведет: Вывод: 'testpalindromemordnilaptest'

```
**Разбор вариантов:**

*   **A. Для решения задачи нужно перебрать все возможные подстроки, и при этом проверить их на палиндромность.:** Неправильно, такой подход приведет к  O(n^3) сложности, что не является оптимальным.
*  **B. Для решения задачи нужно использовать алгоритм быстрой сортировки и сравнить отсортированные подстроки.:** Неправильно. Быстрая сортировка  не поможет решить задачу.
*   **C. Для решения задачи нужно использовать алгоритм динамического программирования, который находит все палиндромы, и запоминает самый длинный.:** Неправильно. Хотя динамическое программирование решает эту задачу,  имеет сложность O(n^2), но  расширение строки в обе стороны более прямой способ.
*  **D. Для решения задачи, нужно проверить каждую позицию в строке и  расширять палиндром  налево и направо, пока это возможно, и сохранять самый длинный.:** Правильно.

**В результате:**
*   Расширение строк с центра является эффективным алгоритмом для поиска палиндрома.
*   Алгоритм имеет  сложность O(n^2), и не использует дополнительной памяти.

Таким образом, правильным ответом является **D. Для решения задачи, нужно проверить каждую позицию в строке и  расширять палиндром  налево и направо, пока это возможно, и сохранять самый длинный.**
