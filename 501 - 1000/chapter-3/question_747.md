### `question_747.md`

**Вопрос 747.** Дан размер массива `n`. Разработайте алгоритм для создания массива целых чисел, где каждый элемент является случайным числом (как положительным, так и отрицательным) таким образом, чтобы *абсолютные значения* всех чисел в массиве были уникальными. После создания массива, найдите в нем максимальное по модулю (абсолютному значению) число и верните его.

-  A.  Для решения задачи нужно создать  массив случайных  значений,  отсортировать его и убедиться, что  все значения в нем уникальны по модулю.
-  B.  Для решения задачи нужно генерировать значения  и  проверять каждое значение на уникальность по модулю с  помощью цикла и множества, а затем проитерироваться по  массиву и вернуть  максимальное  по модулю число.
- C. Для решения задачи нужно перебирать все возможные комбинации  и  генерировать их  рекурсивно.
- D. Для решения задачи подходит  жадный алгоритм, при котором на каждом шаге подбираем случайное число,  удовлетворяющее условиям, пока не будет достигнут размер  n.

**Правильный ответ: B**

**Объяснение:**

Для решения задачи создания массива случайных целых чисел с уникальными абсолютными значениями, а также поиска максимального по модулю значения, необходим подход, который будет гарантировать уникальность на каждом шаге добавления в список,  а для поиска  максимального элемента достаточно перебрать все элементы и выбрать наибольший, используя  функцию `abs()` и оператор  `max()`.

*   **Алгоритм (итеративный с проверкой уникальности):**
    1.  **Инициализация:**
        *   Создаем пустой массив `result` для хранения случайных чисел.
        *   Создаем пустое множество  `seen_abs`,  для отслеживания уже добавленных абсолютных значений.
    2.  **Генерация и проверка:** Итерируемся  пока длина массива `result` не будет равна  `n`.
        *   Генерируем новое случайное число `new_num`, которое  может быть как  положительным так и отрицательным.
        *   **Проверка уникальности:** Вычисляем модуль  `abs(new_num)` и проверяем, существует ли этот модуль в `seen_abs`.
            *   Если да, то пропускаем число, и переходим к следующей итерации.
            *   Если нет, то  добавляем в множество  `seen_abs`  модуль числа `abs(new_num)`  и  добавляем в список `result` само число  `new_num`.
   3. **Поиск максимума:**
     *  Итерируемся по полученному списку  `result` и  используя `abs()` для получения модуля значения, находим максимальное значение.
    4.  **Результат:**  Возвращаем  найденное максимальное значение  по модулю.

*   **Преимущества алгоритма:**
    *   **Гарантированная уникальность:** Множество `seen_abs` обеспечивает, что ни одно абсолютное значение не повторится в массиве.
    *   **Эффективность:**   Алгоритм имеет сложность, близкую к O(n), так как проверяется  каждое новое значение.
     *   **Нахождение максимума:** Алгоритм  позволяет найти значение  максимальное по модулю, за время O(n).

**Примеры (псевдокод):**
```
function generate_unique_abs_numbers(n):
  result = [] # list with resulting numbers.
  seen_abs = set() # set for tracking abs values
    while length(result) is less than n:
        new_num =  random number (positive or negative)
         if abs(new_num) is not in seen_abs
           add new_num to result
           add abs(new_num) to seen_abs
  max_abs = 0;
  for x in result:
     if abs(x) > max_abs:
       max_abs = abs(x)
  return max_abs
```

**Примеры реализации в Python:**
```python
import random
def generate_unique_abs_numbers(n):
    result = []
    seen_abs = set()

    while len(result) < n:
      new_num = random.randint(-1000, 1000)
      if abs(new_num) not in seen_abs:
         seen_abs.add(abs(new_num))
         result.append(new_num)
    max_abs = 0
    for x in result:
      if abs(x) > max_abs:
        max_abs = abs(x)

    return  max_abs

print(f"Вывод: {generate_unique_abs_numbers(5)}") # Выведет: Вывод: случайное значение, но не меньше 0
print(f"Вывод: {generate_unique_abs_numbers(10)}") # Выведет: Вывод: случайное значение, но не меньше 0
print(f"Вывод: {generate_unique_abs_numbers(20)}") # Выведет: Вывод: случайное значение, но не меньше 0
```

**Разбор вариантов:**
*  **A. Для решения задачи нужно создать  массив случайных  значений,  отсортировать его и убедиться, что  все значения в нем уникальны по модулю.:** Неправильно, это не эффективно.
*  **B. Для решения задачи нужно генерировать значения и  проверять каждое значение на уникальность по модулю с  помощью цикла и множества, а затем проитерироваться по  массиву и вернуть  максимальное  по модулю число.:** Правильно.
* **C. Для решения задачи нужно перебирать все возможные комбинации  и  генерировать их  рекурсивно.:** Неправильно.  Рекурсия тут не нужна и замедлит процесс.
*   **D. Для решения задачи подходит  жадный алгоритм, при котором на каждом шаге подбираем случайное число,  удовлетворяющее условиям, пока не будет достигнут размер  n.:** Неправильно. Жадный алгоритм не гарантирует уникальности элементов.

**В результате:**
*  Использование множества  позволяет избежать дубликатов при генерации массива случайных чисел.
*  Перебор массива  один раз позволяет  эффективно найти максимальный элемент  по модулю.
*  Сложность алгоритма  `O(n)` - где  n длина массива.

Таким образом, правильным ответом является **B. Для решения задачи нужно генерировать значения  и  проверять каждое значение на уникальность по модулю с  помощью цикла и множества, а затем проитерироваться по  массиву и вернуть  максимальное  по модулю число.**
