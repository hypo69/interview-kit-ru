### `question_748.md`

**Вопрос 748.** Вам дан массив целых чисел `students`, представляющий рейтинг успеваемости учеников. Вычислите минимальное количество элементов, которое нужно удалить из массива, чтобы получился массив, "понравившийся" учителю информатики, Ивану Ивановичу (ИИ).

Массив `students` нравится ИИ, если:
1. Длина массива является четным числом.
2.  Для всех учеников на четных позициях `students[i] != students[i+1]` (т.е. у соседей по парте должен быть разный рейтинг).

Пустой массив также нравится ИИ.

*   Важно: Переставлять элементы местами нельзя, можно только удалять. Когда элемент удаляется, элементы справа смещаются на одну позицию влево.

**Примеры:**

```
Ввод: students = [1, 1, 2, 3, 5]
Вывод: 1
Объяснение: Можно удалить либо students[0], либо students[1], чтобы получить  [1, 2, 3, 5].

Ввод: students = [1,1,1,2,3]
Вывод: 1
Объяснение: Удаляем 1, и получим [1,2,3] , затем удалим 1, получим [2,3]. А если удалить  третий 1 то получим: [1,1,2,3] , а это не верный вариант.

Ввод: students = [1,1,2,2,3,3]
Вывод: 3
Объяснение: Нужно удалить хотя бы один из каждой пары
```

-  A.  Для решения задачи нужно перебрать все варианты удалений, и выбрать минимальное число удалений, и все решения проверить на валидность.
- B.  Для решения задачи нужно использовать жадный алгоритм, удаляя дублирующиеся элементы по одному и удаляя элемент, если длинна массива не является четным числом.
-   C.  Для решения задачи  необходимо использовать  динамическое программирование и искать оптимальную последовательность  удаления элементов,  с помощью сохранения ранее вычисленных значений.
-  D.  Для решения задачи нужно использовать  жадный алгоритм и проверять  четные пары элементов и  при необходимости удалять элементы,  проходя  массив слева направо.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи нахождения минимального количества удалений из массива с целью его "понравится" ИИ, нужно использовать динамическое программирование, что позволит  построить решение на основе предыдущих вычислений. При этом можно  оптимально выбрать, какой элемент нужно удалить, если есть конфликт на четной позиции.

*   **Алгоритм (динамическое программирование):**
    1.  **Инициализация:**
         *   Создаем массив `dp`,  длинной  `n+1` с значениями 0. Значение `dp[i]` будет соответствовать минимальному количеству удаленных элементов до индекса `i`, при этом  подмассив `nums[:i]` будет нравится ИИ.
    2. **Итерирование по массиву:** Итерируемся по  массиву `students` от `2`  до конца:
         *   **Проверка на чётность:**  Если индекс `i` четный, то:
                *   Если  `students[i-2]` и  `students[i-1]`  не равны, то  берем  предыдущее значение  `dp[i-2]`.
                 *   Если `students[i-2]` и  `students[i-1]` равны, то  берем  минимальное из  `dp[i-1]+1`  (удаляем предыдущий) и  `dp[i-2]+1`  (удаляем текущий).
           *   **Нечетный индекс:** Если индекс `i`  нечетный, то просто копируем предыдущее значение `dp[i] = dp[i-1]`
    3.  **Проверка четности:** Если длина списка `n` не четна, то добавляем `1`  к значению  в `dp[n-1]`.
    4. **Результат:**  Возвращаем значение  `dp[n]`,  которое и  соответствует  минимальному кол-ву  удаленных элементов.

*   **Преимущества алгоритма:**
    *   **Динамическое программирование:** Использует  массив `dp` для хранения  промежуточных решений и  избегания повторных вычислений.
    *  **Оптимальность:**  Находит минимальное количество удалений, необходимых для достижения желаемого состояния.
   *  **Переиспользование:** Использует ранее вычисленные результаты.
  *   **Линейная сложность:**  Алгоритм имеет  временную сложность `O(n)`.

**Примеры (псевдокод):**
```
function min_removals(students):
     n = length(students)
     dp = an array with length n+1 with defaults 0
    for i = 2 to n-1
       if i is even
           if students[i-2] != students[i-1]
                dp[i] = dp[i-2]
          else
             dp[i] = min(dp[i-1]+1, dp[i-2] +1)
        else
           dp[i] = dp[i-1]
     if len is odd
         dp[n] = dp[n-1] + 1
    return dp[n]
```
**Примеры реализации в Python:**

```python
def min_removals(students):
    n = len(students)
    dp = [0] * (n + 1)
    for i in range(2, n + 1):
        if i % 2 == 0:
            if students[i-2] != students[i-1]:
               dp[i] = dp[i-2]
            else:
                dp[i] = min(dp[i-1] + 1, dp[i-2]+1)
        else:
             dp[i] = dp[i-1]
    if n % 2 != 0:
        dp[n] = dp[n-1] + 1

    return dp[n]

students1 = [1, 1, 2, 3, 5]
print(f"Ввод: students = {students1}")
print(f"Вывод: {min_removals(students1)}") # Выведет: 1

students2 = [1,1,1,2,3]
print(f"Ввод: students = {students2}")
print(f"Вывод: {min_removals(students2)}") # Выведет: 1

students3 = [1,1,2,2,3,3]
print(f"Ввод: students = {students3}")
print(f"Вывод: {min_removals(students3)}") # Выведет: 3
```
**Разбор вариантов:**
*  **A. Для решения задачи нужно перебрать все возможные комбинации игроков, проверить их на конфликт, и затем найти  максимальную сумму очков.:** Неправильно. Полный перебор не эффективен.
*  **B. Для решения задачи нужно использовать только жадный алгоритм, добавляя к команде игроков,  набравших наибольшее кол-во очков.:** Неправильно. Жадный алгоритм не гарантирует нахождение минимального кол-ва удалений.
*   **C. Для решения задачи  необходимо использовать  динамическое программирование и искать оптимальную последовательность  удаления элементов,  с помощью сохранения ранее вычисленных значений.:** Правильно.
*  **D. Для решения задачи нужно отсортировать массив и проверить,  только  элементы,  которые стоят рядом.:** Неправильно.

**В результате:**
*  Алгоритм использует массив dp для сохранения информации о минимальном кол-ве удалений до текущего индекса.
*  При итерации используются прошлые значения для вычисления текущего результата.
*  Алгоритм  достигает  сложности  `O(n)` при  вычислении результата.

Таким образом, правильным ответом является **C. Для решения задачи необходимо использовать динамическое программирование и искать оптимальную последовательность удаления элементов, с помощью сохранения ранее вычисленных значений.**
