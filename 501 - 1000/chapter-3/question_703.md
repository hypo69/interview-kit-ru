### `question_703.md`

**Вопрос 703.** Дан список целых чисел `candidates` и целое число `target`. Разработайте алгоритм, который находит и возвращает все уникальные комбинации чисел из `candidates`, сумма которых равна `target`. Каждый число из списка `candidates` может использоваться только один раз в каждой комбинации. Результат не должен содержать дубликатов.

**Примеры:**

```
Ввод: candidates = [10,1,2,7,6,1,5], target = 8
Вывод: [
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

Ввод: candidates = [2,5,2,1,2], target = 5
Вывод: [
[1,2,2],
[5]
]
```

- A. Для решения задачи необходимо использовать полный перебор всех возможных комбинаций с проверкой на сумму.
- B. Для решения задачи необходимо использовать только жадный алгоритм, выбирая подходящие элементы до достижения требуемого значения target.
- C. Для решения задачи необходимо использовать только алгоритм сортировки.
- D.  Для решения задачи нужно использовать рекурсию с бэктрекингом и дополнительным отсечением не перспективных решений.

**Правильный ответ: D**

**Объяснение:**

Для решения задачи поиска всех уникальных комбинаций, дающих в сумме заданное целевое значение, используется алгоритм рекурсивного бэктрекинга, который позволяет перебрать все возможные комбинации чисел с заданными ограничениями, и  с отсечением не перспективных ветвей, что повышает производительность.

*   **Алгоритм (рекурсивный с бэктрекингом):**
    1.  **Сортировка:** Исходный список `candidates` сортируется, что позволяет избежать повторных комбинаций.
    2. **Рекурсивная функция:**  Создается рекурсивная функция, которая:
         *   Принимает текущую комбинацию,  остаточную сумму `target`, индекс текущего элемента, и список результатов.
        * **Базовый случай (успех):** Если `target` равно `0`, то текущая комбинация добавляется в список результатов.
         *  **Базовый случай (отсечение):** Если `target` меньше 0, то функция ничего не добавляет и возвращается.
        *  **Итерация и рекурсия:**  Итерируемся по элементам, начиная с текущего индекса:
             *    Игнорируем дубликаты:  для этого требуется использовать проверку `if i > index and candidates[i] == candidates[i-1]: continue`.
            *  Рекурсивно вызываем функцию, уменьшая  остаточную сумму  и передавая в рекурсию значение текущего индекса + 1.
        *  **Бэктрекинг:** Отменяем текущий выбор (не добавляем элемент к комбинации), чтобы рассмотреть другие варианты.

*  **Преимущества алгоритма:**
    *   **Нахождение всех комбинаций:** Перебирает все возможные подмножества, которые дают нужную сумму.
    *   **Бэктрекинг:** Отбрасывает неподходящие  варианты.
    *  **Отсечение:**  Отсечение на дубликатах и отрицательной сумме, для оптимизации решения.

**Примеры (псевдокод):**

```
function find_combinations(candidates, target, index, current_combination, result):
   if target == 0:
        add current_combination to result
        return

   if target < 0:
        return

    for i from index to length(candidates) - 1:
      if i > index and candidates[i] == candidates[i-1]:
        continue

        # include
        current_combination.append(candidates[i])
        find_combinations(candidates, target-candidates[i], i+1, current_combination, result)
         current_combination.removeLast() # Backtracking
```

**Примеры реализации в Python:**

```python
def find_combinations(candidates, target):
    result = []
    candidates.sort()
    def backtrack(index, current_combination, remaining_target):
      if remaining_target == 0:
         result.append(current_combination.copy())
         return
      if remaining_target < 0:
         return

      for i in range(index, len(candidates)):
        if i > index and candidates[i] == candidates[i-1]:
            continue
        current_combination.append(candidates[i])
        backtrack(i+1, current_combination, remaining_target - candidates[i])
        current_combination.pop() # Backtracking

    backtrack(0, [], target) # стартуем  рекурсивный поиск
    return result


candidates1 = [10, 1, 2, 7, 6, 1, 5]
target1 = 8
print(f"Ввод: candidates = {candidates1}, target = {target1}")
print(f"Вывод: {find_combinations(candidates1, target1)}") # Вывод:  [['1', '1', '6'], ['1', '2', '5'], ['1', '7'], ['2', '6']]

candidates2 = [2, 5, 2, 1, 2]
target2 = 5
print(f"Ввод: candidates = {candidates2}, target = {target2}")
print(f"Вывод: {find_combinations(candidates2, target2)}")  # Вывод: [['1', '2', '2'], ['5']]
```

**Разбор вариантов:**
*   **A. Для решения задачи необходимо использовать полный перебор всех возможных комбинаций с проверкой на сумму.:** Неправильно. Полный перебор неэффективен.
*  **B. Для решения задачи необходимо использовать только жадный алгоритм, выбирая подходящие элементы до достижения требуемого значения target.:** Неправильно. Жадный алгоритм не гарантирует нахождение всех решений.
*  **C. Для решения задачи нужно использовать только алгоритм сортировки.:** Неправильно.
*   **D. Для решения задачи нужно использовать рекурсию с бэктрекингом и дополнительным отсечением не перспективных решений.:** Правильно.

**В результате:**
*   Рекурсивный алгоритм с бэктрекингом  находит все возможные комбинации чисел  с заданными ограничениями.
*   Метод позволяет отсекать не перспективные решения (если  сумма становится отрицательной), а также  избегать дубликатов.

Таким образом, правильным ответом является **D. Для решения задачи нужно использовать рекурсию с бэктрекингом и дополнительным отсечением не перспективных решений.**
