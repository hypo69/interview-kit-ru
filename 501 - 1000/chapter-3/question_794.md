### `question_794.md`

**Вопрос 794.** Разработайте декоратор `RepeatDecorator` в Python, который проверяет, вызывалась ли ранее декорированная функция с заданными позиционными аргументами. Если вызов с такими аргументами уже был, то декоратор должен вывести на экран сообщение `"Функция с такими аргументами уже запускалась!"`. Иначе - вызывает декорируемую функцию.

*   Примечание: Декоратор должен вести себя правильно в случае, если декорируются разные функции, с одинаковыми аргументами.

**Примеры:**
```python
@RepeatDecorator
def func1(x, y):
    pass

@RepeatDecorator
def func2(x, y):
    pass
func1(1, 2)
# Ничего не выводится
func1(2, 1)
# Ничего не выводится
func1(3, 1)
# Ничего не выводится
func1(1, 2)
# Функция с такими аргументами уже запускалась!

func2(1, 2)
# Ничего не выводится, т.к. функция другая
func2(1, 2)
# Функция с такими аргументами уже запускалась!
```

-  A. Для решения задачи нужно использовать  только   глобальную переменную.
- B.  Для решения задачи необходимо использовать только стек для отслеживания ранее вызванных функций.
-   C.  Для решения задачи нужно использовать  словарь (хеш-таблицу),  где ключом будет имя функции и кортеж позиционных аргументов, и проверять, есть ли такой ключ.
-   D. Для решения задачи необходимо использовать только рекурсию и сохранять значения в стек.

**Правильный ответ: C**

**Объяснение:**

Для реализации декоратора, отслеживающего повторные вызовы функции с идентичными позиционными аргументами, оптимальным подходом является использование словаря (хеш-таблицы). Это позволяет эффективно проверять наличие ранее вызванных функций с заданными аргументами.

*   **Основные концепции:**
    *   **Словарь (хеш-таблица):** Используется для хранения информации  о  ранее вызванных функциях и их  позиционных аргументов (в виде кортежей).
        *  Ключем в словаре является имя функции и кортеж позиционных аргументов, что позволяет  хранить данные изолированно для каждой функции.
    *   **Декоратор:**
        * Принимает функцию как аргумент.
        *  Возвращает  функцию-обертку, которая выполняется при вызове декорированной функции.
    *  **Проверка:** Перед вызовом  декорируемой функции, происходит проверка  в словаре, что бы определить, был ли ранее вызов с теми же  параметрами.
     *  **Вывод сообщения:** Если  ключ  уже есть в словаре, то печатается  сообщение `"Функция с такими аргументами уже запускалась!"`  .
     *  **Сохранение состояния:**  Если ключа нету, то вызывается функция, и  записывается новый ключ в хеш-таблицу.

**Примеры (псевдокод):**

```
function RepeatDecorator(func):
    cache = new dictionary

    function wrapper(*args, **kwargs):
        key = (func.__name__, args) # create unique key (func name + args)
        if key is in cache:
            print that method with given args was called before
        else:
           cache[key] = True
            func(*args, **kwargs)
       
  return wrapper
```

**Примеры реализации в Python:**

```python
from functools import wraps
def RepeatDecorator(func):
    cache = {}
    @wraps(func)
    def wrapper(*args, **kwargs):
        key = (func.__name__, *args)
        if key in cache:
            print("Функция с такими аргументами уже запускалась!")
        else:
            cache[key] = True
        return func(*args, **kwargs)
    return wrapper

@RepeatDecorator
def func1(x, y):
    pass

@RepeatDecorator
def func2(x, y):
    pass
func1(1, 2)
# Ничего не выводится
func1(2, 1)
# Ничего не выводится
func1(3, 1)
# Ничего не выводится
func1(1, 2)
# Функция с такими аргументами уже запускалась!

func2(1, 2)
# Ничего не выводится, т.к. функция другая
func2(1, 2)
# Функция с такими аргументами уже запускалась!

```
**Разбор вариантов:**

*   **A. Для решения задачи нужно использовать только операторы сравнения и  условные операторы, и отслеживать параметры, переданные в функцию.:** Неправильно.
*    **B. Для решения задачи  нужно использовать вложенную функцию, и глобальную переменную,  чтобы сохранять значения параметров при вызове.:** Неправильно, глобальные переменные не позволят отслеживать параметры разных функций.
*    **C. Для решения задачи нужно использовать  словарь, в котором ключом будет кортеж аргументов и имя функции, и проверять, есть ли такой ключ.:** Правильно.
*   **D. Для решения задачи можно использовать только множество, и добавлять в него значения всех аргументов.:** Неправильно. Множество  не гарантирует, что разные аргументы в разном порядке не будут давать  один  результат.

**В результате:**
*   Использование словаря позволяет  отслеживать уникальность  вызова функции с  заданными  параметрами и  избежать повторного вызова.
*  Кортеж  позволяет  использовать аргументы  как ключ для словаря.
*   Декоратор  позволяет  реализовать данную  логику  без изменения кода декорируемых функций.

Таким образом, правильным ответом является **C. Для решения задачи нужно использовать словарь, в котором ключом будет кортеж аргументов и имя функции, и проверять, есть ли такой ключ.**
