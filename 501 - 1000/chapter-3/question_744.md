### `question_701.md`

**Вопрос 701.** Дана непустая строка `s`. Разработайте алгоритм на Python, который находит и возвращает все уникальные перестановки символов в строке `s`.

**Примеры:**

```
Ввод: s = "a"
Вывод: ["a"]

Ввод: s = "ab"
Вывод: ["ab", "ba"]

Ввод: s = "aabb"
Вывод: ["aabb", "abab", "abba", "baab", "baba", "bbaa"]
```

- A. Для решения задачи нужно использовать жадный алгоритм, и на каждом шаге переставлять только 2 символа.
-  B. Для решения задачи необходимо использовать рекурсивный алгоритм  с  бэктрекингом, для нахождения всех перестановок, избегая повторных комбинаций, с помощью  множества.
-   C. Для решения задачи необходимо использовать алгоритм поиска в ширину (BFS) для перебора всех возможных перестановок.
-  D.  Для решения задачи нужно использовать  только метод  перестановки элементов с помощью циклов.

**Правильный ответ: B**

**Объяснение:**

Для решения задачи нахождения всех уникальных перестановок символов в строке, оптимальным решением является применение рекурсивного алгоритма с использованием техники бэктрекинга. При использовании бэктрекинга  алгоритм позволяет  отследить все возможные варианты, а использование множества помогает избежать дубликатов.

*   **Алгоритм (рекурсивный с бэктрекингом):**
    1.  **Инициализация:** Создается множество `result` для хранения уникальных перестановок.
    2. **Рекурсивная функция:**
         *   Функция принимает текущую подстановку `current_combination`, неиспользованные символы `remaining` и результирующее множество `result`.
           *  **Базовый случай:** Если `remaining`  пустой (т.е. не осталось символов), добавляем   `current_combination` в `result`.
          *   **Перебор:** На каждом шагу итерируемся по  символам `remaining`:
              *  Устанавливаем текущий символ  `next_char`.
            *  Вызываем рекурсивную функцию,  где  `current_combination`  добавляется  `next_char`, а  `remaining`  становится строкой `remaining`  без текущего символа  `next_char`.
            *  **Бэктрекинг:** После вызова рекурсии, мы  убираем `next_char` из  `current_combination`.
    3.   **Начальный вызов:** Вызываем рекурсию со  значениями `""`, `s` и  `result`.
    4. **Результат:**  После завершения рекурсивного обхода, возвращаем  результат из  множества, преобразовав в список.

*   **Преимущества алгоритма:**
    *   **Генерация всех перестановок:**  Алгоритм перебирает все возможные перестановки символов в строке.
    *  **Бэктрекинг:**  Позволяет  отсекать неподходящие  пути и  управлять логикой перебора.
    *   **Множество для уникальности:** Множество `result`  гарантирует, что все перестановки будут уникальными, даже при повторяющихся символах.
    *   **Эффективность:**   Алгоритм  имеет сложность `O(n*n!)`.

**Примеры (псевдокод):**
```
function all_permutations_unique(s):
   result = new Set()
    function backtrack(current_permutation, remaining_chars):
       if remaining_chars is empty:
           add current_permutation to the result
           return
       for index from 0 to length(remaining_chars) -1:
           new_permutation = current_permutation + remaining_chars[index]
           new_remaining = remaining_chars without remaining_chars[index]
            backtrack(new_permutation, new_remaining)

    backtrack("",s)
    return convert set result to list
```

**Примеры реализации в Python:**
```python
def all_permutations_unique(s):
    result = set()
    def backtrack(current_combination, remaining_chars):
        if not remaining_chars:
            result.add("".join(current_combination))
            return

        for index, char in enumerate(remaining_chars):
            backtrack(current_combination + [char], remaining_chars[:index] + remaining_chars[index+1:])


    backtrack("", list(s))
    return list(result)

s1 = "a"
print(f"Ввод: s = '{s1}'")
print(f"Вывод: {all_permutations_unique(s1)}") # Выведет: Вывод: ['a']

s2 = "ab"
print(f"Ввод: s = '{s2}'")
print(f"Вывод: {all_permutations_unique(s2)}") # Выведет: Вывод: ['ab', 'ba']

s3 = "aabb"
print(f"Ввод: s = '{s3}'")
print(f"Вывод: {all_permutations_unique(s3)}") # Выведет: Вывод: ['aabb', 'abab', 'baba', 'abba', 'baab', 'bbaa']

```

**Разбор вариантов:**

*   **A. Для решения задачи нужно использовать жадный алгоритм, и на каждом шаге переставлять только 2 символа.:** Неправильно.
*   **B. Для решения задачи необходимо использовать рекурсивный алгоритм  с  бэктрекингом, для нахождения всех перестановок, избегая повторных комбинаций, с помощью  множества.:** Правильно.
*    **C. Для решения задачи необходимо использовать алгоритм поиска в ширину (BFS) для перебора всех возможных перестановок.:** Неправильно.
*  **D. Для решения задачи нужно использовать  только метод  перестановки элементов с помощью циклов.:** Неправильно.

**В результате:**
*   Рекурсивный алгоритм с бэктрекингом позволяет  сгенерировать все возможные комбинации.
*   Множество гарантирует, что все строки будут уникальными.
*   Алгоритм проходит все варианты, добавляя их в множество, при этом отсекая неподходящие варианты.

Таким образом, правильным ответом является **B. Для решения задачи необходимо использовать рекурсивный алгоритм  с  бэктрекингом, для нахождения всех перестановок, избегая повторных комбинаций, с помощью  множества.**
