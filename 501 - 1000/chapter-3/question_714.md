### `question_714.md`

**Вопрос 714.** Дан связный неориентированный граф (дерево) из `n` узлов, пронумерованных от `0` до `n - 1`, с корнем в узле `0`, и `n-1` ребрами. Дерево представлено массивом `edges` где `edges[i] = [a_i, b_i]`  означает, что есть ребро между узлами `a_i` и `b_i`. Каждый узел имеет метку, представленную символом из строки `labels`. Разработайте алгоритм для вычисления массива `result` размера `n`, где `result[i]` — количество узлов в поддереве узла `i`, имеющих ту же метку, что и узел `i`.

**Изображение дерева в ASCII:**

```
    0 ('a')
   /  \
  1 ('b')  2 ('a')
 /  \   / \
4 ('d') 5('c') 3('e') 6('d')
```
**Примеры:**
```
Ввод: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = "abaedcd"
Вывод: [2,1,1,1,1,1,1]

Ввод: n = 4, edges = [[0,1],[1,2],[0,3]], labels = "bbbb"
Вывод: [4,2,1,1]
```

-   A.  Для решения задачи необходимо отсортировать дерево и затем использовать поиск в ширину (BFS).
-  B. Для решения задачи нужно использовать обход в глубину (DFS),  при этом каждый вызов будет возвращать счетчик узлов, имеющих такое же значение.
-  C. Для решения задачи нужно использовать стек и обходить дерево в ширину (BFS), вычисляя и сохраняя результат для каждой поддерева.
-  D. Для решения задачи  нужно использовать бинарный поиск в сочетании с  динамическим программированием.

**Правильный ответ: B**

**Объяснение:**

Для решения задачи подсчета количества узлов с совпадающими метками в поддереве, оптимальным является использование алгоритма поиска в глубину (DFS). При этом при каждом рекурсивном вызове мы будем возвращать информацию о количестве совпадений, и увеличивать счетчики на каждом уровне.

*   **Алгоритм (рекурсивный DFS):**
    1.  **Создание графа:** На основе  массива `edges` создаем представление дерева, используя словарь, где ключами будут  узлы, а значениями - списки дочерних узлов.
    2.   **Рекурсивная функция:**
         *   Функция принимает текущий узел  и массив `result`,  где будет записываться кол-во совпадающих узлов.
         *    Вначале, устанавливаем начальное  значение счетчика для текущего узла как 1 (сам узел).
         *  **Итерация по дочерним узлам:**  Рекурсивно вызываем  функцию для каждого дочернего узла.
          *   **Проверка на соответствие:**  Если  значение дочернего узла  совпадает со значением текущего узла, увеличиваем счетчик.
         *  **Возврат счетчика:**  Возвращаем общее количество совпадающих узлов.
    3.  **Начальный вызов:** Вызываем рекурсивную функцию для корня (узел `0`).
    4.  **Возврат результата:**  После прохождения всех узлов возвращаем список  `result`.

*   **Преимущества алгоритма:**
    *   **Обход дерева:** Рекурсия позволяет легко обходить дерево в глубину.
    *   **Эффективность:** Достигает сложности `O(n)`, где `n` — количество узлов дерева.
    *   **Корректный подсчет:** Подсчитывает  узлы  с  совпадающей меткой в поддереве.
    *  **Простота:** Легко реализуемый алгоритм.

**Примеры (псевдокод):**

```
function find_subtree_counts(n, edges, labels):
    adj = create adjency list from edges
    result = new array[n] initialized with 0

    function dfs(node, result):
         count = 1 # начальное значение текущего узла
          for child in adj[node]:
              child_count = dfs(child)
               if labels[node] == labels[child]:
                    count += child_count
        result[node] = count
        return count
     dfs(0, result); # вызов рекурсии с корня
    return result
```
**Примеры реализации в Python:**
```python
def find_subtree_counts(n, edges, labels):
    adj = [[] for _ in range(n)]
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)

    result = [0] * n
    def dfs(node, parent):
      count = 1
      for child in adj[node]:
        if child != parent: # исключаем переход назад (к родителю)
          child_count = dfs(child, node)
          if labels[node] == labels[child]:
                count += child_count
      result[node] = count
      return count

    dfs(0, -1) # начало рекурсии с корня (0)
    return result


n1 = 7
edges1 = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]
labels1 = "abaedcd"
print(f"Ввод: n = {n1}, edges = {edges1}, labels = '{labels1}'")
print(f"Вывод: {find_subtree_counts(n1, edges1, labels1)}") # Выведет [2, 1, 1, 1, 1, 1, 1]

n2 = 4
edges2 = [[0,1],[1,2],[0,3]]
labels2 = "bbbb"
print(f"Ввод: n = {n2}, edges = {edges2}, labels = '{labels2}'")
print(f"Вывод: {find_subtree_counts(n2, edges2, labels2)}") # Выведет: [4, 2, 1, 1]
```

**Разбор вариантов:**
*  **A. Для решения задачи необходимо отсортировать дерево и затем использовать поиск в ширину (BFS).:** Неправильно, сортировка дерева не требуется.
*   **B. Для решения задачи можно использовать только поиск в глубину (DFS),  и при этом нужно возвращать  сумму длинн двух самых длинных путей, проходящих через узел.:** Правильно, но нужно возвращать кол-во узлов.
*   **C. Для решения задачи нужно использовать стек и обходить дерево в ширину (BFS), вычисляя и сохраняя результат для каждой поддерева.:** Неправильно. BFS не является наиболее эффективным способом обхода для этой задачи.
*   **D. Для решения задачи нужно использовать рекурсивный поиск в глубину (DFS), и при этом сохранять максимальную длину на каждом узле, рассматривая поддеревья.:** Правильно, но нужно сохранять не длину, а кол-во узлов с нужным значением.

**В результате:**
*  DFS  с рекурсией  и отслеживанием пройденных  узлов  позволяет эффективно решать поставленную задачу.
*  Алгоритм позволяет вычислить и сохранить  количество совпадений  на каждом узле.
*   Использование рекурсии является естественным решением  для обхода дерева и вычисление  значений в каждом поддереве.

Таким образом, правильным ответом является **B. Для решения задачи нужно использовать обход в глубину (DFS),  при этом каждый вызов будет возвращать счетчик узлов, имеющих такое же значение.**
