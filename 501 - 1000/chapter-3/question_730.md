### `question_730.md`

**Вопрос 730.** Разработайте функцию на Python, которая принимает на вход две квадратные матрицы (списки списков) и возвращает их сумму. Все элементы матриц — целые числа. Реализуйте алгоритм без использования библиотеки `numpy` и метода `matrix.sum()`.

**Примеры:**
```
Ввод: 
matrixAddition([ [1, 2, 3], [3, 2, 1], [1, 1, 1] ], [[2, 2, 1], [3, 2, 3], [1, 1, 3]])
Вывод: [[3, 4, 4], [6, 4, 4], [2, 2, 4]]

```

-  A.  Для решения задачи нужно просто перебрать все элементы матриц и поочередно сложить их.
-  B.  Для решения задачи необходимо использовать рекурсивный алгоритм и складывать элементы по диагонали.
-   C.  Для решения задачи нужно использовать алгоритм  с двумя циклами, где значения  элементов с одинаковыми индексами в матрицах  складываются, и записываются в новую матрицу.
-   D. Для решения задачи нужно предварительно отсортировать обе матрицы, а затем складывать их.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи сложения двух матриц, нужно использовать итеративный алгоритм с двумя вложенными циклами, который будет проходить по каждой ячейке матриц и складывать соответствующие элементы, создавая при этом новый список.

*   **Алгоритм (итеративный с вложенными циклами):**
    1.   **Размерность матриц:**  Проверяем, что матрицы имеют одинаковую размерность.
     2. **Создание результирующей матрицы:**  Создаем новую матрицу `result`, с той же размерностью что и исходные матрицы, которую мы будем заполнять  по мере вычисления суммы элементов.
    3.  **Вложенные циклы:**  Проходим по каждой строке  и по каждому столбцу  матриц с помощью  двух циклов  `for`:
         *  Складываем  элементы на текущих индексах `[row][col]`  из обеих матриц и записываем их сумму  в результирующую матрицу `result[row][col]`.
    4. **Возврат результата:** После прохождения всех элементов, возвращаем  результирующую матрицу `result`.

*   **Преимущества алгоритма:**
     *   **Простота:**  Код  легок в реализации и  понимании.
     *   **Эффективность:**  Имеет линейную временную сложность `O(n^2)` (где n - размер стороны квадратной матрицы), и  не использует дополнительную память.

**Примеры (псевдокод):**
```
function matrix_addition(matrix1, matrix2):
  result = create a matrix with the same dimensions as matrix1 and zeroed out

  for i from 0 to the number of rows in matrix1:
    for j from 0 to number of cols in matrix1:
       result[i][j] = matrix1[i][j] + matrix2[i][j]
  return result;
```
**Примеры реализации в Python:**

```python
def matrix_addition(matrix1, matrix2):
    rows = len(matrix1)
    cols = len(matrix1[0])
    result = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            result[i][j] = matrix1[i][j] + matrix2[i][j]
    return result

matrix1 = [ [1, 2, 3],
            [3, 2, 1],
            [1, 1, 1] ]

matrix2 = [[2, 2, 1],
           [3, 2, 3],
           [1, 1, 3] ]

print(f"Ввод: matrix1 = {matrix1}, matrix2 = {matrix2}")
print(f"Вывод: {matrix_addition(matrix1,matrix2)}")

```
**Разбор вариантов:**
*   **A. Для решения задачи нужно просто перебрать все элементы матриц и поочередно сложить их.:** Неправильно.
*   **B. Для решения задачи необходимо использовать рекурсивный алгоритм и складывать элементы по диагонали.:** Неправильно. Рекурсивный алгоритм не является оптимальным для этой задачи.
*   **C. Для решения задачи нужно использовать алгоритм с двумя циклами, где значения  элементов с одинаковыми индексами в матрицах  складываются, и записываются в новую матрицу.:** Правильно.
*   **D. Для решения задачи нужно предварительно отсортировать обе матрицы, а затем складывать их.:** Неправильно. Сортировка не нужна.

**В результате:**
*   Два вложенных цикла позволяют перебрать все элементы в двухмерном массиве.
*   Алгоритм  вычисляет сумму для каждой пары элементов  и формирует новый результирующий массив.
*  Алгоритм имеет сложность O(n*n) или O(n^2).

Таким образом, правильным ответом является **C. Для решения задачи нужно использовать алгоритм с двумя циклами, где значения  элементов с одинаковыми индексами в матрицах  складываются, и записываются в новую матрицу.**
