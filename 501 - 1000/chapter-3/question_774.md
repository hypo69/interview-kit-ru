### `question_774.md`

**Вопрос 774.** Дан целочисленный массив `nums`, который отсортирован в порядке возрастания, а затем сдвинут относительно неизвестного опорного элемента, то есть он может иметь вид `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`. Разработайте алгоритм на Python для поиска индекса заданного целого числа `target` в массиве `nums` за время O(log n),  или верните `-1` если элемент отсутствует.

**Примеры:**

```
Ввод: nums = [4,5,6,7,0,1,2], target = 0
Вывод: 4
Объяснение: Элемент 0 находится на индексе 4.

Ввод: nums = [4,5,6,7,0,1,2], target = 3
Вывод: -1
Объяснение:  Элемент 3 не найден.
```

-   A.  Для решения задачи нужно использовать линейный поиск, и по очереди проверять все элементы.
-   B. Для решения задачи необходимо использовать алгоритм сортировки, и затем применить бинарный поиск.
-   C. Для решения задачи нужно использовать бинарный поиск, но при этом учитывать, что массив отсортирован только частично и проверять по какому принципу отсортирована подпоследовательность.
-  D. Для решения задачи подходит только метод `index()` ,  который сразу возвращает значение, если оно есть, и  выдаёт ошибку, если значения нет.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи поиска элемента в частично отсортированном массиве с временной сложностью `O(log n)`, наиболее подходящим является адаптация алгоритма бинарного поиска, учитывая возможность наличия сдвига массива.

*   **Алгоритм (адаптированный бинарный поиск):**
    1.  **Инициализация границ:**  Устанавливаем указатель на левую  границу  `left = 0` и  на правую границу  `right`  на конец массива `len(nums)-1`.
    2.  **Бинарный поиск:**  Пока  левая граница не превышает правую:
         *   Вычисляем середину массива: `mid = left + (right-left) // 2`
           *   **Целевое значение:** Если  значение в середине `nums[mid]`  равно целевому  `target`, то  возвращаем  индекс `mid`.
           *   **Правая часть отсортирована:** Проверяем, отсортирована ли правая половина массива  `nums[mid] <= nums[right]`.
              *  Если да:
                   *  если `target` находится в правой половине, то переходим в правую половину  `left = mid + 1`.
                   *  иначе -  переходим в левую половину `right = mid - 1`.
        * **Левая часть отсортирована:**  Если правая часть не отсортирована, то левая точно отсортирована.
             * Если  `target`  находится в левой половине, то переходим в левую половину `right = mid - 1`.
          *   иначе - переходим в правую половину `left = mid + 1`.
    3. **Результат:**  После завершения цикла,  если  элемент не найден, то возвращаем  `-1`.

*   **Преимущества алгоритма:**
    *   **Логарифмическая сложность:** Обеспечивает временную сложность O(log n), так как  размер области поиска  сокращается в 2 раза на каждом шаге.
    *  **Обработка сдвига:** Учитывает частичную отсортированность массива.

**Примеры (псевдокод):**
```
function search_rotated_array(nums, target):
     left = 0
    right = length(nums) - 1

    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target
             return mid;
        if nums[mid] <= nums[right]:
          if  target >= nums[mid] and target <= nums[right]:
                left = mid + 1;
            else:
                right = mid - 1;
       else:
            if  target >= nums[left] and target < nums[mid]:
                right = mid - 1;
           else
               left = mid + 1
    return -1;
```
**Примеры реализации в Python:**

```python
def search_rotated_array(nums, target):
    left = 0
    right = len(nums) - 1

    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] <= nums[right]:
           if target >= nums[mid] and target <= nums[right]:
               left = mid + 1
           else:
               right = mid - 1

        else:
            if target >= nums[left] and target < nums[mid]:
               right = mid - 1
            else:
                left = mid + 1
    return -1

nums1 = [4, 5, 6, 7, 0, 1, 2]
target1 = 0
print(f"Ввод: nums = {nums1}, target = {target1}")
print(f"Вывод: {search_rotated_array(nums1, target1)}")   # Выведет: Вывод: 4

nums2 = [4,5,6,7,0,1,2]
target2 = 3
print(f"Ввод: nums = {nums2}, target = {target2}")
print(f"Вывод: {search_rotated_array(nums2, target2)}") #  Выведет: Вывод: -1

nums3 = [1,2,3]
target3 = 2
print(f"Ввод: nums = {nums3}, target = {target3}")
print(f"Вывод: {search_rotated_array(nums3, target3)}")   # Выведет: Вывод: 1

nums4 = [5, 1, 2, 3, 4]
target4 = 3
print(f"Ввод: nums = {nums4}, target = {target4}")
print(f"Вывод: {search_rotated_array(nums4, target4)}") # Выведет: Вывод: 3
```

**Разбор вариантов:**
* **A. Для решения задачи нужно использовать линейный поиск, и по очереди проверять все элементы.:** Неправильно.  Это не обеспечит  нужную  сложность.
*   **B. Для решения задачи необходимо использовать алгоритм сортировки, и затем применить бинарный поиск.:** Неправильно. Сортировка  имеет большую сложность, а  бинарный поиск, при  этом не гарантируется, что будет верный результат.
*  **C. Для решения задачи нужно использовать бинарный поиск, но при этом учитывать, что массив отсортирован только частично и проверять по какому принципу отсортирована подпоследовательность.:** Правильно.
*   **D. Для решения задачи подойдет только метод `index()` ,  который сразу возвращает значение, если оно есть, и  выдаёт ошибку, если значения нет.:** Неправильно. `index()` не работает за O(log n).

**В результате:**
*   Адаптированный бинарный поиск позволяет эффективно искать  значения в частично отсортированном массиве.
*   Алгоритм  имеет  сложность  `O(log n)`.
*   Алгоритм  позволяет обрабатывать  разные случаи  отсортированности списка, и при этом  правильно  находить индекс нужного элемента.

Таким образом, правильным ответом является **C. Для решения задачи нужно использовать бинарный поиск, но при этом учитывать, что массив отсортирован только частично и проверять по какому принципу отсортирована подпоследовательность.**
