### `question_684.md`

**Вопрос 684.** Дан массив символов `chars`. Реализуйте алгоритм сжатия массива, следуя правилу: для каждой группы последовательных повторяющихся символов:

*   Если длина группы равна 1, добавьте символ в сжатую строку.
*   Если длина группы больше 1, добавьте символ, за которым следует длина группы.

Сжатая строка должна быть сохранена во входном массиве `chars`. Верните новую длину массива после сжатия. Требование к алгоритму - использование только постоянной дополнительной памяти.

**Пример:**

```
Ввод: chars = ["a","a","b","b","c","c","c"]
Вывод: 6, и первые 6 элементов массива chars должны быть: ["a","2","b","2","c","3"]

Ввод: chars = ["a"]
Вывод: 1, и первые 1 элементы массива chars должны быть: ["a"]

Ввод: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
Вывод: 4, и первые 4 элемента должны быть: ["a", "b", "1", "2"]
```

-   A.  Для решения этой задачи необходима  рекурсия и  дополнительная память O(n).
-  B.  Для решения этой задачи нужно проитерироваться по входному списку, собирая повторяющиеся символы и  сохраняя результат во временном списке, а в конце заменить исходный список, и вернуть его длину.
- C. Для решения этой задачи можно использовать два указателя, для отслеживания начала и конца последовательности повторяющихся символов,  и модифицировать исходный список на месте, при этом дополнительной памяти не будет требоваться.
- D. Для решения этой задачи нужно использовать хэш таблицу для запоминания  значений и количество их повторений.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи сжатия массива символов на месте с временной сложностью O(n) и постоянной пространственной сложностью O(1) можно использовать метод двух указателей.

*  **Алгоритм с двумя указателями:**
    *  **Указатель `read`:**  Используется для чтения символов из исходного списка.
    *  **Указатель `write`:** Используется для записи сжатых данных в исходный список.
    *  **Перебор:** Перебираются символы, пока не достигнут конец списка, начиная с  `read=0`.
     *  **Поиск последовательности:**  Пока  `read` указывает на начало последовательности одинаковых символов.
      * **Подсчет повторений:** Считаем количество повторений текущего символа.
       *  **Запись в сжатый массив:**  Если повторения были, то  записываем в результирующий массив сам символ, и затем количество повторений (если они больше 1).
        *   **Переход:** Двигаем  `read` до следующего уникального символа.

* **Преимущества алгоритма:**
     *  **Постоянная память:** Использует постоянный объем дополнительной памяти, поскольку изменяет исходный массив (in place).
     *  **Линейная сложность:** Алгоритм проходит по массиву один раз, поэтому временная сложность равна O(n).

**Примеры (псевдокод):**
```
function compress_string(chars):
    read = 0
    write = 0
    while read < length(chars):
        start = read
        while read < length(chars) and chars[start] == chars[read]:
            read +=1
        chars[write] = chars[start]
        write+=1
        if read - start > 1:
          count = str(read-start)
          for char in count:
              chars[write] = char
              write+=1
    return write
```
**Примеры реализации в Python:**
```python
def compress_string(chars):
    write = 0
    read = 0
    while read < len(chars):
        start = read
        while read < len(chars) and chars[start] == chars[read]:
            read += 1
        chars[write] = chars[start]
        write += 1
        if read - start > 1:
            count = str(read - start)
            for char in count:
               chars[write] = char
               write += 1
    return write


chars1 = ["a","a","b","b","c","c","c"]
length1 = compress_string(chars1)
print(f"Уменьшенный список {chars1[:length1]}, длинна {length1}")  # Выведет: Уменьшенный список ['a', '2', 'b', '2', 'c', '3'], длинна 6

chars2 = ["a"]
length2 = compress_string(chars2)
print(f"Уменьшенный список {chars2[:length2]}, длинна {length2}")  # Выведет: Уменьшенный список ['a'], длинна 1


chars3 = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
length3 = compress_string(chars3)
print(f"Уменьшенный список {chars3[:length3]}, длинна {length3}") # Выведет: Уменьшенный список ['a', 'b', '1', '2'], длинна 4
```

**Разбор вариантов:**
*   **A. Для решения этой задачи необходима  рекурсия и  дополнительная память O(n).:** Неправильно.
*   **B. Для решения этой задачи нужно проитерироваться по входному списку, собирая повторяющиеся символы и  сохраняя результат во временном списке, а в конце заменить исходный список, и вернуть его длину.:** Неправильно, этот метод требует дополнительную память.
*   **C. Для решения этой задачи можно использовать два указателя, для отслеживания начала и конца последовательности повторяющихся символов,  и модифицировать исходный список на месте, при этом дополнительной памяти не будет требоваться.:** Правильно.
*   **D. Для решения этой задачи нужно использовать хэш таблицу для запоминания  значений и количество их повторений.:** Неправильно. Хеш-таблица  не является оптимальным решением.

**В результате:**
*   Метод двух указателей позволяет сжать строку "in-place" (без выделения дополнительной памяти).
*   Сложность алгоритма равна O(n), поскольку  проходимся по массиву один раз.

Таким образом, правильным ответом является **C. Для решения этой задачи можно использовать два указателя, для отслеживания начала и конца последовательности повторяющихся символов, и  модифицировать исходный список на месте, при этом дополнительной памяти не будет требоваться.**
