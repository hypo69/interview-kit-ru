### `question_672.md`

**Вопрос 672.** Что такое Method Resolution Order (MRO) в Python и какова его цель?

-   A. Method Resolution Order (MRO) — это порядок, в котором методы вызываются при рекурсивных вызовах функций.
-   B. Method Resolution Order (MRO) — это порядок, в котором методы объявлены в классе, и при вызове используется порядок объявления.
-  C. Method Resolution Order (MRO) — это порядок, в котором Python ищет методы при множественном наследовании и определяет, как интерпретатор разрешает вызовы методов при наследовании.
-  D. Method Resolution Order (MRO) - это порядок, в котором переменные обьявляются внутри класса.

**Правильный ответ: C**

**Объяснение:**

Method Resolution Order (MRO) в Python — это порядок, в котором интерпретатор языка ищет методы при множественном наследовании (когда класс наследуется от нескольких родительских классов). MRO определяет, как Python разрешает вызовы методов, особенно если в родительских классах встречаются методы с одинаковыми именами.

*   **Основные цели MRO:**
    *   **Разрешение конфликтов:**  Обеспечивает правильный порядок поиска методов в иерархии классов, и когда разные классы имеют методы с одинаковым именем.
    *   **Предсказуемое поведение:** Гарантирует предсказуемый порядок вызовов методов, делая код более надежным.
    *   **Управление множественным наследованием:** Позволяет эффективно использовать множественное наследование.

*   **C3 линеаризация:**
    *  **Алгоритм:**  Python использует алгоритм C3 линеаризации, который является наиболее распространенным и  используется  по умолчанию.
    *  **Гарантии:** C3 гарантирует, что  при следовании MRO будут учитываться все исходные порядки, сохраняя при этом их локальный порядок.
    *  **Определение:**  C3 алгоритм строит MRO, сохраняя все правила наследования и исключая возможную неоднозначность.

*  **Как MRO работает:**
    *    Когда вызывается метод у объекта, Python проверяет  иерархию классов (наследованных от базовых классов) в порядке MRO, пока не найдет метод, удовлетворяющий  запросу.

**Примеры:**

```python
# Пример 1: Простая иерархия наследования (одиночное наследование)
class A:
    def method(self):
        print("Method of A")

class B(A):
    def method(self):
        print("Method of B")

b = B()
b.method()  # Выведет: Method of B (вызывается метод из дочернего класса)

# Пример 2: Множественное наследование (проблема ромба)

class A2:
    def method2(self):
        print("Method of A")

class B2(A2):
    def method2(self):
        print("Method of B")
class C2(A2):
    pass
class D2(B2, C2): #множественное наследование
    pass

d = D2()
d.method2() #  Method of B (за счет MRO, метод из класса B находится раньше)

print(D2.__mro__)

# Пример 3: Использование super() для вызова родительских методов
class Base:
    def hello(self):
       print("Hello from Base")
class Mixin(Base):
    def hello(self):
      super().hello() # Вызов родительского метода
      print("Hello from Mixin")

class MyClass(Mixin):
   def hello(self):
      super().hello()
      print("Hello from MyClass")

MyClass().hello()
# Выведет:
# Hello from Base
# Hello from Mixin
# Hello from MyClass
```

**Разбор вариантов:**

*   **A. Method Resolution Order (MRO) — это порядок, в котором методы вызываются при рекурсивных вызовах функций.:** Неправильно.
*  **B. Method Resolution Order (MRO) — это порядок, в котором методы объявлены в классе, и при вызове используется порядок объявления.:** Неправильно.
*   **C. Method Resolution Order (MRO) — это порядок, в котором Python ищет методы при множественном наследовании и определяет, как интерпретатор разрешает вызовы методов при наследовании.:** Правильно.
*  **D. Method Resolution Order (MRO) - это порядок, в котором переменные обьявляются внутри класса.:** Неправильно.

**В результате:**
*   MRO  обеспечивает предсказуемый и понятный поиск методов.
*   MRO  является важным для понимания принципов работы множественного наследования.
*  Python  по умолчанию использует  алгоритм C3 линеаризации.

Таким образом, правильным ответом является **C. Method Resolution Order (MRO) — это порядок, в котором Python ищет методы при множественном наследовании и определяет, как интерпретатор разрешает вызовы методов при наследовании.**
