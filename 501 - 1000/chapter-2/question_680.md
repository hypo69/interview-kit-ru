### `question_680.md`

**Вопрос 680.** Разработайте алгоритм для сортировки массива целых чисел `nums` в порядке возрастания с временной сложностью O(n log n) и с наименьшей возможной пространственной сложностью, не используя при этом встроенные функции для сортировки.

**Примеры:**
```
Ввод: nums = [5,2,3,1]
Вывод: [1,2,3,5]

Ввод: nums = [5,1,1,2,0,0]
Вывод: [0,0,1,1,2,5]
```

-  A.  Для решения этой задачи можно использовать алгоритм сортировки пузырьком.
-  B.  Для решения этой задачи можно использовать алгоритм сортировки вставками.
-  C. Для решения этой задачи можно использовать алгоритм сортировки выбором.
-   D. Для решения этой задачи можно использовать алгоритм сортировки слиянием (Merge Sort), который имеет временную сложность O(n log n) и не использует много дополнительной памяти.

**Правильный ответ: D**

**Объяснение:**

Для решения задачи сортировки массива целых чисел в порядке возрастания с временной сложностью O(n log n) без использования встроенных функций сортировки, подходящим алгоритмом является сортировка слиянием (Merge Sort).

*   **Сортировка слиянием (Merge Sort):**
    *   **Принцип "разделяй и властвуй":** Разделяет список на две половины, пока не останутся списки из 1 элемента, а затем рекурсивно объединяет отсортированные списки.
    *   **Временная сложность:** Имеет временную сложность O(n log n) в худшем, среднем и лучшем случаях.
    *  **Устойчивость:** Сохраняет порядок одинаковых элементов.
    *  **Рекурсия:** Основан на рекурсивном вызове самого себя.

*   **Почему другие варианты не подходят:**
     *   **Сортировка пузырьком (Bubble Sort), вставками (Insertion Sort), и выбором (Selection Sort):** Имеют временную сложность O(n^2) в худшем и среднем случаях, что делает их неэффективными для больших наборов данных.

**Примеры (псевдокод):**

```
function merge_sort(arr):
    if length(arr) <= 1:
        return arr
    mid = length(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    left = merge_sort(left)
    right = merge_sort(right)
    return merge(left, right)
function merge(left, right):
    merged = []
    i = 0
    j = 0
    while i < length(left) and j < length(right):
        if left[i] < right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged
```

**Примеры реализации в Python:**
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    left = merge_sort(left)
    right = merge_sort(right)
    return merge(left, right)

def merge(left, right):
    merged = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged

print(merge_sort([5,2,3,1])) # Выведет: [1, 2, 3, 5]
print(merge_sort([5,1,1,2,0,0])) # Выведет: [0, 0, 1, 1, 2, 5]
```

**Разбор вариантов:**
*   **A. Для решения этой задачи можно использовать алгоритм сортировки пузырьком.:** Неправильно.
*   **B. Для решения этой задачи можно использовать алгоритм сортировки вставками.:** Неправильно.
*  **C. Для решения этой задачи можно использовать алгоритм сортировки выбором.:** Неправильно.
*   **D. Для решения этой задачи можно использовать алгоритм сортировки слиянием (Merge Sort), который имеет временную сложность O(n log n) и не использует много дополнительной памяти.:** Правильно.

**В результате:**
*   Алгоритм сортировки слиянием (Merge Sort) является эффективным для сортировки массива с временной сложностью O(n log n).
*   Алгоритм  реализуется рекурсивно и использует принцип "разделяй и властвуй".

Таким образом, правильным ответом является **D. Для решения этой задачи можно использовать алгоритм сортировки слиянием (Merge Sort), который имеет временную сложность O(n log n) и не использует много дополнительной памяти.**
