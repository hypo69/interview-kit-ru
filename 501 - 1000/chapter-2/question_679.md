### `question_679.md`

**Вопрос 679.** На рисунке представлено бинарное дерево поиска (BST), которое используется для игры "Угадай число". Разработайте алгоритм для поиска загаданного числа, используя бинарный поиск, и реализуйте API, который возвращает:

-   `-1`, если загаданное число больше выбранного.
-   `1`, если загаданное число меньше выбранного.
-   `0`, если загаданное число и выбранное совпадают.

**Изображение дерева в ASCII:**

```
      7
     / \
    3   9
   / \ / \
  1  5  8  10
   \   / \
    2 4   6
```
* **Условие задачи:** Вам дано бинарное дерево поиска. Вы выбираете число и затем на основе сравнения с загаданным числом, алгоритм говорит вам,  что загаданное число больше или меньше, и нужно отгадать это число.
*  **Интерфейс:**
   * Алгоритм должен уметь принимать номер числа и возвращать:
   *  `-1`: если загаданное число больше выбранного.
   *  `1`:  если загаданное число меньше выбранного.
   *  `0`: если загаданное число и выбранное совпали.
* **Вход:** `n = 10, pick = 6`
* **Вывод:** `6`

-   A. Необходимо перебрать все узлы дерева в порядке возрастания, пока не найдем искомое число.
-   B. Для поиска загаданного числа нужно использовать алгоритм поиска в глубину (DFS).
-   C. Для поиска загаданного числа нужно использовать алгоритм поиска в ширину (BFS).
-   D. Для поиска загаданного числа нужно использовать алгоритм бинарного поиска, что позволяет исключить узлы, которые не являются кандидатами на искомое значение, в зависимости от результатов сравнения.

**Правильный ответ: D**

**Объяснение:**

Использование бинарного дерева поиска (BST) и алгоритма бинарного поиска является оптимальным способом для поиска загаданного числа в этой задаче, поскольку позволяет отсеивать ненужные узлы на каждом этапе и имеет логарифмическую временную сложность O(log n).

*   **Алгоритм (бинарный поиск):**
    1.  **Начало:** Начинаем поиск с корня дерева (узла `7` в примере).
    2.  **Сравнение с загаданным числом:** Сравниваем текущее значение узла с загаданным числом `pick`.
    3. **Меньше:** Если текущее значение узла больше загаданного числа, переходим в левое поддерево.
    4.  **Больше:** Если текущее значение узла меньше загаданного числа, переходим в правое поддерево.
    5.  **Совпадение:** Если текущее значение узла равно загаданному числу, поиск завершен и возвращаем текущее значение.
    6.  **Повторение:**  Продолжаем шаги 2-5, пока не найдем загаданное число, или пока не  дойдем до узла, у которого нет детей, и тогда возвращаем `-1`.

*   **Реализация API:**
    *   API должен принимать число (узел, который нужно проверить) и сравнивать с загаданным числом.
    *   В зависимости от сравнения, API возвращает `-1`, `1` или `0`.

*  **Почему не подходят другие варианты:**
   *     **Вариант А**  -  линейный обход дерева -  неэффективен, так как не использует свойств дерева поиска и имеет сложность  `O(n)`.
    *   **Вариант B и C** - алгоритмы обхода дерева  в глубину или ширину  являются неэффективными для данной задачи и также имеют сложность  `O(n)`.

**Примеры (псевдокод):**

```
function guess_number(root, pick)
    current_node = root

    while current_node is not None:
        if current_node.val == pick:
            return current_node.val  # Найдено
        if pick < current_node.val:
            current_node = current_node.left
        elif pick > current_node.val:
            current_node = current_node.right

    return -1
function check_number(number_to_check,  pick):
  if number_to_check > pick:
        return -1
    elif number_to_check < pick:
         return 1
    else:
         return 0

```
**Разбор вариантов:**
*   **A. Необходимо перебрать все узлы дерева в порядке возрастания, пока не найдем искомое число.:** Неправильно, для этого используется бинарный поиск.
*   **B. Для поиска загаданного числа нужно использовать алгоритм поиска в глубину (DFS).:** Неправильно, поскольку DFS является не самым оптимальным алгоритмом для поиска в BST.
*  **C. Для поиска загаданного числа нужно использовать алгоритм поиска в ширину (BFS).:** Неправильно, поскольку BFS является не самым оптимальным алгоритмом для поиска в BST.
*   **D. Для поиска загаданного числа нужно использовать алгоритм бинарного поиска, что позволяет исключить узлы, которые не являются кандидатами на искомое значение, в зависимости от результатов сравнения.:** Правильно.

**В результате:**
*   Бинарный поиск позволяет эффективно искать искомый элемент в бинарном дереве, которое является отсортированным (BST).
*  Алгоритм имеет временную сложность  O(log n), вместо O(n) у полного обхода.
*  Метод сравнения элементов на каждом шаге позволяет отбросить неподходящую часть дерева.

Таким образом, правильным ответом является **D. Для поиска загаданного числа нужно использовать алгоритм бинарного поиска, что позволяет исключить узлы, которые не являются кандидатами на искомое значение, в зависимости от результатов сравнения.**
