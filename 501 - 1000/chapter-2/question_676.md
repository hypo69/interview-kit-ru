### `question_676.md`

**Вопрос 676.** Вам даны `n` городов, соединенных определенным количеством рейсов. Массив `flights`, где `flights[i] = [from_i, to_i, price_i]`, означает, что есть рейс из города `from_i` в город `to_i` со стоимостью `price_i`. Даны также три целых числа `src`, `dst` и `k`. Опишите алгоритм, для поиска самой дешевой стоимости перелета из города `src` в город `dst` не более чем с `k` пересадками. Если такого маршрута не существует, вернуть `-1`.

**Пример:**

```
Ввод: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1
Вывод: 700

Ввод: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
Вывод: 200
```

-   A. Решить эту задачу невозможно.
-  B. Для поиска самого дешевого пути можно использовать алгоритм Дейкстры (Dijkstra), и алгоритм BFS (Breadth-First Search) с ограничением на количество остановок.
-   C. Для поиска самого дешевого пути можно использовать только алгоритм поиска в глубину (DFS).
-   D.  Для решения данной задачи подходит только алгоритм поиска в ширину (BFS).

**Правильный ответ: B**

**Объяснение:**

Задача поиска кратчайшего пути между двумя вершинами в графе с ограничением на количество промежуточных узлов может быть решена с использованием комбинации алгоритма поиска в ширину (BFS) и принципов динамического программирования.

*   **Алгоритм (комбинация BFS и динамического программирования):**
    1.  **Инициализация:**
         *  Создается словарь для отслеживания стоимости перелета до каждого города,  изначально  цена равна  бесконечности, кроме стартовой точки (`src`), у которой  цена равна 0.
         * Создается очередь `queue` для BFS, в которой на первом шаге будет только стартовая точка `src` и число пересадок = `0`.
    2. **Поиск в ширину:**
      *  Обходим все маршруты,  пока очередь не станет пустой.
      *  На каждом шаге извлекаем текущий город  `from_city` и количество пересадок `stops`.
      *   **Проверка на остановку:** Если количество пересадок превышает `k`, то пропускаем этот путь.
      *  **Соседние города:**  Ищем все соседние города  `to_city`, в которые можно попасть из `from_city`.
      *   **Обновление стоимости:**  Рассчитываем стоимость перелета  и сравниваем с уже сохраненной стоимостью перелета для города `to_city`, и сохраняем меньшую.
     *   **Добавление в очередь:**   Добавляем  `to_city` в очередь если число пересадок  не превышает `k`.
    3.  **Результат:** После обхода всего графа, если стоимость перелета до пункта назначения (`dst`) отлична от бесконечности, возвращаем ее, иначе возвращаем `-1`.

*   **Почему не подходит Dijkstra:**
    *   Алгоритм Дейкстры предназначен для поиска кратчайшего пути с минимальной стоимостью, и не предназначен для работы с ограничением на количество пересадок.

*   **Почему BFS лучше DFS:**
     *   DFS  может зайти в неправильный путь, проходя его глубоко, прежде чем вернуться, в то время как BFS будет обходить все варианты с минимальным кол-вом пересадок.

**Примеры (псевдокод):**

```
function find_cheapest_price(n, flights, src, dst, k):
    distances = {city: infinity for city in range(n)}
    distances[src] = 0
    queue = [(src, 0)]  # (city, stops)
    while queue is not empty:
        from_city, stops = queue.pop(0)
        if stops > k:
            continue
        for from_i, to_i, price in flights:
            if from_i == from_city:
              if distances[to_i] > distances[from_city] + price:
                distances[to_i] = distances[from_city] + price
                queue.append((to_i, stops +1))

    if distances[dst] is not infinity:
        return distances[dst]
    else:
        return -1
```

**Разбор вариантов:**
*   **A. Решить эту задачу невозможно.:** Неправильно.
*  **B. Для поиска самого дешевого пути можно использовать алгоритм Дейкстры (Dijkstra), и алгоритм BFS (Breadth-First Search) с ограничением на количество остановок.:** Правильно, но алгоритм Дейкстры сам по себе не подходит для  такой задачи.
*  **C. Для поиска самого дешевого пути можно использовать только алгоритм поиска в глубину (DFS).:** Неправильно. DFS не самый оптимальный подход.
*   **D.  Для решения данной задачи подходит только алгоритм поиска в ширину (BFS).:** Неправильно. BFS в данном случае можно использовать, но требуется также логика с ограничением на число остановок и динамическим программированием для выбора оптимального маршрута.

**В результате:**
*   Данную задачу можно решить с использованием алгоритма BFS c ограничением на число пересадок.
*  Алгоритм Дейкстры сам по себе не подходит для этой задачи.
*  Также используется динамическое программирование.

Таким образом, правильным ответом является **B. Для поиска самого дешевого пути можно использовать алгоритм Дейкстры (Dijkstra), и алгоритм BFS (Breadth-First Search) с ограничением на количество остановок.**
