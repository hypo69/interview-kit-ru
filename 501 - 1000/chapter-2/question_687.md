### `question_678.md`

**Вопрос 678.** Разработайте алгоритм, который принимает на вход две строки (`text1` и `text2`) и возвращает длину их наибольшей общей подпоследовательности (LCS, longest common subsequence).

*   **Подпоследовательность:** Совокупность символов, не обязательно смежных, идущих слева направо в том же порядке, что и в исходной строке.

**Примеры:**

```
Ввод: text1 = "abcde", text2 = "ace"
Вывод: 3
Объяснение: "ace" является LCS

Ввод: text1 = "abc", text2 = "def"
Вывод: 0
```

-   A. Для решения задачи можно использовать алгоритм поиска в глубину (DFS).
-   B. Для решения этой задачи можно использовать жадный алгоритм, сравнивая символы по очереди.
-   C. Для решения задачи можно использовать алгоритм  динамического программирования, который строит таблицу, отражающую длины LCS для всех возможных подстрок.
-   D. Для решения задачи можно использовать бинарный поиск.

**Правильный ответ: C**

**Объяснение:**

Задача поиска наибольшей общей подпоследовательности (LCS, Longest Common Subsequence) — это классическая задача, решаемая с использованием динамического программирования (dynamic programming). Этот метод позволяет разбить задачу на меньшие подзадачи, переиспользуя результаты предыдущих вычислений.

*   **Алгоритм (динамическое программирование):**
    1.  **Создание таблицы:** Создается таблица `dp` размером `(len(text1) + 1) x (len(text2) + 1)`, где  `dp[i][j]` будет хранить длину наибольшей общей подпоследовательности для подстрок `text1[:i]` и `text2[:j]`.
    2.   **Инициализация:** Первая строка и первый столбец таблицы заполняются нулями, так как общая подпоследовательность  пустой строки с любой строкой  всегда равна `0`.
    3.  **Заполнение таблицы:**
           *   Итерируемся по строкам и столбцам таблицы, начиная с индекса `1`.
           *   Если `text1[i - 1] == text2[j - 1]`, то есть текущие символы совпадают, то   `dp[i][j] = dp[i - 1][j - 1] + 1` (длина LCS равна длине LCS предыдущих строк + 1).
          *   Если символы не совпадают, то `dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])` (максимальное значение между LCS из  `text1[:i-1]` и  `text2[:j]`  или `text1[:i]` и `text2[:j-1]`).
    4.  **Результат:** Длина LCS для строк `text1` и `text2` хранится в ячейке `dp[len(text1)][len(text2)]`.
    *    После построения всей таблицы возвращаем  значение из последней ячейки таблицы `dp[len(text1)][len(text2)]`

* **Преимущества алгоритма динамического программирования:**
     *  **Оптимальное решение:** Гарантирует нахождения наиболее оптимального решения.
    *   **Эффективность:** Имеет временную сложность O(m*n), где m и n — длины строк `text1` и `text2`.
     *   **Избежание повторных вычислений:** Использует  ранее вычисленные значения для нахождения  длинных общих подпоследовательностей.

*   **Почему другие подходы не подходят:**
    *   **DFS:** DFS может заходить в неоптимальные пути и имеет большую сложность.
    *   **Жадный алгоритм:** Жадные алгоритмы не гарантируют нахождения оптимального решения для LCS.
    *    **Бинарный поиск:** Не применяется для поиска наибольшей общей подпоследовательности.

**Пример (псевдокод):**

```
function longest_common_subsequence(text1, text2):
    m = length(text1)
    n = length(text2)
    dp = таблица(m+1, n+1)
    for i from 0 to m:
      dp[i][0] = 0
    for j from 0 to n:
      dp[0][j] = 0
    for i from 1 to m:
       for j from 1 to n:
          if text1[i-1] == text2[j-1]:
             dp[i][j] = dp[i-1][j-1] + 1
          else:
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]
```
**Примеры реализации в Python:**
```python
def longest_common_subsequence(text1, text2):
    m = len(text1)
    n = len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

print(f"Длина LCS для 'abcde' и 'ace': {longest_common_subsequence('abcde', 'ace')}")  # Выведет: Длина LCS для 'abcde' и 'ace': 3
print(f"Длина LCS для 'abc' и 'def': {longest_common_subsequence('abc', 'def')}")  # Выведет: Длина LCS для 'abc' и 'def': 0
print(f"Длина LCS для 'AGGTAB' и 'GXTXAYB': {longest_common_subsequence('AGGTAB', 'GXTXAYB')}")  # Выведет: Длина LCS для 'AGGTAB' и 'GXTXAYB': 4
```

**Разбор вариантов:**
*  **A. Для решения задачи можно использовать алгоритм поиска в глубину (DFS).:** Неправильно. DFS не гарантирует нахождения LCS.
*  **B. Для решения этой задачи можно использовать жадный алгоритм, сравнивая символы по очереди.:** Неправильно. Жадные алгоритмы не гарантируют нахождения LCS.
*   **C. Для решения задачи можно использовать алгоритм  динамического программирования, который строит таблицу, отражающую длины LCS для всех возможных подстрок.:** Правильно.
*  **D. Для решения задачи можно использовать бинарный поиск.:** Неправильно.

**В результате:**
*  Алгоритм динамического программирования обеспечивает эффективное решение задачи LCS.
*  Строится таблица, которая хранит длины LCS для подстрок.
*  Используется рекуррентная формула для вычисления значений таблицы.

Таким образом, правильным ответом является **C. Для решения задачи можно использовать алгоритм  динамического программирования, который строит таблицу, отражающую длины LCS для всех возможных подстрок.**
