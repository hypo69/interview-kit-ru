### `question_686.md`

**Вопрос 686.** Дан целочисленный массив `nums` и два целых числа `minK` и `maxK`. Необходимо разработать алгоритм, который подсчитывает количество подмассивов (непрерывных частей массива) в `nums`, удовлетворяющих следующим условиям:

*   Минимальное значение в подмассиве равно `minK`.
*   Максимальное значение в подмассиве равно `maxK`.

**Примеры:**

```
Ввод: nums = [1,3,5,2,7,5], minK = 1, maxK = 5
Вывод: 2

Ввод: nums = [1,1,1,1], minK = 1, maxK = 1
Вывод: 10
```

-   A. Для решения задачи можно отсортировать подмассивы и проверить их на соответствие minK и maxK, если подходит, то увеличиваем счетчик.
-   B. Для решения задачи, необходимо  итерироваться по массиву и генерировать все возможные подмассивы, и каждый раз проверять условия минимума и максимума.
-   C. Для решения задачи нужно использовать sliding window подход и поддерживать указатели left и right, при этом используя динамическое программирование для оптимизации.
-   D. Для решения задачи можно использовать два указателя `left` и `right`, двигая правый и отслеживая min и max в диапазоне `left`, `right`, а также `last_min` и  `last_max` индексы, что позволяет переиспользовать данные, чтобы не пересчитывать min и max.

**Правильный ответ: D**

**Объяснение:**

Для эффективного решения задачи подсчета подмассивов, удовлетворяющих условию минимума и максимума, можно использовать подход с двумя указателями и отслеживанием положения minK и maxK, что позволит переиспользовать результаты, и избежать повторного поиска минимума и максимума на каждом шаге.

*   **Алгоритм с двумя указателями:**
    1.  **Инициализация:**
         *  `left` - Указатель на левую границу текущего подмассива.
        *  `right` - Указатель на правую границу текущего подмассива.
         * `result` - Кол-во подмассивов, удовлетворяющих условию.
        * `last_min` и `last_max` -  индексы последних `minK` и `maxK`.
    2.   **Передвигаем правую границу:**
          *  Подвигаем `right` вправо, пока не достигнем конца списка.
        *   **Обновляем `last_min` и `last_max`:**
           *  Обновляем позиции `last_min` и  `last_max`  если встречаем  новые минимальные и максимальные элементы.
       *  **Проверка условия:**
         *  Если в текущем окне,  `last_min`  и `last_max`   за пределами окна, то левую границу переносим за них (то есть  `left = min(last_min, last_max)+1`), так как слева нет вариантов для подходящего подмассива, а так же  обнуляем кол-во подходящих подмассивов для левой границы.
      * **Подсчет:**   Если  оба индекса `last_min`  и  `last_max`  находятся в текущем окне, то добавляем в результат кол-во подходящих подмассивов, где левый указатель может располагаться до индекса, который идет за последним  `last_min` и  `last_max`   (т.е `min(last_min, last_max)+1` ) -  формула `max(0, min(last_min, last_max)-left+1)` .
   3. **Возврат результата:** Возвращаем посчитанное количество подмассивов.

*   **Преимущества алгоритма:**
    *   **Линейная сложность:** Алгоритм имеет временную сложность O(n), поскольку оба указателя пробегают по массиву не более чем один раз.
    *   **Эффективность:** Не требуется перебирать все подмассивы, что позволяет получить нужный результат за линейное время.

**Примеры (псевдокод):**

```
function count_fixed_bound_subarrays(nums, minK, maxK):
    left = 0
    result = 0
    last_min = -1
    last_max = -1
    for right in range(length(nums)):
        if nums[right] < minK or nums[right] > maxK: # проверяем ограничения
          last_min = -1
          last_max = -1
          left = right + 1 # сбрасываем счетчик, так как больше не может быть правильных подмассивов слева.
          continue
        if nums[right] == minK:
            last_min = right
        if nums[right] == maxK:
            last_max = right
        if last_min != -1 and last_max != -1:
          result += max(0, min(last_min, last_max)-left+1 )
    return result
```

**Примеры реализации в Python:**

```python
def count_fixed_bound_subarrays(nums, minK, maxK):
    left = 0
    result = 0
    last_min = -1
    last_max = -1
    for right, val in enumerate(nums):
        if val < minK or val > maxK:
           last_min = -1
           last_max = -1
           left = right + 1
           continue
        if val == minK:
           last_min = right
        if val == maxK:
           last_max = right
        if last_min != -1 and last_max != -1:
          result += max(0, min(last_min, last_max)-left+1 )
    return result

nums = [1,3,5,2,7,5]
minK = 1
maxK = 5
print(f"Ввод: nums = {nums}, minK = {minK}, maxK = {maxK}")
print(f"Вывод: {count_fixed_bound_subarrays(nums, minK, maxK)}") # Выведет: Вывод: 2
nums2 = [1,1,1,1]
minK2 = 1
maxK2 = 1
print(f"Ввод: nums = {nums2}, minK = {minK2}, maxK = {maxK2}")
print(f"Вывод: {count_fixed_bound_subarrays(nums2, minK2, maxK2)}") # Выведет: Вывод: 10
nums3 = [1,3,2,2,4,5]
minK3 = 1
maxK3 = 4
print(f"Ввод: nums = {nums3}, minK = {minK3}, maxK = {maxK3}")
print(f"Вывод: {count_fixed_bound_subarrays(nums3, minK3, maxK3)}") # Выведет: Вывод: 10
```

**Разбор вариантов:**
*   **A. Для решения задачи можно отсортировать подмассивы и проверить их на соответствие minK и maxK, если подходит, то увеличиваем счетчик.:** Неправильно. Сортировка каждого подмассива неэффективно.
*   **B. Для решения задачи, необходимо  итерироваться по массиву и генерировать все возможные подмассивы, и каждый раз проверять условия минимума и максимума.:** Неправильно. Этот метод имеет  сложность O(n^3).
*  **C. Для решения задачи нужно использовать sliding window подход и поддерживать указатели left и right, при этом используя динамическое программирование для оптимизации.:** Неправильно, хоть это и похоже на правильный ответ, но не использует механизм отслеживания индексов last_min и last_max.
*   **D. Для решения задачи можно использовать два указателя `left` и `right`, двигая правый и отслеживая min и max в диапазоне `left`, `right`, а также `last_min` и  `last_max` индексы, что позволяет переиспользовать данные, чтобы не пересчитывать min и max.:** Правильно.

**В результате:**
*  Использование двух указателей позволяет  проверить все подмассивы и применить к ним условие с эффективностью O(n).
*  Использование `last_min`  и `last_max`  позволяет не пересчитывать мин и макс  значения  на каждом шаге.

Таким образом, правильным ответом является **D. Для решения задачи можно использовать два указателя `left` и `right`, двигая правый и отслеживая min и max в диапазоне `left`, `right`, а также `last_min` и  `last_max` индексы, что позволяет переиспользовать данные, чтобы не пересчитывать min и max.**
