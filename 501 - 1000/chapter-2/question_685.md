### `question_685.md`

**Вопрос 685.** Дан целочисленный массив `nums` и целое число `k`, представляющее размер подмассива. Необходимо разработать алгоритм, который вычисляет максимальное значение для каждого скользящего подмассива размера `k` в массиве `nums`.

**Примеры:**
```
Ввод: nums = [1,3,-1,-3,5,3,6,7], k = 3
Вывод: [3,3,5,5,6,7]

Ввод: nums = [1], k = 1
Вывод: [1]
```

-   A. Для решения задачи нужно отсортировать все подмассивы и взять максимальное значение.
-  B. Для решения задачи нужно использовать алгоритм, который проходит по всем элементам массива и использует два вложенных цикла, чтобы перебрать подмассивы размера k.
-   C. Для решения задачи  нужно использовать очередь для хранения только k элементов и  максимальное значение нужно вычислять каждый раз когда добавляется новый элемент и удаляется элемент который вышел за границы k.
- D. Для решения задачи можно использовать дек (двусторонняя очередь), в котором будем хранить только индексы элементов, которые являются кандидатами на максимум, тем самым, позволяя отслеживать индексы элементов, и при этом  иметь возможность  эффективного добавления и удаления элементов с начала или конца дека.

**Правильный ответ: D**

**Объяснение:**

Для эффективного решения задачи поиска максимума в каждом скользящем окне размера `k` в массиве, нужно использовать структуру данных "дек" (двусторонняя очередь).  Использование дека  позволяет отслеживать индексы  кандидатов на максимум в окне.

*   **Алгоритм с использованием дека (двусторонней очереди):**
    1. **Инициализация:**
          *  Создаем пустую деку.
         *    Результатом является список.
    2. **Итерация по массиву:**
         *  Обходим массив слева направо.
          *    **Удаление старых элементов:** Если  первый элемент дека, за пределами текущего окна, удаляем его из начала дека.
          * **Удаление меньших элементов:**  Удаляем с конца все индексы  элементов, которые меньше текущего элемента.
          * **Добавление текущего индекса:**  Добавляем текущий индекс элемента в конец дека.
       *  **Запись максимального:** Когда длина окна достигла k, то записываем максимальное значение из начала дека в результирующий массив, так как это индекс самого большого элемента в текущем окне.
    3.  **Возврат результата:** Возвращаем результат - список максимумов.

*   **Преимущества этого алгоритма:**
    *  **Сложность:**  Обеспечивает линейную временную сложность O(n), поскольку каждый элемент массива добавляется в дек и удаляется из него не более одного раза.
     *  **Эффективность:** Позволяет отслеживать кандидатов на максимум в окне, не перебирая их повторно, при этом обеспечивает константную сложность для получения максимального элемента в окне.

*  **Почему не подходят другие варианты:**
      * **Вариант А:** Сортировка  всех подмассивов  является  неэффективным решением и займет O(n^2 log n).
     * **Вариант B:** Использование двух вложенных циклов для перебора подмассивов приведет к сложности O(n\*k), а не O(n log n)
     *  **Вариант C:** Использование очереди не позволит получить максимальное значение за O(1) время.

**Примеры (псевдокод):**
```
function max_sliding_window(nums, k)
  deque = []
  result = []
  for i = 0 to nums.length - 1:
    # Remove indices outside the window
      while deque is not empty and deque[0] < i - k + 1
        deque.pop_front()

     # remove elements less than current
     while deque is not empty and nums[deque[-1]] <= nums[i]:
         deque.pop_back()
      deque.append(i) # add new index
      if i >= k - 1:
         result.append(nums[deque[0]]) # add to results if window is at least k
   return result
```
**Примеры реализации в Python:**

```python
from collections import deque

def max_sliding_window(nums, k):
    d = deque()
    res = []
    for i, x in enumerate(nums):
        while d and d[0] < i - k + 1:
            d.popleft()
        while d and nums[d[-1]] <= x:
            d.pop()
        d.append(i)
        if i >= k - 1:
            res.append(nums[d[0]])
    return res

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(f"Вход: nums = {nums}, k = {k}")
print(f"Выход: {max_sliding_window(nums,k)}")  # Вывод: [3, 3, 5, 5, 6, 7]

nums2 = [1]
k2 = 1
print(f"Вход: nums = {nums2}, k = {k2}")
print(f"Выход: {max_sliding_window(nums2, k2)}")  # Вывод: [1]
```

**Разбор вариантов:**
*   **A. Для решения задачи нужно отсортировать все подмассивы и взять максимальное значение.:** Неправильно.
*   **B. Для решения этой задачи нужно использовать алгоритм, который проходит по всем элементам массива и использует два вложенных цикла, чтобы перебрать подмассивы размера k.:** Неправильно. Этот метод не оптимален.
*  **C. Для решения этой задачи нужно использовать очередь для хранения только k элементов и  максимальное значение нужно вычислять каждый раз когда добавляется новый элемент и удаляется элемент который вышел за границы k.:** Неправильно.  Очередь не позволяет быстро получать максимум.
*   **D. Для решения этой задачи можно использовать дек (двусторонняя очередь), в котором будем хранить только индексы элементов, которые являются кандидатами на максимум, тем самым, позволяя отслеживать индексы элементов, и при этом  иметь возможность  эффективного добавления и удаления элементов с начала или конца дека.:** Правильно.

**В результате:**
*  Использование дека позволяет достичь сложности O(n).
*  Используется для отслеживания индексов, где хранятся максимальные значения,  имеет возможность удалять не нужные данные с обеих сторон.

Таким образом, правильным ответом является **D. Для решения этой задачи можно использовать дек (двусторонняя очередь), в котором будем хранить только индексы элементов, которые являются кандидатами на максимум, тем самым, позволяя отслеживать индексы элементов, и при этом  иметь возможность  эффективного добавления и удаления элементов с начала или конца дека.**
