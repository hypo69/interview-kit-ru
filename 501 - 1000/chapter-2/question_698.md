### `question_699.md`

**Вопрос 699.** Дан массив строк `words`. Разработайте алгоритм, который возвращает новый список, содержащий только те строки, которые могут быть набраны с использованием клавиш только одного ряда на стандартной QWERTY-клавиатуре.

**Примеры:**
```
Ввод: words = ["Hello","Alaska","Dad","Peace"]
Вывод: ["Alaska","Dad"]

Ввод: words = ["omk"]
Вывод: []
```

-   A. Для решения задачи нужно перебрать все слова и проверять вложенными циклами символы на то, чтобы они находились в одном ряду.
-   B. Для решения задачи нужно использовать динамическое программирование.
-   C. Для решения задачи нужно использовать только рекурсивные функции.
-   D. Для решения задачи нужно  создать три множества  для строк QWERTY клавиатуры, и для каждого слова  нужно проверить, что все его символы принадлежат  одному из этих множеств.

**Правильный ответ: C**

**Объяснение:**

Для решения задачи отбора слов, которые могут быть набраны на одной строке клавиатуры, оптимальным подходом будет создание множеств для каждой строки и последующая проверка каждого слова на принадлежность символов к одному множеству.

*   **Алгоритм с множествами:**
    1.  **Создание множеств:** Создаем три множества, которые представляют три строки QWERTY-клавиатуры:
          *  `row1 = {'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'}`
         *   `row2 = {'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'}`
         * `row3 = {'z', 'x', 'c', 'v', 'b', 'n', 'm'}`
    2.  **Итерация по словам:** Проходим по каждому слову в массиве `words`.
    3.  **Проверка принадлежности к строке:** Проверяем, что все символы текущего слова, приведенные к нижнему регистру, принадлежат одному из созданных множеств.
          *   Для этого, слово преобразовывается во множество, и проверяется является ли это множество подмножеством одного из множеств строк клавиатуры (используется метод `issubset()`).
       *   Если это условие выполнено, значит слово можно набрать на одной строке клавиатуры, и оно добавляется в результирующий список.
     4.  **Результат:** Возвращаем отфильтрованный список.

*   **Преимущества алгоритма:**
    *  **Эффективность:** Множества обеспечивают быструю проверку принадлежности элементов O(1) на основе их хеш-значений.
    *  **Лаконичность:** Код является простым, понятным и легко читаемым.

**Примеры (псевдокод):**
```
function find_words_from_keyboard_row(words):
    row1 = {'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'}
    row2 = {'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'}
    row3 = {'z', 'x', 'c', 'v', 'b', 'n', 'm'}
    result = []
    for word in words:
        word_set = set(word.lower())
       if word_set.issubset(row1) or  word_set.issubset(row2) or word_set.issubset(row3):
         result.append(word)
    return result
```
**Примеры реализации в Python:**
```python
def find_words_from_keyboard_row(words):
    row1 = {'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'}
    row2 = {'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'}
    row3 = {'z', 'x', 'c', 'v', 'b', 'n', 'm'}

    result = []
    for word in words:
       word_set = set(word.lower())
       if word_set.issubset(row1) or  word_set.issubset(row2) or word_set.issubset(row3):
         result.append(word)
    return result
words1 = ["Hello","Alaska","Dad","Peace"]
print(f"Ввод: words = {words1}")
print(f"Вывод: {find_words_from_keyboard_row(words1)}")  # Выведет:  Вывод: ['Alaska', 'Dad']


words2 = ["omk"]
print(f"Ввод: words = {words2}")
print(f"Вывод: {find_words_from_keyboard_row(words2)}")  # Выведет: Вывод: []

words3 = ["adsf","qwer","mxcv","asdfghjkl", "qwertyuiop"]
print(f"Ввод: words = {words3}")
print(f"Вывод: {find_words_from_keyboard_row(words3)}")  # Выведет: Вывод: ['adsf', 'qwer', 'mxcv', 'asdfghjkl', 'qwertyuiop']
```
**Разбор вариантов:**
*   **A. Для решения задачи необходимо использовать вложенные циклы и для каждого слова проверять, из какой строки оно.:** Неправильно. Использование вложенных циклов будет менее эффективным.
*    **B. Для решения задачи нужно использовать регулярные выражения.:** Неправильно.
*   **C. Для решения задачи нужно  создать множество символов для каждого ряда клавиатуры и проверять для каждого слова, что все его символы принадлежат  одному из этих множеств.:** Правильно.
*  **D. Для решения задачи можно сначала отсортировать список слов по их длине и затем проверять их.:** Неправильно.

**В результате:**
* Использование множества для хранения символов каждого ряда, делает проверку принадлежности эффективной.
* Метод `issubset` позволяет определить, является ли множество подмножеством другого.

Таким образом, правильным ответом является **C. Для решения задачи нужно  создать множество символов для каждого ряда клавиатуры и проверять для каждого слова, что все его символы принадлежат  одному из этих множеств.**
