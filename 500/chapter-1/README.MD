## Вопросы для собеседования по Python

[**Вопрос 1.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python список (list) — одна из наиболее часто используемых структур данных, известная своей способностью хранить последовательность элементов. Что происходит, когда вы используете метод `append()` в списке, чтобы добавить новый элемент, а затем пытаетесь использовать метод `extend()`, чтобы добавить другую последовательность к тому же списку?

A. Метод `append()` добавит каждый символ нового элемента отдельно, а метод `extend()` создаст новый список внутри существующего списка.
B. Метод `append()` добавит новый элемент как один элемент в конец списка, а метод `extend()` будет итерировать по элементам и добавлять каждый из них по отдельности к исходному списку.
C. Оба метода `append()` и `extend()` добавят их содержимое одинаковым образом, создав вложенный список внутри исходного списка.
D. Метод `append()` заменяет существующий список, а метод `extend()` очищает список перед добавлением новой последовательности.

[**Вопрос 2.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python цикл `for` очень гибок для итерации по различным итерируемым объектам. Рассмотрим ситуацию, когда у вас есть словарь со строковыми ключами и целочисленными значениями. Какой из следующих вариантов правильно итерирует как по ключам, так и по значениям этого словаря?

A. `for key, value in dictionary.items(): print(key, value)`
B. `for key in dictionary: print(key, dictionary[key])`
C. `for value in dictionary.values(): print(value)`
D. `for key in dictionary.keys(): print(key)`

[**Вопрос 3.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python области видимости переменных играют важную роль в понимании того, как переменные доступны или изменяются внутри вложенных блоков кода. Если переменная с одним и тем же именем определена как внутри функции, так и вне ее, что произойдет, когда функция попытается изменить эту переменную без какого-либо дополнительного ключевого слова?

A. Функция напрямую изменит глобальную переменную без какой-либо ошибки.
B. Python вызовет ошибку `SyntaxError` из-за конфликтующих областей видимости переменных.
C. Функция создаст новую локальную переменную с тем же именем, что и глобальная переменная, оставив глобальную переменную без изменений.
D. Глобальная переменная будет перекрыта, и ее значение изменится только тогда, когда функция завершит свою работу.

[**Вопрос 4.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Python поддерживает несколько типов данных, и строки являются одним из наиболее часто используемых типов данных. Какой из следующих способов является правильным для конкатенации трех строк в Python, гарантируя, что результатом будет одна строка без каких-либо дополнительных пробелов между ними?

A. `"Python" + "is" + "awesome"`
B. `"Python", "is", "awesome"`
C. `"Python" + " " + "is" + " " + "awesome"`
D. `"Python".join(["is", "awesome"])`

[**Вопрос 5.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
При определении функции в Python можно установить значения параметров по умолчанию, что обеспечивает большую гибкость при вызове функции. Каков будет результат вызова следующей функции: `def multiply(a, b=2): return a * b`, если функция вызывается как `multiply(5)`?

A. Функция вернет 5.
B. Функция вызовет `TypeError` из-за отсутствующего аргумента.
C. Функция вернет 10, так как будет использовано значение по умолчанию `b`.
D. Функция вернет `None`, поскольку предоставлен только один параметр.

[**Вопрос 6.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python, какой метод можно использовать для замены частей строки другой строкой, и каков синтаксис этого метода, если вы хотите заменить `'cat'` на `'dog'` в строке `s = "The cat sat on the mat"`?

A. `s.replaceString('cat', 'dog')`
B. `s.replace('cat', 'dog')`
C. `s.stringReplace('cat', 'dog')`
D. `s.replaceAll('cat', 'dog')`

[**Вопрос 7.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
При создании функции в Python, которая вычисляет факториал числа с использованием рекурсии, какое из следующих определений функции реализовано правильно и соответствует принципам рекурсии?

A. `def factorial(n): return n * factorial(n-1) if n > 1 else 1`
B. `def factorial(n): return factorial(n-1) * n if n == 0 else 1`
C. `def factorial(n): factorial(n-1) * n`
D. `def factorial(n): return n * factorial(n) if n > 1 else 1`

[**Вопрос 8.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Какое из следующих утверждений о списках Python является истинным, особенно когда речь идет о гибкости типов элементов, которые может содержать список?

A. Списки Python могут содержать только элементы одного и того же типа данных, такие как все целые числа или все строки.
B. Списки Python могут содержать элементы разных типов данных, такие как целые числа, строки и объекты, в одном и том же списке.
C. Списки Python не могут содержать другие типы коллекций, такие как другие списки или словари.
D. Списки Python являются неизменяемыми, то есть после создания их элементы не могут быть изменены.

[**Вопрос 9.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python, как можно эффективно объединить несколько строк, хранящихся в списке с именем `strings = ["Python", "is", "awesome"]`, чтобы сформировать одну строку `"Python is awesome"`?

A. `" ".join(strings)`
B. `strings.join(" ")`
C. `concatenate(" ", strings)`
D. `strings.concatenate(" ")`

[**Вопрос 10.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Рассмотрите блок кода Python для обработки исключений при попытке преобразовать целое число из пользовательского ввода, используя функцию `input()`. Какая реализация правильно обрабатывает ввод, который может быть недействительным целым числом, например `'пять'`, и выводит сообщение об ошибке?

A.
```python
try:
    num = int(input("Введите число: "))
except ValueError:
    print("Это не является действительным числом!")
```
B.
```python
try:
    num = int(input("Введите число: "))
    if not num:
        print("Это не является действительным числом!")
```
C.
```python
num = int(input("Введите число: "))
except ValueError:
    print("Это не является действительным числом!")
```
D.
```python
try:
    num = int(input("Введите число: "))
catch (ValueError):
    print("Это не является действительным числом!")
```

[**Вопрос 11.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python имена переменных чувствительны к регистру, что означает, что `variable` и `Variable` считаются интерпретатором разными. Учитывая эту информацию, какое из следующих утверждений будет верным, если `variable` и `Variable` были определены как целые числа в сценарии Python?

A. `print(variable)` и `print(Variable)` выведут одинаковое значение, если обе переменные имеют одно и то же значение.
B. Произойдет ошибка, сообщающая, что имена переменных не могут быть похожими, за исключением их регистра.
C. Python автоматически перезапишет значение первой переменной (`variable`) значением второй (`Variable`) во всем сценарии.
D. Невозможно использовать одно и то же имя с разными регистрами для разных переменных в одном сценарии.

[**Вопрос 12.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Python поддерживает несколько типов данных, и строки являются одним из наиболее часто используемых. При рассмотрении целого числа (int), числа с плавающей точкой (float) и строкового (str) типов данных, какой из следующих фрагментов кода правильно преобразует строковое представление числа в число с плавающей точкой и впоследствии добавляет его к целому числу перед выводом результата?

A.
```python
str_num = "12.5"
int_num = 5
result = float(str_num) + int_num
print(result)
```
B.
```python
str_num = "12.5"
int_num = 5
result = str_num + int_num
print(result)
```
C.
```python
str_num = "12.5"
int_num = 5
result = int(str_num) + int_num
print(result)
```
D.
```python
str_num = "12.5"
int_num = 5
result = float(int_num) + str_num
print(result)
```

[**Вопрос 13.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Учитывая динамическую систему типизации Python, какой из следующих фрагментов кода демонстрирует гибкость присваивания типов в Python, позволяя переназначать переменные на различные типы данных в пределах одного и того же сценария?

A.
```python
x = 10
x = "hello"
print(x)
```
B.
```python
x = 10
y : str = "hello"
print(x+y)
```
C.
```python
x = 10
str(x) = "hello"
print(x)
```
D.
```python
x : int = 10
x : str = "hello"
print(x)
```

[**Вопрос 14.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Функции Python определяются с помощью ключевого слова `def`, за которым следует имя функции и круглые скобки. Какое из следующих определений включает параметр по умолчанию, позволяя вызывать функцию с меньшим количеством аргументов, чем определено параметров?

A. `def my_function(a, b): return a + b`
B. `def my_function(a, b=10): return a + b`
C. `def my_function(a=5, b): return a + b`
D. `def my_function(a): return a`

[**Вопрос 15.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
При итерировании по списку в Python для вычисления суммы его элементов, какая из следующих конструкций цикла правильно сформулирована, чтобы избежать ошибки `IndexError` и успешно вычислить общую сумму?

A.
```python
my_list = [1, 2, 3, 4, 5]
sum = 0
for i in range(len(my_list)):
    sum += my_list[i+1]
```
B.
```python
my_list = [1, 2, 3, 4, 5]
sum = 0
for i in my_list:
    sum += i
```
C.
```python
my_list = [1, 2, 3, 4, 5]
sum = 0
for i in range(len(my_list)+1):
    sum += my_list[i]
```
D.
```python
my_list = [1, 2, 3, 4, 5]
sum = 0
for i in range(5):
  sum += my_list[i]
```

[**Вопрос 16.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Каков будет вывод следующего фрагмента кода Python при его выполнении?
```python
x = "Welcome to Python programming where the value of y is "
y = 5*3
print(x + str(y))
```
A. Welcome to Python programming where the value of y is 15
B. Ошибка из-за несовместимых типов данных
C. Welcome to Python programming where the value of y is y
D. Ничего из вышеперечисленного

[**Вопрос 17.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Каково будет поведение следующей Python функции?
```python
def check_number(n):
    if n % 2 == 0:
        return "Even"
    elif n % 3 == 0:
        return "Divisible by 3"
    else:
        return "Other"
```

A. Функция возвращает "Even" только если n делится на 2 и 3.
B. Функция возвращает "Divisible by 3" для всех чисел, делящихся на 3, независимо от того, являются ли они четными.
C. Функция возвращает "Even" для всех четных чисел, и "Divisible by 3" для чисел не четных, но делящихся на 3.
D. Функция не может вернуть "Other".

[**Вопрос 18.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Дан следующий код модификации списка Python, каков будет окончательный вывод?
```python
numbers = [2, 4, 6, 8, 10]
for i in range(len(numbers)):
    numbers[i] = numbers[i] + 3
print(numbers)
```

A. `[5, 7, 9, 11, 13]`
B. `[2, 4, 6, 8, 10]`
C. `[3, 6, 9, 12, 15]`
D. `[5, 7, 9, 11, 15]`

[**Вопрос 19.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Рассмотрите выполнение следующих операций над словарем Python. Каково состояние словаря `person` после завершения всех операций?
```python
person = {'name': 'Alice', 'age': 25, 'city': 'London'}
del person['name']
person['age'] = 26
person['city'] = 'New York'
```

A. `{'name': 'Alice', 'age': 26, 'city': 'New York'}`
B. `{'age': 26}`
C. `{'age': 26, 'city': 'New York'}`
D. `{'name': 'Alice', 'city': 'New York'}`

[**Вопрос 20.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Каков будет результат выполнения следующего цикла Python и условных операторов?
```python
result = []
for i in range(1, 11):
    if i % 2 == 0:
        result.append(f'{i} is even')
        if i % 4 == 0:
            result.append(f'{i} is divisible by 4')
    elif i%2 != 0:
        result.append(f'{i} is odd')
print(result)
```

A. `['2 is even', '4 is divisible by 4', '6 is even', '8 is divisible by 4', '10 is even']`
B. `['1 is odd', '2 is even', '3 is odd', '4 is divisible by 4', '5 is odd', '6 is even', '7 is odd', '8 is divisible by 4', '9 is odd', '10 is even']`
C. `['2 is even', '4 is even', '6 is even', '8 is even', '10 is even']`
D. `['2 is divisible by 4', '4 is divisible by 4', '6 is divisible by 4', '8 is divisible by 4', '10 is divisible by 4']`

[**Вопрос 21.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python-программировании каково значение метода `__init__` в классе и чем он отличается от других методов, которые могут быть определены в классе? В частности, объясните, как функции `__init__` работают в объектно-ориентированном программировании, включая ее роль в создании объектов, и сравните это с такими методами, как `__str__` и пользовательские функции, которые могут быть добавлены позже в класс.

A. Метод `__init__` отвечает за инициализацию вновь созданных объектов, действуя как конструктор, задавая начальное состояние или свойства экземпляра при создании объекта.
B. Метод `__init__` предоставляет строковое представление объекта, в основном для целей отладки, и может быть вызван напрямую для просмотра отформатированной строки.
C. Метод `__init__` используется для определения того, как экземпляры класса должны быть выведены в удобочитаемом формате в консоль, обычно вызывается при использовании `print()` или `str()`.
D. Метод `__init__` — это метод, автоматически вызываемый после выполнения любой функции внутри класса, предоставляющий механизм очистки неиспользуемых переменных.

[**Вопрос 22.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python, `*args` и `**kwargs` часто используются в определениях функций для передачи переменного числа аргументов. Как именно эти специальные синтаксические элементы расширяют функциональность функции Python и каков правильный способ использовать их вместе в определении функции для поддержания правильного синтаксиса и гарантии того, что функция может принимать как позиционные, так и ключевые аргументы гибко?

A. `*args` позволяет передавать несколько ключевых аргументов, в то время как `**kwargs` обрабатывает несколько позиционных аргументов, что упрощает вызовы функций.
B. `*args` используется для передачи переменного числа позиционных аргументов в виде кортежа, а `**kwargs` используется для переменных ключевых аргументов в виде словаря, что позволяет гибко вводить аргументы.
C. `*args` можно использовать для передачи всех аргументов в виде списка, в то время как `**kwargs` работает только с аргументами на основе строк. Порядок синтаксиса не важен.
D. `*args` требует, чтобы все аргументы были одного и того же типа данных, а `**kwargs` принуждает передавать только целые значения в качестве ключевых аргументов для обеспечения безопасности типов.

[**Вопрос 23.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python, списковое включение (list comprehension) — это краткий способ создания списков. Рассмотрим следующий код: `squared_numbers = [x**2 for x in range(10) if x % 2 == 0]`. Как списковое включение в этом примере сравнивается с традиционным созданием списка на основе цикла `for`, и каковы преимущества использования спискового включения в программировании на Python при работе с большими наборами данных или сложными преобразованиями?

A. Списковое включение предоставляет менее эффективный способ создания списков по сравнению с традиционными циклами, часто приводя к увеличению временной сложности.
B. Списковое включение предлагает читаемый и эффективный подход к созданию списков в одну строку, значительно сокращая длину кода и повышая производительность благодаря оптимизированным внутренним механизмам Python.
C. Списковое включение не может обрабатывать условия типа `if` и его основная выгода заключается лишь в преобразовании одного списка в другой той же длины без изменений.
D. Списковое включение ограничено созданием числовых списков и не может использоваться для манипуляции со строками или создания сложных объектов внутри списка.

[**Вопрос 25.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python ключевые слова `global` и `nonlocal` служат разным целям при работе с областью видимости переменных. Как эти ключевые слова функционируют во вложенных функциях или модулях и какой правильный способ использовать их для изменения значений переменных, существующих в разных областях видимости, таких как внутри внешней функции или на глобальном уровне модуля?

A. Ключевое слово `global` используется для изменения переменных во вложенных функциях, в то время как `nonlocal` можно использовать для доступа к глобальным переменным напрямую из любой вложенной области видимости.
B. Ключевое слово `global` позволяет изменять переменную на уровне модуля внутри функции, в то время как `nonlocal` обеспечивает доступ к ближайшей включающей области видимости, не являющейся глобальной, помогая управлять вложенными переменными функции.
C. Ключевое слово `global` в основном предназначено для объявления констант в нескольких функциях, а `nonlocal` используется исключительно для изменения переменных уровня класса изнутри методов.
D. Ключевые слова `global` и `nonlocal` взаимозаменяемы в Python, позволяя изменять любую переменную независимо от ее исходной области видимости.

[**Вопрос 26.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Каково значение ключевого слова `None` в Python?

A. Оно указывает на отсутствие значения или нулевое значение в переменной.
B. Это специальный тип данных, который может быть присвоен только строковым переменным.
C. Он представляет нулевое числовое значение в числовых вычислениях.
D. Он используется для определения бесконечного цикла в программировании Python.

[**Вопрос 27.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Каков будет вывод следующего фрагмента кода Python?
```python
x = 5
y = 10
print(x < y)
```

A. Yes
B. No
C. True
D. Error

[**Вопрос 28.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
В Python, что делает метод `append()` при применении к списку?

A. Он сливает другой список с текущим списком в указанной позиции.
B. Он добавляет новый элемент в конец списка, увеличивая его размер.
C. Он вычисляет общую сумму всех числовых элементов в списке.
D. Он удаляет последний элемент списка и возвращает его.

[**Вопрос 29.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Дан следующий словарь Python, как вы получите доступ к значению, связанному с ключом `'color'`?
```python
car = {"brand": "Ford", "model": "Mustang", "year": 1964, "color": "red"}
```

A. `car[1]`
B. `car.get("color")`
C. `car[color]`
D. `car['color']`

[**Вопрос 30.**](https://github.com/hypo69/interview-kit-ru/blob/master/500/chapter-1/question_055.md)
Что делает метод `split()` в Python строках?

A. Разделяет строку на подстроки в местах, где встречается указанный разделитель, и возвращает эти подстроки в виде списка.
B. Объединяет несколько строк в одну строку, разделенную указанным символом.
C. Выполняет поиск указанной подстроки в строке и возвращает ее позицию.
D. Заменяет указанные элементы строки новой строкой.
