### `question_007.md` (ISP - Introduction)

**Вопрос 007.** Что такое принцип разделения интерфейсов (Interface Segregation Principle - ISP) в объектно-ориентированном программировании, и какую проблему он призван решить?

A. ISP утверждает, что классы должны зависеть от минимального количества интерфейсов, необходимых для их функционирования, чтобы избежать ненужных зависимостей.
B. ISP утверждает, что большие интерфейсы лучше, чем маленькие, потому что они предоставляют больше возможностей для реализации.
C. ISP утверждает, что классы должны реализовывать все методы интерфейса, который они реализуют, даже если эти методы не используются.
D. ISP утверждает, что все интерфейсы должны быть реализованы в одном классе, чтобы уменьшить количество классов в проекте.

**Правильный ответ: A**

**Объяснение:**

Принцип разделения интерфейсов (Interface Segregation Principle - ISP) — это один из принципов SOLID, который фокусируется на проектировании интерфейсов.

*   **Суть ISP:** Клиенты (классы, модули) не должны быть вынуждены зависеть от методов, которые они не используют. Вместо одного большого интерфейса лучше создавать много маленьких, специализированных интерфейсов, чтобы клиенты зависели только от тех методов, которые им действительно нужны.

*   **Проблема, которую решает ISP:** Предотвращение "раздутых" интерфейсов, когда классы вынуждены реализовывать ненужные методы, что приводит к:
    *   Увеличению связности (coupling) между классами.
    *   Усложнению кода.
    *   Потенциальным ошибкам и неожиданному поведению.

*   **Вариант A верен:**  Это точное определение принципа ISP.
*   **Вариант B не верен:** Это противоречит ISP.
*   **Вариант C не верен:** Это тоже противоречит ISP.
*   **Вариант D не верен:** Количество классов увеличивается, но у них становится меньше обязанностей.

**Пример:**

Представим интерфейс `IWorker`, который содержит методы `work()` и `eat()`:

```python
class IWorker(ABC):
    @abstractmethod
    def work(self):
        pass
    @abstractmethod
    def eat(self):
        pass
```

Если у нас есть класс `Robot`, который может только работать, но не есть, то он будет вынужден реализовать метод `eat()`, который ему не нужен. ISP предлагает разделить интерфейс `IWorker` на два интерфейса: `IWorkable` и `IEatable`.

**В результате:**

ISP позволяет создавать более гибкие и слабосвязанные системы, где классы зависят только от необходимых им методов.

Таким образом, вариант A является правильным.
